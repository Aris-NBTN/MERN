!function () { "use strict"; !function () { function e() { } function t(e, t) { for (const n in t) e[n] = t[n]; return e } function n(e) { return e() } function i() { return Object.create(null) } function o(e) { e.forEach(n) } function r(e) { return "function" == typeof e } function s(e, t) { return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e } function c(e) { const t = {}; for (const n in e) "$" !== n[0] && (t[n] = e[n]); return t } function l(e, t, n) { e.insertBefore(t, n || null) } function a(e) { e.parentNode.removeChild(e) } function u() { return e = "", document.createTextNode(e); var e } function f(e, t, n) { null == n ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n) } function d(e, t) { for (const n in t) f(e, n, t[n]) } let p; function h(e) { p = e } function g() { if (!p) throw new Error("Function called outside component initialization"); return p } const m = [], y = [], $ = [], v = [], b = Promise.resolve(); let k = !1; function _(e) { $.push(e) } let w = !1; const x = new Set; function C() { if (!w) { w = !0; do { for (let e = 0; e < m.length; e += 1) { const t = m[e]; h(t), j(t.$$) } for (h(null), m.length = 0; y.length;)y.pop()(); for (let e = 0; e < $.length; e += 1) { const t = $[e]; x.has(t) || (x.add(t), t()) } $.length = 0 } while (m.length); for (; v.length;)v.pop()(); k = !1, w = !1, x.clear() } } function j(e) { if (null !== e.fragment) { e.update(), o(e.before_update); const t = e.dirty; e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(_) } } const I = new Set; function P(e, t) { -1 === e.$$.dirty[0] && (m.push(e), k || (k = !0, b.then(C)), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31 } function O(t, s, c, l, u, f, d = [-1]) { const g = p; h(t); const m = s.props || {}, y = t.$$ = { fragment: null, ctx: null, props: f, update: e, not_equal: u, bound: i(), on_mount: [], on_destroy: [], before_update: [], after_update: [], context: new Map(g ? g.$$.context : []), callbacks: i(), dirty: d, skip_bound: !1 }; let $ = !1; if (y.ctx = c ? c(t, m, ((e, n, ...i) => { const o = i.length ? i[0] : n; return y.ctx && u(y.ctx[e], y.ctx[e] = o) && (!y.skip_bound && y.bound[e] && y.bound[e](o), $ && P(t, e)), n })) : [], y.update(), $ = !0, o(y.before_update), y.fragment = !!l && l(y.ctx), s.target) { if (s.hydrate) { const e = function (e) { return Array.from(e.childNodes) }(s.target); y.fragment && y.fragment.l(e), e.forEach(a) } else y.fragment && y.fragment.c(); s.intro && ((v = t.$$.fragment) && v.i && (I.delete(v), v.i(b))), function (e, t, i) { const { fragment: s, on_mount: c, on_destroy: l, after_update: a } = e.$$; s && s.m(t, i), _((() => { const t = c.map(n).filter(r); l ? l.push(...t) : o(t), e.$$.on_mount = [] })), a.forEach(_) }(t, s.target, s.anchor), C() } var v, b; h(g) } function S(e, t, n) { return e(n = { path: t, exports: {}, require: function (e, t) { return function () { throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs") }(null == t && n.path) } }, n.exports), n.exports } var E = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateIcon = t.stringToIcon = void 0; const n = /^[a-z0-9]+(-[a-z0-9]+)*$/; t.stringToIcon = (e, n, i) => { let o = ""; const r = e.split(":"); if ("@" === e.slice(0, 1)) { if (r.length < 2 || r.length > 3) return null; o = r.shift().slice(1) } if (r.length > 3 || !r.length) return null; if (r.length > 1) { const e = r.pop(), i = r.pop(), s = { provider: r.length > 0 ? r[0] : o, prefix: i, name: e }; return n && !t.validateIcon(s) ? null : s } const s = r[0], c = s.split("-"); if (c.length > 1) { const e = { provider: o, prefix: c.shift(), name: c.join("-") }; return n && !t.validateIcon(e) ? null : e } if (i && "" === o) { const e = { provider: o, prefix: "", name: s }; return n && !t.validateIcon(e, i) ? null : e } return null }; t.validateIcon = (e, t) => !!e && !("" !== e.provider && !e.provider.match(n) || !(t && "" === e.prefix || e.prefix.match(n)) || !e.name.match(n)) })), M = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.merge = void 0, t.merge = function (e, t, n) { const i = Object.create(null), o = [e, t, n]; for (let e = 0; e < 3; e++) { const t = o[e]; if ("object" == typeof t && t) for (const e in t) { const n = t[e]; void 0 !== n && (i[e] = n) } } return i } })), T = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.fullIcon = t.iconDefaults = void 0, t.iconDefaults = Object.freeze({ body: "", left: 0, top: 0, width: 16, height: 16, rotate: 0, vFlip: !1, hFlip: !1 }), t.fullIcon = function (e) { return M.merge(t.iconDefaults, e) } })), A = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeIcons = void 0; const n = Object.keys(T.iconDefaults); t.mergeIcons = function (e, t) { const i = Object.create(null); return n.forEach((n => { if (void 0 !== e[n]) if (void 0 !== t[n]) switch (n) { case "rotate": return void (i[n] = (e[n] + t[n]) % 4); case "hFlip": case "vFlip": return void (i[n] = e[n] !== t[n]); default: i[n] = t[n] } else i[n] = e[n]; else void 0 !== t[n] && (i[n] = t[n]) })), i } })), R = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIconSet = void 0; const n = Object.keys(T.iconDefaults); function i(e, t, n, o = 0) { const r = e.parent; if (void 0 !== t[r]) return A.mergeIcons(t[r], e); if (void 0 !== n[r]) { if (o > 2) return null; const s = i(n[r], t, n, o + 1); if (s) return A.mergeIcons(s, e) } return null } t.parseIconSet = function (e, t, o = "none") { const r = []; if ("object" != typeof e) return "none" !== o && r; if (e.not_found instanceof Array && e.not_found.forEach((e => { t(e, null), "all" === o && r.push(e) })), "object" != typeof e.icons) return "none" !== o && r; const s = Object.create(null); n.forEach((t => { void 0 !== e[t] && "object" != typeof e[t] && (s[t] = e[t]) })); const c = e.icons; if (Object.keys(c).forEach((e => { const n = c[e]; "string" == typeof n.body && (t(e, Object.freeze(M.merge(T.iconDefaults, s, n))), r.push(e)) })), "object" == typeof e.aliases) { const n = e.aliases; Object.keys(n).forEach((e => { const o = i(n[e], c, n, 1); o && (t(e, Object.freeze(M.merge(T.iconDefaults, s, o))), r.push(e)) })) } return "none" === o ? r.length > 0 : r } })), F = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.listIcons = t.getIcon = t.iconExists = t.addIcon = t.addIconSet = t.getStorage = t.newStorage = void 0; const n = Object.create(null); function i(e, t) { return { provider: e, prefix: t, icons: Object.create(null), missing: Object.create(null) } } function o(e, t) { void 0 === n[e] && (n[e] = Object.create(null)); const o = n[e]; return void 0 === o[t] && (o[t] = i(e, t)), o[t] } t.newStorage = i, t.getStorage = o, t.addIconSet = function (e, t, n = "none") { const i = Date.now(); return R.parseIconSet(t, ((t, n) => { null === n ? e.missing[t] = i : e.icons[t] = n }), n) }, t.addIcon = function (e, t, n) { try { if ("string" == typeof n.body) return e.icons[t] = Object.freeze(T.fullIcon(n)), !0 } catch (e) { } return !1 }, t.iconExists = function (e, t) { return void 0 !== e.icons[t] }, t.getIcon = function (e, t) { const n = e.icons[t]; return void 0 === n ? null : n }, t.listIcons = function (e, t) { let i, r = []; return i = "string" == typeof e ? [e] : Object.keys(n), i.forEach((e => { let i; i = "string" == typeof e && "string" == typeof t ? [t] : void 0 === n[e] ? [] : Object.keys(n[e]), i.forEach((t => { const n = o(e, t), i = Object.keys(n.icons).map((n => ("" !== e ? "@" + e + ":" : "") + t + ":" + n)); r = r.concat(i) })) })), r } })), L = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.storageFunctions = t.addCollection = t.addIcon = t.getIconData = t.allowSimpleNames = void 0; let n = !1; function i(e) { const t = "string" == typeof e ? E.stringToIcon(e, !0, n) : e; return t ? F.getIcon(F.getStorage(t.provider, t.prefix), t.name) : null } function o(e, t) { const i = E.stringToIcon(e, !0, n); if (!i) return !1; const o = F.getStorage(i.provider, i.prefix); return F.addIcon(o, i.name, t) } function r(e, t) { if ("object" != typeof e) return !1; if ("string" != typeof t && (t = "string" == typeof e.provider ? e.provider : ""), n && "" === t && ("string" != typeof e.prefix || "" === e.prefix)) { let t = !1; return R.parseIconSet(e, ((e, n) => { null !== n && o(e, n) && (t = !0) })), t } if ("string" != typeof e.prefix || !E.validateIcon({ provider: t, prefix: e.prefix, name: "a" })) return !1; const i = F.getStorage(t, e.prefix); return !!F.addIconSet(i, e) } t.allowSimpleNames = function (e) { return "boolean" == typeof e && (n = e), n }, t.getIconData = i, t.addIcon = o, t.addCollection = r, t.storageFunctions = { iconExists: e => null !== i(e), getIcon: e => { const t = i(e); return t ? M.merge(t) : null }, listIcons: F.listIcons, addIcon: o, addCollection: r } })), N = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceIDs = void 0; const n = /\sid="(\S+)"/g, i = "IconifyId-" + Date.now().toString(16) + "-" + (16777216 * Math.random() | 0).toString(16) + "-"; let o = 0; function r(e, t, n) { let i = 0; for (; -1 !== (i = n.indexOf(e, i));)n = n.slice(0, i) + t + n.slice(i + e.length), i += t.length; return n } t.replaceIDs = function (e, t = i) { const s = []; let c; for (; c = n.exec(e);)s.push(c[1]); return s.length ? (s.forEach((n => { const i = "function" == typeof t ? t() : t + o++; e = r('="' + n + '"', '="' + i + '"', e), e = r('="#' + n + '"', '="#' + i + '"', e), e = r("(#" + n + ")", "(#" + i + ")", e) })), e) : e } })), B = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.calculateSize = void 0; const n = /(-?[0-9.]*[0-9]+[0-9.]*)/g, i = /^-?[0-9.]*[0-9]+[0-9.]*$/g; t.calculateSize = function (e, t, o) { if (1 === t) return e; if (o = void 0 === o ? 100 : o, "number" == typeof e) return Math.ceil(e * t * o) / o; if ("string" != typeof e) return e; const r = e.split(n); if (null === r || !r.length) return e; const s = []; let c = r.shift(), l = i.test(c); for (; ;) { if (l) { const e = parseFloat(c); isNaN(e) ? s.push(c) : s.push(Math.ceil(e * t * o) / o) } else s.push(c); if (c = r.shift(), void 0 === c) return s.join(""); l = !l } } })), V = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeCustomisations = t.defaults = void 0, t.defaults = Object.freeze({ inline: !1, width: null, height: null, hAlign: "center", vAlign: "middle", slice: !1, hFlip: !1, vFlip: !1, rotate: 0 }), t.mergeCustomisations = function (e, t) { const n = {}; for (const i in e) { const o = i; if (n[o] = e[o], void 0 === t[o]) continue; const r = t[o]; switch (o) { case "inline": case "slice": "boolean" == typeof r && (n[o] = r); break; case "hFlip": case "vFlip": !0 === r && (n[o] = !n[o]); break; case "hAlign": case "vAlign": "string" == typeof r && "" !== r && (n[o] = r); break; case "width": case "height": ("string" == typeof r && "" !== r || "number" == typeof r && r || null === r) && (n[o] = r); break; case "rotate": "number" == typeof r && (n[o] += r) } } return n } })), D = S((function (e, t) { function n(e) { let t = ""; switch (e.hAlign) { case "left": t += "xMin"; break; case "right": t += "xMax"; break; default: t += "xMid" }switch (e.vAlign) { case "top": t += "YMin"; break; case "bottom": t += "YMax"; break; default: t += "YMid" }return t += e.slice ? " slice" : " meet", t } Object.defineProperty(t, "__esModule", { value: !0 }), t.iconToSVG = void 0, t.iconToSVG = function (e, t) { const i = { left: e.left, top: e.top, width: e.width, height: e.height }; let o, r, s = e.body;[e, t].forEach((e => { const t = [], n = e.hFlip, o = e.vFlip; let r, c = e.rotate; switch (n ? o ? c += 2 : (t.push("translate(" + (i.width + i.left) + " " + (0 - i.top) + ")"), t.push("scale(-1 1)"), i.top = i.left = 0) : o && (t.push("translate(" + (0 - i.left) + " " + (i.height + i.top) + ")"), t.push("scale(1 -1)"), i.top = i.left = 0), c < 0 && (c -= 4 * Math.floor(c / 4)), c %= 4, c) { case 1: r = i.height / 2 + i.top, t.unshift("rotate(90 " + r + " " + r + ")"); break; case 2: t.unshift("rotate(180 " + (i.width / 2 + i.left) + " " + (i.height / 2 + i.top) + ")"); break; case 3: r = i.width / 2 + i.left, t.unshift("rotate(-90 " + r + " " + r + ")") }c % 2 == 1 && (0 === i.left && 0 === i.top || (r = i.left, i.left = i.top, i.top = r), i.width !== i.height && (r = i.width, i.width = i.height, i.height = r)), t.length && (s = '<g transform="' + t.join(" ") + '">' + s + "</g>") })), null === t.width && null === t.height ? (r = "1em", o = B.calculateSize(r, i.width / i.height)) : null !== t.width && null !== t.height ? (o = t.width, r = t.height) : null !== t.height ? (r = t.height, o = B.calculateSize(r, i.width / i.height)) : (o = t.width, r = B.calculateSize(o, i.height / i.width)), "auto" === o && (o = i.width), "auto" === r && (r = i.height), o = "string" == typeof o ? o : o + "", r = "string" == typeof r ? r : r + ""; const c = { attributes: { width: o, height: r, preserveAspectRatio: n(t), viewBox: i.left + " " + i.top + " " + i.width + " " + i.height }, body: s }; return t.inline && (c.inline = !0), c } })), z = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.builderFunctions = void 0, t.builderFunctions = { replaceIDs: N.replaceIDs, calculateSize: B.calculateSize, buildIcon: (e, t) => D.iconToSVG(T.fullIcon(e), V.mergeCustomisations(V.defaults, t)) } })), q = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.coreModules = void 0, t.coreModules = {} })), U = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.defaultConfig = void 0, t.defaultConfig = { resources: [], index: 0, timeout: 2e3, rotate: 750, random: !1, dataAfterTimeout: !1 } })), H = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.sendQuery = void 0, t.sendQuery = function (e, t, n, i, o) { const r = e.resources.length, s = e.random ? Math.floor(Math.random() * r) : e.index; let c; if (e.random) { let t = e.resources.slice(0); for (c = []; t.length > 1;) { const e = Math.floor(Math.random() * t.length); c.push(t[e]), t = t.slice(0, e).concat(t.slice(e + 1)) } c = c.concat(t) } else c = e.resources.slice(s).concat(e.resources.slice(0, s)); const l = Date.now(); let a, u = "pending", f = 0, d = null, p = [], h = []; function g() { d && (clearTimeout(d), d = null) } function m() { "pending" === u && (u = "aborted"), g(), p.forEach((e => { e.abort && e.abort(), "pending" === e.status && (e.status = "aborted") })), p = [] } function y(e, t) { t && (h = []), "function" == typeof e && h.push(e) } function $() { return { startTime: l, payload: t, status: u, queriesSent: f, queriesPending: p.length, subscribe: y, abort: m } } function v() { u = "failed", h.forEach((e => { e(void 0, a) })) } function b() { p = p.filter((e => ("pending" === e.status && (e.status = "aborted"), e.abort && e.abort(), !1))) } function k() { if ("pending" !== u) return; g(); const i = c.shift(); if (void 0 === i) { if (p.length) { const t = "function" == typeof e.timeout ? e.timeout(l) : e.timeout; if (t) return void (d = setTimeout((() => { g(), "pending" === u && (b(), v()) }), t)) } return void v() } const r = { getQueryStatus: $, status: "pending", resource: i, done: (t, n) => { !function (t, n, i) { const r = void 0 === n; switch (p = p.filter((e => e !== t)), u) { case "pending": break; case "failed": if (r || !e.dataAfterTimeout) return; break; default: return }if (r) return void 0 !== i && (a = i), void (p.length || (c.length ? k() : v())); if (g(), b(), o && !e.random) { const n = e.resources.indexOf(t.resource); -1 !== n && n !== e.index && o(n) } u = "completed", h.forEach((e => { e(n) })) }(r, t, n) } }; p.push(r), f++; const s = "function" == typeof e.rotate ? e.rotate(f, l) : e.rotate; d = setTimeout(k, s), n(i, t, r) } return "function" == typeof i && h.push(i), setTimeout(k), $ } })), K = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.initRedundancy = void 0, t.initRedundancy = function (e) { const t = function (e) { if (!("object" == typeof e && "object" == typeof e.resources && e.resources instanceof Array && e.resources.length)) throw new Error("Invalid Reduncancy configuration"); const t = Object.create(null); let n; for (n in U.defaultConfig) void 0 !== e[n] ? t[n] = e[n] : t[n] = U.defaultConfig[n]; return t }(e); let n = []; function i() { n = n.filter((e => "pending" === e().status)) } return { query: function (e, o, r) { const s = H.sendQuery(t, e, o, ((e, t) => { i(), r && r(e, t) }), (e => { t.index = e })); return n.push(s), s }, find: function (e) { const t = n.find((t => e(t))); return void 0 !== t ? t : null }, setIndex: e => { t.index = e }, getIndex: () => t.index, cleanup: i } } })), G = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.sortIcons = void 0, t.sortIcons = function (e) { const t = { loaded: [], missing: [], pending: [] }, n = Object.create(null); e.sort(((e, t) => e.provider !== t.provider ? e.provider.localeCompare(t.provider) : e.prefix !== t.prefix ? e.prefix.localeCompare(t.prefix) : e.name.localeCompare(t.name))); let i = { provider: "", prefix: "", name: "" }; return e.forEach((e => { if (i.name === e.name && i.prefix === e.prefix && i.provider === e.provider) return; i = e; const o = e.provider, r = e.prefix, s = e.name; void 0 === n[o] && (n[o] = Object.create(null)); const c = n[o]; void 0 === c[r] && (c[r] = F.getStorage(o, r)); const l = c[r]; let a; a = void 0 !== l.icons[s] ? t.loaded : "" === r || void 0 !== l.missing[s] ? t.missing : t.pending; const u = { provider: o, prefix: r, name: s }; a.push(u) })), t } })), J = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.storeCallback = t.updateCallbacks = t.callbacks = void 0, t.callbacks = Object.create(null); const n = Object.create(null); function i(e, n) { e.forEach((e => { const i = e.provider; if (void 0 === t.callbacks[i]) return; const o = t.callbacks[i], r = e.prefix, s = o[r]; s && (o[r] = s.filter((e => e.id !== n))) })) } t.updateCallbacks = function (e, o) { void 0 === n[e] && (n[e] = Object.create(null)); const r = n[e]; r[o] || (r[o] = !0, setTimeout((() => { if (r[o] = !1, void 0 === t.callbacks[e] || void 0 === t.callbacks[e][o]) return; const n = t.callbacks[e][o].slice(0); if (!n.length) return; const s = F.getStorage(e, o); let c = !1; n.forEach((t => { const n = t.icons, r = n.pending.length; n.pending = n.pending.filter((t => { if (t.prefix !== o) return !0; const i = t.name; if (void 0 !== s.icons[i]) n.loaded.push({ provider: e, prefix: o, name: i }); else { if (void 0 === s.missing[i]) return c = !0, !0; n.missing.push({ provider: e, prefix: o, name: i }) } return !1 })), n.pending.length !== r && (c || i([{ provider: e, prefix: o }], t.id), t.callback(n.loaded.slice(0), n.missing.slice(0), n.pending.slice(0), t.abort)) })) }))) }; let o = 0; t.storeCallback = function (e, n, r) { const s = o++, c = i.bind(null, r, s); if (!n.pending.length) return c; const l = { id: s, icons: n, callback: e, abort: c }; return r.forEach((e => { const n = e.provider, i = e.prefix; void 0 === t.callbacks[n] && (t.callbacks[n] = Object.create(null)); const o = t.callbacks[n]; void 0 === o[i] && (o[i] = []), o[i].push(l) })), c } })), W = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getAPIModule = t.setAPIModule = void 0; const n = Object.create(null); t.setAPIModule = function (e, t) { n[e] = t }, t.getAPIModule = function (e) { return void 0 === n[e] ? n[""] : n[e] } })), Q = S((function (e, t) { function n(e) { let t; if ("string" == typeof e.resources) t = [e.resources]; else if (t = e.resources, !(t instanceof Array && t.length)) return null; return { resources: t, path: void 0 === e.path ? "/" : e.path, maxURL: e.maxURL ? e.maxURL : 500, rotate: e.rotate ? e.rotate : 750, timeout: e.timeout ? e.timeout : 5e3, random: !0 === e.random, index: e.index ? e.index : 0, dataAfterTimeout: !1 !== e.dataAfterTimeout } } Object.defineProperty(t, "__esModule", { value: !0 }), t.getAPIConfig = t.setAPIConfig = void 0; const i = Object.create(null), o = ["https://api.simplesvg.com", "https://api.unisvg.com"], r = []; for (; o.length > 0;)1 === o.length || Math.random() > .5 ? r.push(o.shift()) : r.push(o.pop()); i[""] = n({ resources: ["https://api.iconify.design"].concat(r) }), t.setAPIConfig = function (e, t) { const o = n(t); return null !== o && (i[e] = o, !0) }; t.getAPIConfig = e => i[e] })), Y = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getProviders = t.listToIcons = void 0, t.listToIcons = function (e, t = !0, n = !1) { const i = []; return e.forEach((e => { const o = "string" == typeof e ? E.stringToIcon(e, !1, n) : e; t && !E.validateIcon(o, n) || i.push({ provider: o.provider, prefix: o.prefix, name: o.name }) })), i }, t.getProviders = function (e) { const t = Object.create(null); return e.forEach((e => { t[e.provider] = !0 })), Object.keys(t) } })), X = S((function (e, t) { function n() { } Object.defineProperty(t, "__esModule", { value: !0 }), t.API = t.getRedundancyCache = void 0; const i = Object.create(null), o = Object.create(null), r = Object.create(null), s = Object.create(null), c = Object.create(null); function l(e) { if (void 0 === c[e]) { const t = Q.getAPIConfig(e); if (!t) return; const n = { config: t, redundancy: K.initRedundancy(t) }; c[e] = n } return c[e] } t.getRedundancyCache = l; const a = Object.create(null); function u(e, t, n) { function c() { const n = ("" === e ? "" : "@" + e + ":") + t, i = Math.floor(Date.now() / 6e4); a[n] < i && (a[n] = i, console.error('Unable to retrieve icons for "' + n + '" because API is not configured properly.')) } void 0 === o[e] && (o[e] = Object.create(null)); const u = o[e]; void 0 === s[e] && (s[e] = Object.create(null)); const f = s[e]; void 0 === i[e] && (i[e] = Object.create(null)); const d = i[e]; let p; void 0 === u[t] ? u[t] = n : u[t] = u[t].concat(n).sort(), f[t] || (f[t] = !0, setTimeout((() => { f[t] = !1; const n = u[t]; delete u[t]; const i = W.getAPIModule(e); if (!i) return void c(); if (void 0 === p) { const t = l(e); if (void 0 === t) return void c(); p = t } i.prepare(e, t, n).forEach((n => { p.redundancy.query(n, i.send, ((i, o) => { const s = F.getStorage(e, t); if ("object" != typeof i) { if (404 !== o) return; const e = Date.now(); n.icons.forEach((t => { s.missing[t] = e })) } else try { const n = F.addIconSet(s, i, "all"); if ("boolean" == typeof n) return; const o = d[t]; n.forEach((e => { delete o[e] })), q.coreModules.cache && q.coreModules.cache(e, i) } catch (e) { console.error(e) } !function (e, t) { void 0 === r[e] && (r[e] = Object.create(null)); const n = r[e]; n[t] || (n[t] = !0, setTimeout((() => { n[t] = !1, J.updateCallbacks(e, t) }))) }(e, t) })) })) }))) } t.API = { isPending: e => void 0 !== i[e.provider] && void 0 !== i[e.provider][e.prefix] && void 0 !== i[e.provider][e.prefix][e.name], loadIcons: (e, t) => { const o = Y.listToIcons(e, !0, L.allowSimpleNames()), r = G.sortIcons(o); if (!r.pending.length) { let e = !0; return t && setTimeout((() => { e && t(r.loaded, r.missing, r.pending, n) })), () => { e = !1 } } const s = Object.create(null), c = []; let l, a; r.pending.forEach((e => { const t = e.provider, n = e.prefix; if (n === a && t === l) return; l = t, a = n, c.push({ provider: t, prefix: n }), void 0 === i[t] && (i[t] = Object.create(null)); const o = i[t]; void 0 === o[n] && (o[n] = Object.create(null)), void 0 === s[t] && (s[t] = Object.create(null)); const r = s[t]; void 0 === r[n] && (r[n] = []) })); const f = Date.now(); return r.pending.forEach((e => { const t = e.provider, n = e.prefix, o = e.name, r = i[t][n]; void 0 === r[o] && (r[o] = f, s[t][n].push(o)) })), c.forEach((e => { const t = e.provider, n = e.prefix; s[t][n].length && u(t, n, s[t][n]) })), t ? J.storeCallback(t, r, c) : n } } })), Z = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.APIInternalFunctions = t.APIFunctions = void 0, t.APIFunctions = { loadIcons: X.API.loadIcons, addAPIProvider: Q.setAPIConfig }, t.APIInternalFunctions = { getAPI: X.getRedundancyCache, getAPIConfig: Q.getAPIConfig, setAPIModule: W.setAPIModule } })), ee = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getAPIModule = void 0; let n = null, i = "{prefix}.js?icons={icons}&callback={callback}"; const o = Object.create(null), r = Object.create(null); function s() { if (null === n) { const e = self; let t = "Iconify", o = ".cb"; if (void 0 === e[t]) t = "IconifyJSONP", o = "", void 0 === e[t] && (e[t] = Object.create(null)), n = e[t]; else { const i = e[t]; void 0 === i.cb && (i.cb = Object.create(null)), n = i.cb } i = i.replace("{callback}", t + o + ".{cb}") } return n } t.getAPIModule = e => ({ prepare: (t, n, c) => { const l = []; let a = o[t + ":" + n]; void 0 === a && (a = function (t, n) { const c = e(t); if (!c) return 0; let l; if (c.maxURL) { let e = 0; c.resources.forEach((t => { const n = t; e = Math.max(e, n.length) })), s(); const o = 3; l = c.maxURL - e - c.path.length - i.replace("{provider}", t).replace("{prefix}", n).replace("{icons}", "").length - o } else l = 0; const a = t + ":" + n; return r[a] = c.path, o[a] = l, l }(t, n)); let u = { provider: t, prefix: n, icons: [] }, f = 0; return c.forEach(((e, i) => { f += e.length + 1, f >= a && i > 0 && (l.push(u), u = { provider: t, prefix: n, icons: [] }, f = e.length), u.icons.push(e) })), l.push(u), l }, send: (e, t, n) => { const o = t.provider, c = t.prefix, l = t.icons.join(","), a = o + ":" + c, u = c.split("-").shift().slice(0, 3), f = s(); let d = function (e) { let t, n = 0; for (t = e.length - 1; t >= 0; t--)n += e.charCodeAt(t); return n % 999 }(o + ":" + e + ":" + c + ":" + l); for (; void 0 !== f[u + d];)d++; const p = u + d, h = r[a] + i.replace("{provider}", o).replace("{prefix}", c).replace("{icons}", l).replace("{cb}", p); f[p] = e => { delete f[p], n.done(e) }; const g = e + h, m = document.createElement("script"); m.type = "text/javascript", m.async = !0, m.src = g, document.head.appendChild(m) } }) })), te = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getAPIModule = t.setFetch = void 0; const n = "{prefix}.json?icons={icons}", i = Object.create(null), o = Object.create(null); let r = null; try { r = fetch } catch (e) { } t.setFetch = function (e) { r = e }; t.getAPIModule = e => ({ prepare: (t, r, s) => { const c = []; let l = i[r]; void 0 === l && (l = function (t, r) { const s = e(t); if (!s) return 0; let c; if (s.maxURL) { let e = 0; s.resources.forEach((t => { const n = t; e = Math.max(e, n.length) })), c = s.maxURL - e - s.path.length - n.replace("{provider}", t).replace("{prefix}", r).replace("{icons}", "").length } else c = 0; const l = t + ":" + r; return o[l] = s.path, i[l] = c, c }(t, r)); let a = { provider: t, prefix: r, icons: [] }, u = 0; return s.forEach(((e, n) => { u += e.length + 1, u >= l && n > 0 && (c.push(a), a = { provider: t, prefix: r, icons: [] }, u = e.length), a.icons.push(e) })), c.push(a), c }, send: (e, t, i) => { const s = t.provider, c = t.prefix, l = t.icons.join(","), a = o[s + ":" + c] + n.replace("{provider}", s).replace("{prefix}", c).replace("{icons}", l); r ? r(e + a).then((e => { if (200 === e.status) return e.json(); i.done(void 0, e.status) })).then((e => { "object" == typeof e && null !== e && i.done(e) })).catch((e => { i.done(void 0, e.errno) })) : i.done(void 0, 424) } }) })), ne = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.storeCache = t.loadCache = t.mock = t.emptyList = t.count = t.config = void 0; const n = "iconify2", i = "iconify", o = "iconify-count", r = "iconify-version", s = 36e5; t.config = { local: !0, session: !0 }; let c = !1; t.count = { local: 0, session: 0 }, t.emptyList = { local: [], session: [] }; let l = "undefined" == typeof window ? {} : window; function a(e) { const n = e + "Storage"; try { if (l && l[n] && "number" == typeof l[n].length) return l[n] } catch (e) { } return t.config[e] = !1, null } function u(e, n, i) { try { return e.setItem(o, i + ""), t.count[n] = i, !0 } catch (e) { return !1 } } function f(e) { const t = e.getItem(o); if (t) { const e = parseInt(t); return e || 0 } return 0 } t.mock = function (e) { c = !1, l = e }; t.loadCache = () => { if (c) return; c = !0; const e = Math.floor(Date.now() / s) - 168; function o(o) { const s = a(o); if (!s) return; const c = t => { const n = i + t, o = s.getItem(n); if ("string" != typeof o) return !1; let r = !0; try { const t = JSON.parse(o); if ("object" != typeof t || "number" != typeof t.cached || t.cached < e || "string" != typeof t.provider || "object" != typeof t.data || "string" != typeof t.data.prefix) r = !1; else { const e = t.provider, n = t.data.prefix, i = F.getStorage(e, n); r = F.addIconSet(i, t.data) } } catch (e) { r = !1 } return r || s.removeItem(n), r }; try { const e = s.getItem(r); if (e !== n) return e && function (e) { try { const t = f(e); for (let n = 0; n < t; n++)e.removeItem(i + n) } catch (e) { } }(s), void function (e, t) { try { e.setItem(r, n) } catch (e) { } u(e, t, 0) }(s, o); let l = f(s); for (let e = l - 1; e >= 0; e--)c(e) || (e === l - 1 ? l-- : t.emptyList[o].push(e)); u(s, o, l) } catch (e) { } } for (const e in t.config) o(e) }; t.storeCache = (e, n) => { function o(o) { if (!t.config[o]) return !1; const r = a(o); if (!r) return !1; let c = t.emptyList[o].shift(); if (void 0 === c && (c = t.count[o], !u(r, o, c + 1))) return !1; try { const t = { cached: Math.floor(Date.now() / s), provider: e, data: n }; r.setItem(i + c, JSON.stringify(t)) } catch (e) { return !1 } return !0 } c || t.loadCache(), o("local") || o("session") } })), ie = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.toggleBrowserCache = void 0, t.toggleBrowserCache = function (e, t) { switch (e) { case "local": case "session": ne.config[e] = t; break; case "all": for (const e in ne.config) ne.config[e] = t } } })), oe = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.alignmentFromString = t.flipFromString = void 0; const n = /[\s,]+/; t.flipFromString = function (e, t) { t.split(n).forEach((t => { switch (t.trim()) { case "horizontal": e.hFlip = !0; break; case "vertical": e.vFlip = !0 } })) }, t.alignmentFromString = function (e, t) { t.split(n).forEach((t => { const n = t.trim(); switch (n) { case "left": case "center": case "right": e.hAlign = n; break; case "top": case "middle": case "bottom": e.vAlign = n; break; case "slice": case "crop": e.slice = !0; break; case "meet": e.slice = !1 } })) } })), re = S((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.rotateFromString = void 0, t.rotateFromString = function (e) { const t = e.replace(/^-?[0-9.]*/, ""); function n(e) { for (; e < 0;)e += 4; return e % 4 } if ("" === t) { const t = parseInt(e); return isNaN(t) ? 0 : n(t) } if (t !== e) { let i = 0; switch (t) { case "%": i = 25; break; case "deg": i = 90 }if (i) { let o = parseFloat(e.slice(0, e.length - t.length)); return isNaN(o) ? 0 : (o /= i, o % 1 == 0 ? n(o) : 0) } } return 0 } })); const se = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "aria-hidden": !0, role: "img" }; L.storageFunctions.iconExists; const ce = L.storageFunctions.getIcon; L.storageFunctions.listIcons, L.storageFunctions.addIcon; const le = L.storageFunctions.addCollection, ae = z.builderFunctions.calculateSize; z.builderFunctions.replaceIDs, z.builderFunctions.buildIcon; const ue = Z.APIFunctions.loadIcons, fe = Z.APIFunctions.addAPIProvider, de = Z.APIInternalFunctions; L.allowSimpleNames(!0), q.coreModules.api = X.API; let pe = te.getAPIModule; try { "undefined" != typeof document && "undefined" != typeof window && (pe = "function" == typeof fetch && "function" == typeof Promise ? te.getAPIModule : ee.getAPIModule) } catch (e) { } if (W.setAPIModule("", pe(Q.getAPIConfig)), de.setFetch = e => { te.setFetch(e), pe !== te.getAPIModule && (pe = te.getAPIModule, W.setAPIModule("", pe(Q.getAPIConfig))) }, "undefined" != typeof document && "undefined" != typeof window) { q.coreModules.cache = ne.storeCache, ne.loadCache(); const e = window; if (void 0 !== e.IconifyPreload) { const t = e.IconifyPreload, n = "Invalid IconifyPreload syntax."; "object" == typeof t && null !== t && (t instanceof Array ? t : [t]).forEach((e => { try { ("object" != typeof e || null === e || e instanceof Array || "object" != typeof e.icons || "string" != typeof e.prefix || !le(e)) && console.error(n) } catch (e) { console.error(n) } })) } if (void 0 !== e.IconifyProviders) { const t = e.IconifyProviders; if ("object" == typeof t && null !== t) for (let e in t) { const n = "IconifyProviders[" + e + "] is invalid."; try { const i = t[e]; if ("object" != typeof i || !i || void 0 === i.resources) continue; Q.setAPIConfig(e, i) || console.error(n) } catch (e) { console.error(n) } } } } function he(e, t) { return e ? function (e, t) { const n = V.mergeCustomisations(V.defaults, t), i = M.merge(se); let o = "string" == typeof t.style ? t.style : ""; for (let e in t) { const r = t[e]; if (void 0 !== r) switch (e) { case "icon": case "style": case "onLoad": break; case "inline": case "hFlip": case "vFlip": n[e] = !0 === r || "true" === r || 1 === r; break; case "flip": "string" == typeof r && oe.flipFromString(n, r); break; case "align": "string" == typeof r && oe.alignmentFromString(n, r); break; case "color": o = o + (o.length > 0 && ";" !== o.trim().slice(-1) ? ";" : "") + "color: " + r + "; "; break; case "rotate": "string" == typeof r ? n[e] = re.rotateFromString(r) : "number" == typeof r && (n[e] = r); break; case "ariaHidden": case "aria-hidden": !0 !== r && "true" !== r && delete i["aria-hidden"]; break; default: void 0 === V.defaults[e] && (i[e] = r) } } const r = D.iconToSVG(e, n); for (let e in r.attributes) i[e] = r.attributes[e]; r.inline && (o = "vertical-align: -0.125em; " + o), "" !== o && (i.style = o); let s = 0; const c = t.id; return { attributes: i, body: N.replaceIDs(r.body, c ? () => c + "-" + s++ : "iconify-svelte-") } }(e, t) : null } function ge(e) { let n, i = e[0].body + "", o = [e[0].attributes], r = {}; for (let e = 0; e < o.length; e += 1)r = t(r, o[e]); return { c() { n = function (e) { return document.createElementNS("http://www.w3.org/2000/svg", e) }("svg"), d(n, r) }, m(e, t) { l(e, n, t), n.innerHTML = i }, p(e, t) { 1 & t && i !== (i = e[0].body + "") && (n.innerHTML = i), d(n, r = function (e, t) { const n = {}, i = {}, o = { $$scope: 1 }; let r = e.length; for (; r--;) { const s = e[r], c = t[r]; if (c) { for (const e in s) e in c || (i[e] = 1); for (const e in c) o[e] || (n[e] = c[e], o[e] = 1); e[r] = c } else for (const e in s) o[e] = 1 } for (const e in i) e in n || (n[e] = void 0); return n }(o, [1 & t && e[0].attributes])) }, d(e) { e && a(n) } } } function me(t) { let n, i = null !== t[0] && ge(t); return { c() { i && i.c(), n = u() }, m(e, t) { i && i.m(e, t), l(e, n, t) }, p(e, [t]) { null !== e[0] ? i ? i.p(e, t) : (i = ge(e), i.c(), i.m(n.parentNode, n)) : i && (i.d(1), i = null) }, i: e, o: e, d(e) { i && i.d(e), e && a(n) } } } function ye(e, n, i) { const o = { name: "", loading: null, destroyed: !1 }; let r, s = !1, l = 0; function a() { i(3, l++, l) } var u; return u = () => { i(2, s = !0) }, g().$$.on_mount.push(u), function (e) { g().$$.on_destroy.push(e) }((() => { i(1, o.destroyed = !0, o), o.loading && (o.loading.abort(), i(1, o.loading = null, o)) })), e.$$set = e => { i(5, n = t(t({}, n), c(e))) }, e.$$.update = () => { { const e = function (e, t, n, i, o) { function r() { t.loading && (t.loading.abort(), t.loading = null) } if ("object" == typeof e && null !== e && "string" == typeof e.body) return t.name = "", r(), { data: T.fullIcon(e) }; let s; if ("string" != typeof e || null === (s = E.stringToIcon(e, !1, !0))) return r(), null; const c = L.getIconData(s); if (null === c) return !n || t.loading && t.loading.name === e || (r(), t.name = "", t.loading = { name: e, abort: X.API.loadIcons([s], i) }), null; r(), t.name !== e && (t.name = e, o && !t.destroyed && o(e)); const l = ["iconify"]; return "" !== s.prefix && l.push("iconify--" + s.prefix), "" !== s.provider && l.push("iconify--" + s.provider), { data: c, classes: l } }(n.icon, o, s, a, n.onLoad); i(0, r = e ? he(e.data, n) : null), r && e.classes && i(0, r.attributes.class = ("string" == typeof n.class ? n.class + " " : "") + e.classes.join(" "), r) } }, n = c(n), [r, o, s, l] } class $e extends class { $destroy() { !function (e, t) { const n = e.$$; null !== n.fragment && (o(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []) }(this, 1), this.$destroy = e } $on(e, t) { const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []); return n.push(t), () => { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } $set(e) { var t; this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1) } }{ constructor(e) { super(), O(this, e, ye, me, s, {}) } } function ve(e) { var t = { exports: {} }; return e(t, t.exports), t.exports } var be = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.match = t.compareObjects = t.cloneObject = void 0, t.cloneObject = function e(t) { if ("object" != typeof t || null === t) return t; if (t instanceof Array) return t.map((t => "object" == typeof t ? e(t) : t)); const n = {}; let i; for (i in t) "object" != typeof t[i] ? n[i] = t[i] : n[i] = e(t[i]); return n }, t.compareObjects = function e(t, n) { if ("object" != typeof t || "object" != typeof n) return t === n; if (t === n) return !0; if (null === t || null === n) return !1; if (t instanceof Array) { if (!(n instanceof Array)) return !1; if (t.length !== n.length) return !1; for (let i = 0; i < t.length; i++) { const o = t[i], r = n[i]; if (o !== r && ("object" != typeof o || "object" != typeof r || !e(o, r))) return !1 } return !0 } if (n instanceof Array) return !1; const i = Object.keys(t), o = Object.keys(n); if (i.length !== o.length) return !1; for (let o = 0; o < i.length; o++) { const r = i[o]; if (typeof t[r] != typeof n[r]) return !1; if ("object" == typeof t[r]) { if (!e(t[r], n[r])) return !1 } else if (t[r] !== n[r]) return !1 } return !0 }, t.match = function e(t, n) { if ("number" == typeof t && (t = "" + t), "string" == typeof t) return -1 !== t.toLowerCase().indexOf(n); if ("object" != typeof t || null === t) return !1; if (t instanceof Array) { for (let i = 0; i < t.length; i++)if (e(t[i], n)) return !0; return !1 } for (const i in t) if (e(t[i], n)) return !0; return !1 } })), ke = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.customisedConfig = t.createConfig = t.mergeConfig = t.setComponentsConfig = void 0; const n = { ui: { itemsPerPage: 52, viewUpdateDelay: 300, showSiblingCollections: 2 }, router: { home: "", syncRender: !1 }, components: {} }; function i(e, t) { for (const n in t) { const i = n, o = e[i]; if (void 0 === o) continue; const r = t[i]; for (const e in r) { const t = e; void 0 !== o[t] && (o[t] = r[t]) } } } t.setComponentsConfig = function (e) { n.components = Object.assign(e) }, t.mergeConfig = i, t.createConfig = function (e = {}) { const t = be.cloneObject(n); return e && i(t, e), t }, t.customisedConfig = function (e) { const t = {}; for (const i in e) { const o = i, r = n[o], s = e[o], c = {}; let l = !1; for (const e in s) { const t = e; s[t] !== r[t] && (c[t] = s[t], l = !0) } l && (t[o] = c) } return t } })), _e = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.Events = void 0; t.Events = class { constructor() { this._subscribers = Object.create(null) } subscribe(e, t, n) { void 0 === this._subscribers[e] ? this._subscribers[e] = [] : "string" == typeof n && (this._subscribers[e] = this._subscribers[e].filter((e => e.key !== n))), this._subscribers[e].push({ callback: t, key: n }) } unsubscribe(e, t) { if (void 0 === this._subscribers[e]) return; let n; switch (typeof t) { case "function": n = "callback"; break; case "string": n = "key"; break; default: return }this._subscribers[e] = this._subscribers[e].filter((e => e[n] !== t)) } hasListeners(e) { return void 0 !== this._subscribers[e] && this._subscribers[e].length > 0 } fire(e, t, n = !1) { this.hasListeners(e) && (n ? setTimeout((() => { this._fire(e, t) })) : this._fire(e, t)) } _fire(e, t) { this._subscribers[e].forEach((n => { n.callback(t, e) })) } } })), we = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.setIconify = t.Iconify = void 0, t.Iconify = {}, t.setIconify = function (e) { [e, e._api].forEach((e => { if ("object" == typeof e) for (const n in e) { const i = e[n]; "function" == typeof i && (t.Iconify[n] = i) } })) } })), xe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.fullIcon = t.iconDefaults = t.minifyProps = t.matchName = void 0, t.matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/, t.minifyProps = ["width", "height", "top", "left"], t.iconDefaults = Object.freeze({ left: 0, top: 0, width: 16, height: 16, rotate: 0, vFlip: !1, hFlip: !1 }), t.fullIcon = function (e) { return { ...t.iconDefaults, ...e } } })), Ce = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.listProviders = t.addProvider = t.getProvider = t.convertProviderData = t.internalSourceCache = void 0; const n = { home: "", collection: "", icon: "" }, i = { package: "", icon: "" }, o = { provider: "", title: "", api: "", links: n, npm: i }; t.internalSourceCache = Object.create(null); const r = Object.create(null), s = "https://iconify.design/icon-sets/", c = "@iconify/icons-{prefix}"; t.internalSourceCache[""] = { config: {}, title: "Iconify", links: { home: s, collection: s + "{prefix}/", icon: s + "{prefix}/{name}.html" }, npm: { package: c, icon: c + "/{name}" } }; const l = { title: "", links: n, npm: i }; t.convertProviderData = function (e, t) { const n = t.provider; if ("string" != typeof n || "" !== n && !n.match(xe.matchName)) return null; const i = {}; for (const r in o) { const s = r; let c, l; switch (s) { case "title": i.title = "string" == typeof t.title ? t.title : n; break; case "provider": i.provider = n; break; case "api": if ("string" == typeof t.api && "" !== t.api) i.api = [t.api]; else if (t.api instanceof Array) i.api = t.api; else { if ("" === e) return null; i.api = [e] } break; case "npm": case "links": if (c = o[s], "object" == typeof t[s] && t[s]) { const e = t[s]; l = {}; for (const t in c) { const n = t; "string" == typeof e[n] ? l[n] = e[n] : l[n] = c[n] } } else l = c; i[s] = l } } const r = i; return { config: { resources: r.api }, title: r.title, links: r.links, npm: r.npm } }, t.getProvider = function (e) { if (void 0 === r[e]) { if (void 0 === t.internalSourceCache[e]) return null; const n = t.internalSourceCache[e], i = we.Iconify.getAPI ? we.Iconify.getAPI(e) : void 0; if (void 0 === i) r[e] = null; else { r[e] = { config: i.config, redundancy: i.redundancy }; const t = r[e], o = n; for (const e in l) void 0 !== o[e] ? t[e] = o[e] : t[e] = l[e] } } return r[e] }, t.addProvider = function (e, n) { we.Iconify.addAPIProvider && void 0 === t.internalSourceCache[e] && (void 0 === n.title && (n.title = e), t.internalSourceCache[e] = n, we.Iconify.addAPIProvider(e, n.config)) }, t.listProviders = function () { return Object.keys(t.internalSourceCache).sort() } })), je = ve((function (e, t) { function n(e, t) { let n = e, i = -1 !== n.indexOf("?"); function o(e, t) { switch (typeof e) { case "boolean": if (t) throw new Error("Nested boolean items are not allowed"); return e ? "true" : "false"; case "number": case "string": return encodeURIComponent(e); case "object": if (t) throw new Error("Nested objects are not allowed"); if (e instanceof Array) return e.map((e => o(e, !0))).join(","); throw new Error("Objects are not allowed"); default: throw new Error("Invalid type") } } return Object.keys(t).forEach((e => { let r; try { r = o(t[e], !1) } catch (e) { return } n += (i ? "&" : "?") + encodeURIComponent(e) + "=" + r, i = !0 })), n } Object.defineProperty(t, "__esModule", { value: !0 }), t.searchCacheKey = t.collectionCacheKey = t.collectionsCacheKey = t.BaseAPI = t.mergeQuery = void 0, t.mergeQuery = n; t.BaseAPI = class { constructor(e) { this._cache = Object.create(null), this._registry = e, this._query = this._query.bind(this) } query(e, t, i, o, r = !0) { const s = n(t, i), c = "string" == typeof r ? r : s; void 0 === this._cache[e] && (this._cache[e] = Object.create(null)); const l = this._cache[e]; if (!1 !== r && void 0 !== l[c]) { const e = l[c]; return void o(null === e ? null : JSON.parse(e), void 0, !0) } const a = this._getRedundancy(e); if (!a) return void o(null, !1); const u = a.find((e => { const t = e(); return "pending" === t.status && t.payload === s })); null === u ? a.query(s, this._query.bind(this, e, !1 === r ? null : c), ((e, t) => { o(e, t, !1) })) : u().subscribe(((e, t) => { o(e, t, !1) })) } isCached(e, t, i) { const o = n(t, i); return void 0 !== this._cache[e] && void 0 !== this._cache[e][o] } isPending(e, t, i) { const o = this._getRedundancy(e); if (!o) return !1; const r = n(t, i); return null !== o.find((e => { const t = e(); return "pending" === t.status && t.payload === r })) } _query(e, t, n, i, o) { throw new Error("_query() should not be called on base API class") } storeCache(e, t, n) { void 0 === this._cache[e] && (this._cache[e] = Object.create(null)), this._cache[e][t] = null === n ? null : JSON.stringify(n) } clearCache() { this._cache = Object.create(null) } _getRedundancy(e) { const t = Ce.getProvider(e); return t ? t.redundancy : null } }, t.collectionsCacheKey = function () { return "collections" }, t.collectionCacheKey = function (e) { return "collection." + e }, t.searchCacheKey = function (e, t) { return "search." + e + "." + t } })), Ie = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.API = t.setFetch = void 0; let n = null; try { n = fetch } catch (e) { } t.setFetch = function (e) { n = e }; class i extends je.BaseAPI { sendQuery(e, t, i) { n ? n(e + t).then((e => { if (200 === e.status) return e.json(); i(void 0, e.status) })).then((e => { void 0 !== e && ("object" == typeof e && null !== e ? i(e) : i(void 0, null)) })).catch((e => { i(void 0, null == e ? void 0 : e.errno) })) : i(void 0, 424) } _query(e, t, n, i, o) { this.sendQuery(n, i, ((n, i) => { void 0 !== n && null !== t && this.storeCache(e, t, n), o.done(n, i) })) } } t.API = i })), Pe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getRegistry = t.destroyRegistry = t.getSharedData = t.saveRegistry = t.addRegistry = t.uniqueId = void 0; const n = Object.create(null), i = Object.create(null); t.uniqueId = function (e) { let t, n = 0; for (; void 0 !== i[t = e + n];)n++; return t }, t.addRegistry = function (e) { const t = e.namespace, i = e.id; return void 0 === n[t] ? (n[t] = { ids: [i], data: Object.create(null) }, !0) : (n[t].ids.push(i), !1) }, t.saveRegistry = function (e) { i[e.id] = e }, t.getSharedData = function (e) { return n[e].data }, t.destroyRegistry = function (e) { void 0 !== i[e.id] && (delete i[e.id], n[e.namespace].ids = n[e.namespace].ids.filter((t => t !== e.id))) }; t.getRegistry = e => i[e] })), Oe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.emptyRouteMinimum = t.customRouteMinimum = t.searchRouteMinimum = t.collectionRouteMinimum = t.collectionsRouteMinimum = t.emptyRouteDefaults = t.customRouteDefaults = t.searchRouteDefaults = t.collectionRouteDefaults = t.collectionsRouteDefaults = void 0, t.collectionsRouteDefaults = { provider: "", filter: "", category: null }, t.collectionRouteDefaults = { provider: "", prefix: "", filter: "", icon: "", page: 0, tag: null, themePrefix: null, themeSuffix: null }, t.searchRouteDefaults = { provider: "", search: "", short: !0, page: 0 }, t.customRouteDefaults = { customType: "", filter: "", page: 0 }, t.emptyRouteDefaults = {}, t.collectionsRouteMinimum = {}, t.collectionRouteMinimum = { prefix: "" }, t.searchRouteMinimum = { search: "" }, t.customRouteMinimum = { customType: "" }, t.emptyRouteMinimum = {} })), Se = ve((function (e, t) { function n(e) { let t, n; switch (e) { case "collections": t = Oe.collectionsRouteDefaults, n = Oe.collectionsRouteMinimum; break; case "collection": t = Oe.collectionRouteDefaults, n = Oe.collectionRouteMinimum; break; case "search": t = Oe.searchRouteDefaults, n = Oe.searchRouteMinimum; break; case "custom": t = Oe.customRouteDefaults, n = Oe.customRouteMinimum; break; case "empty": t = Oe.emptyRouteDefaults, n = Oe.emptyRouteMinimum; break; default: throw new Error(`Unknown route type: ${e}`) }return { defaults: t, required: n } } Object.defineProperty(t, "__esModule", { value: !0 }), t.objectToRoute = t.objectToRouteParams = t.routeToObject = t.routeParamsToObject = void 0; t.routeParamsToObject = (e, t) => { const i = {}, { defaults: o, required: r } = n(e); for (const e in o) { const n = t[e]; void 0 === r[e] && n === o[e] || (i[e] = n) } return i }; t.routeToObject = e => { const n = { type: e.type }, i = t.routeParamsToObject(e.type, e.params); if (Object.keys(i).length > 0 && (n.params = i), e.parent) { const i = t.routeToObject(e.parent); i && (n.parent = i) } return n }; const i = ["filter", "search", "provider"]; t.objectToRouteParams = (e, t) => { const o = {}, { defaults: r, required: s } = n(e); for (const e in s) if (typeof t[e] != typeof s[e] || t[e] === s[e]) throw new Error(`Missing required route parameter "${e}" in objectToRouteParams()`); for (const n in r) { const s = r[n]; if (void 0 === t[n]) { o[n] = s; continue } let c = t[n]; const l = null === s ? "string" : typeof s; typeof c !== l ? o[n] = null !== c || "page" !== n || "collection" !== e ? s : c : ("string" === l && -1 !== i.indexOf(n) && (c = c.toLowerCase()), o[n] = c) } return o }; t.objectToRoute = (e, n = null) => { if (null === e || "object" != typeof e || "string" != typeof e.type) return n; const i = e.type; switch (i) { case "collections": case "collection": case "custom": case "search": case "empty": break; default: return n }let o; try { o = t.objectToRouteParams(i, "object" == typeof e.params ? e.params : {}) } catch (e) { return n } let r = null; return "object" == typeof e.parent && null !== e.parent && (r = t.objectToRoute(e.parent, null), null === r) ? n : { type: i, params: o, parent: r } } })), Ee = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseView = void 0; t.BaseView = class { constructor() { this.type = "", this.parent = null, this.updating = !1, this.error = "", this.blocksRequireUpdate = !0, this.loading = !0, this._loadingTimer = null, this._alreadyLoaded = !1, this._startedLoading = !1, this.onLoad = null, this._mustWaitForParent = !1, this._isSync = null } _checkSync() { return null === this._isSync && (this._isSync = !!Pe.getRegistry(this._instance).config.router.syncRender), this._isSync } _parentAction(e) { if (null === this.parent) return; const t = "number" == typeof e && e > 0 ? e : 1; Pe.getRegistry(this._instance).router.setParentView(t) } _providerAction(e) { if ("string" != typeof e) return; if (!Ce.getProvider(e)) return; Pe.getRegistry(this._instance).router.home(e) } startLoading() { this._startedLoading || (this.loading ? (this._mustWaitForParent && null !== this.parent && this.parent.startLoading(), this._startLoading()) : this._startedLoading = !0) } _startLoading() { this._startedLoading = !0, this._checkSync() ? this._startLoadingData() : setTimeout((() => { this._startLoadingData() })) } _startLoadingData() { throw new Error("startLoading should not be called on base view") } _searchAction(e, t) { if ("string" != typeof t || "" === t.trim()) return; const n = t.trim().toLowerCase(); let i = this, o = 0; for (; "collections" !== i.type;) { if (null === i.parent) return; i = i.parent, o++ } Pe.getRegistry(this._instance).router.createChildView({ type: "search", params: { provider: e, search: n } }, o) } _loadAPI(e, t, n, i = !0) { Pe.getRegistry(this._instance).api.query(e, t, n, ((e, t) => { void 0 !== e ? null !== e && this._mustWaitForParent ? this._waitForParent((() => { this._parseAPIData(e) })) : this._parseAPIData(e) : this.loading && (this.error = 404 === t ? "not_found" : "timeout", this.loading = !1, this._triggerLoaded()) }), i) } _waitForParent(e) { this._mustWaitForParent && null !== this.parent && this.parent.loading ? this.parent.onLoad = e : e() } _parseAPIData(e) { throw new Error("_parseAPIData should not be called on base view") } _triggerLoaded() { if (this._alreadyLoaded) return void this._triggerUpdated(); this._alreadyLoaded = !0; if (Pe.getRegistry(this._instance).events.fire("view-loaded", this), null !== this.onLoad) { const e = this.onLoad; this.onLoad = null, e() } } _triggerUpdated() { if (!this.updating) { this.updating = !0; const e = () => { this.updating = !1; Pe.getRegistry(this._instance).events.fire("view-updated", this) }; this._checkSync() ? e() : setTimeout(e) } } } })), Me = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.isCollectionsFilterBlockEmpty = t.defaultCollectionsFilterBlock = void 0; t.defaultCollectionsFilterBlock = () => ({ type: "collections-filter", keyword: "" }), t.isCollectionsFilterBlockEmpty = function (e) { return null == e || "" === e.keyword.trim() } })), Te = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.dataToCollectionInfo = void 0; t.dataToCollectionInfo = function (e, t = "") { if ("object" != typeof e || null === e) return null; const n = e, i = (e, t, i = "") => { if ("object" != typeof n[e]) return i; const o = n[e]; return "string" == typeof o[t] ? o[t] : i }; let o, r; if ("string" == typeof n.name) o = n.name; else { if ("string" != typeof n.title) return null; o = n.title } if ("" === t) { if ("string" != typeof n.prefix) return null; r = n.prefix } else { if ("string" == typeof n.prefix && n.prefix !== t) return null; r = t } const s = { prefix: r, name: o, total: "number" == typeof n.total ? n.total : 0, version: "string" == typeof n.version ? n.version : "", author: { name: i("author", "name", "string" == typeof n.author ? n.author : "Unknown"), url: i("author", "url", "") }, license: { title: i("license", "title", "string" == typeof n.license ? n.license : "Unknown"), spdx: i("license", "spdx", ""), url: i("license", "url", "") }, samples: [], category: "string" == typeof n.category ? n.category : "", palette: "boolean" == typeof n.palette && n.palette }; if ("string" == typeof n.total) { const e = parseInt(n.total); e > 0 && (s.total = e) } if (n.samples instanceof Array && n.samples.forEach((e => { s.samples.length < 3 && "string" == typeof e && s.samples.push(e) })), "number" == typeof n.height || "string" == typeof n.height) { const e = parseInt(n.height); e > 0 && (s.height = e) } if (n.height instanceof Array) switch (n.height.forEach((e => { const t = parseInt(e); t > 0 && (s.height instanceof Array || (s.height = []), s.height.push(t)) })), s.height.length) { case 0: delete s.height; break; case 1: s.height = s.height[0] }if ("number" == typeof s.height) { for (s.displayHeight = s.height; s.displayHeight < 16;)s.displayHeight *= 2; for (; s.displayHeight > 24;)s.displayHeight /= 2; (s.displayHeight !== Math.round(s.displayHeight) || s.displayHeight < 16 || s.displayHeight > 24) && delete s.displayHeight } if ("number" == typeof n.displayHeight || "string" == typeof n.displayHeight) { const e = parseInt(n.displayHeight); e >= 16 && e <= 24 && Math.round(e) === e && (s.displayHeight = e) } if ("string" == typeof n.palette) switch (n.palette.toLowerCase()) { case "colorless": case "false": s.palette = !1; break; case "colorful": case "true": s.palette = !0 }return Object.keys(n).forEach((e => { const t = n[e]; if ("string" == typeof t) switch (e) { case "url": case "uri": s.author.url = t; break; case "licenseURL": case "licenseURI": s.license.url = t; break; case "licenseID": case "licenseSPDX": s.license.spdx = t } })), s } })), Ae = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.autoIndexCollections = t.filterCollections = t.collectionsPrefixes = t.dataToCollections = void 0, t.dataToCollections = function (e) { const t = Object.create(null), n = Object.create(null); return "object" != typeof e || null === e || (Object.keys(e).forEach((i => { const o = e[i]; if ("object" != typeof o || null === o || "string" != typeof o.category) return; const r = Te.dataToCollectionInfo(o, i); if (null === r) return; const s = o.category; "" !== s ? (void 0 === t[s] && (t[s] = Object.create(null)), t[s][i] = r) : n[i] = r })), Object.keys(n).length > 0 && (t[""] = n)), t }, t.collectionsPrefixes = function (e) { let t = []; return Object.keys(e).forEach((n => { t = t.concat(Object.keys(e[n])) })), t }, t.filterCollections = function (e, t, n = !1) { const i = Object.create(null); return Object.keys(e).forEach((o => { n && (i[o] = Object.create(null)), Object.keys(e[o]).forEach((n => { const r = e[o][n]; t(r, o, n) && (void 0 === i[o] && (i[o] = Object.create(null)), i[o][n] = r) })) })), i }, t.autoIndexCollections = function (e, t = 0) { let n = t; Object.keys(e).forEach((t => { const i = e[t]; Object.keys(i).forEach((e => { i[e].index = n++ })) })) } })), Re = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.autoIndexFilters = t.enableFilters = t.isFiltersBlockEmpty = t.defaultFiltersBlock = t.defaultFilter = void 0; t.defaultFilter = e => ({ title: e, index: 0, disabled: !1 }); t.defaultFiltersBlock = () => ({ type: "filters", filterType: "", active: null, filters: Object.create(null) }), t.isFiltersBlockEmpty = function (e) { return null == e || Object.keys(e.filters).length < 2 }, t.enableFilters = function (e, t = !0) { Object.keys(e.filters).forEach((n => { e.filters[n].disabled = !t })) }, t.autoIndexFilters = function (e, t = 0) { let n = t; return Object.keys(e.filters).forEach((t => { e.filters[t].index = n++ })), n } })), Fe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.applyCollectionsFilter = t.disableInactiveCategories = t.filterCollectionsBlock = t.iterateCollectionsBlock = t.collectionsPrefixesWithInfo = t.getCollectionsBlockPrefixes = t.getCollectionsBlockCategories = t.isCollectionsBlockEmpty = t.defaultCollectionsListBlock = void 0; function n(e, t, n = !1) { return { type: "collections-list", showCategories: e.showCategories, collections: Ae.filterCollections(e.collections, t, n) } } t.defaultCollectionsListBlock = () => ({ type: "collections-list", showCategories: !0, collections: Object.create(null) }), t.isCollectionsBlockEmpty = function (e) { if (null == e) return !0; const t = Object.keys(e.collections); for (let n = 0; n < t.length; n++)if (Object.keys(e.collections[t[n]]).length > 0) return !1; return !0 }, t.getCollectionsBlockCategories = function (e, t = !1) { let n = Object.keys(e.collections); return t && (n = n.filter((t => Object.keys(e.collections[t]).length > 0))), n }, t.getCollectionsBlockPrefixes = function (e) { return Ae.collectionsPrefixes(e.collections) }, t.collectionsPrefixesWithInfo = function (e) { const t = []; return Object.keys(e.collections).forEach((n => { const i = e.collections[n]; Object.keys(i).forEach((e => { null !== i[e] && t.push(i[e]) })) })), t }, t.iterateCollectionsBlock = function (e, t) { Object.keys(e.collections).forEach((n => { const i = e.collections[n]; Object.keys(i).forEach((e => { t(i[e], e, n) })) })) }, t.filterCollectionsBlock = n, t.disableInactiveCategories = function (e, t) { if (null === t) return e; const n = { type: "collections-list", showCategories: e.showCategories, collections: Object.create(null) }; return void 0 !== e.collections[t] && (n.collections[t] = e.collections[t]), n }; const i = ["prefix", "name", "author", "license", "category", "palette", "height"]; t.applyCollectionsFilter = function (e, t, o) { const r = t.keyword.trim(), s = null !== o && "categories" === o.filterType, c = o; if ("" === r) return s && Re.enableFilters(c, !0), e; const l = {}; return s && Re.enableFilters(c, !1), n(e, ((e, t) => { for (let n = i.length - 1; n >= 0; n--) { const o = i[n]; if (void 0 !== e[o] && be.match(e[o], r)) return s && !0 !== l[t] && (l[t] = !0, void 0 !== c.filters[t] && (c.filters[t].disabled = !1)), !0 } return !1 }), !1) } })), Le = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getCollectionTitle = t.getCollectionInfo = t.setCollectionInfo = void 0, t.setCollectionInfo = function (e, t, n, i) { void 0 === e[t] && (e[t] = Object.create(null)); const o = e[t]; (void 0 === o[n] || i.index) && (o[n] = i) }, t.getCollectionInfo = function (e, t, n) { return void 0 === e[t] || void 0 === e[t][n] ? null : e[t][n] }, t.getCollectionTitle = function (e, t, n) { return void 0 === e[t] || void 0 === e[t][n] ? n : e[t][n].name } })), Ne = ve((function (e, t) { function n(e, t, n) { const i = { prefix: { hasEmpty: !1, hasUncategorized: !1, values: [], titles: Object.create(null), found: Object.create(null), test: (e, t) => e.slice(0, t.length) === t }, suffix: { hasEmpty: !1, hasUncategorized: !1, values: [], titles: Object.create(null), found: Object.create(null), test: (e, t) => e.slice(0 - t.length) === t } }, o = ["prefix", "suffix"], r = { prefix: null, suffix: null }; if ("object" == typeof e.themes && e.themes) { const t = e.themes; Object.keys(t).forEach((e => { const n = t[e]; o.forEach((e => { const t = e; if ("string" == typeof n[t]) { const i = n[t]; null === r[e] && (r[e] = Object.create(null)), r[e][i] = n.title } })) })) } o.forEach((t => { const n = t + "es"; if ("object" == typeof e[n] && null !== e[n] && (r[t] = e[n]), !r[t]) return void delete i[t]; const o = i[t], s = r[t]; Object.keys(s).forEach((e => { const n = s[e]; if ("" !== e) switch (t) { case "prefix": "-" !== e.slice(-1) && (e += "-"); break; case "suffix": "-" !== e.slice(0, 1) && (e = "-" + e) }void 0 === o.titles[e] && ("" === e ? o.hasEmpty = !0 : o.values.push(e), o.titles[e] = n, o.found[e] = 0) })), Object.keys(o.titles).length || delete i[t] })), Object.keys(i).forEach((e => { const o = i[e], r = o.values, s = "prefix" === e ? "themePrefixes" : "themeSuffixes"; r.sort(((e, t) => e.length === t.length ? e.localeCompare(t) : t.length - e.length)), t.forEach((e => { (e.aliases ? [e.name].concat(e.aliases) : [e.name]).forEach(((t, n) => { let i = null; for (let e = 0; e < r.length; e++) { const n = r[e]; if (o.test(t, n)) { o.found[n]++, i = n; break } } null === i && o.hasEmpty && !n && (i = "", o.found[""]++); const c = null === i ? "" : o.titles[i]; if (null === i) { if (n > 0) return; o.hasUncategorized = !0, i = "" } if (void 0 === e[s]) return void (e[s] = [c]); const l = e[s]; -1 === l.indexOf(c) && l.push(c) })) })); const c = []; switch (Object.keys(o.titles).forEach((e => { o.found[e] && c.push(o.titles[e]) })), o.hasUncategorized && c.push(""), c.length) { case 0: break; case 1: t.forEach((e => { delete e[s] })); break; default: n[s] = c } })) } function i(e, t) { Object.keys(e).forEach((n => { const i = e[n]; if (void 0 !== t[i]) { const e = t[i]; void 0 === e.chars && (e.chars = []), e.chars.push(n) } })) } function o(e) { const t = []; return Object.keys(e).sort(((e, t) => e.localeCompare(t))).forEach((n => { t.push(e[n]) })), t } function r(e, t) { return "" === e ? 1 : "" === t ? -1 : e.localeCompare(t) } Object.defineProperty(t, "__esModule", { value: !0 }), t.rawDataToCollection = t.dataToCollection = void 0, t.dataToCollection = function (e, t) { if ("object" != typeof t || null === t) return null; const s = t; if ("string" != typeof s.prefix) return null; const c = { provider: e, prefix: s.prefix, name: "", total: 0, icons: [] }; if ("object" == typeof s.info && null !== s.info) { const e = Te.dataToCollectionInfo(s.info, c.prefix); if (null === e) return null; c.info = e } if ("string" == typeof s.name) c.name = s.name; else if ("string" == typeof s.title) c.name = s.title; else { if (void 0 === c.info) return null; c.name = c.info.name } let l = "object" == typeof s.categories && null !== s.categories ? Object.keys(s.categories) : [], a = !1, u = "uncategorized";["uncategorized", "uncategorised"].forEach((e => { "object" == typeof s[e] && s[e] instanceof Array && s[e].length > 0 && (u = e, a = !0) })); const f = Object.create(null); function d(t, n) { let i = !1; return t.forEach((t => { if ("string" == typeof t) if (i = !0, void 0 !== f[t]) void 0 === f[t].tags && (f[t].tags = []), -1 === f[t].tags.indexOf(n) && f[t].tags.push(n); else { const i = { provider: e, prefix: c.prefix, name: t, tags: [n] }; f[t] = i } })), i } l = l.filter((e => { let t = !1; const n = s.categories[e]; return n instanceof Array ? t = d(n, e) : Object.keys(n).forEach((i => { const o = n[i]; o instanceof Array && (t = d(o, e) || t) })), t })); const p = l.length > 0; if (a) { s[u].forEach((t => { if ("string" == typeof t && void 0 === f[t]) { const n = { provider: e, prefix: c.prefix, name: t }; return p && (n.tags = [""]), void (f[t] = n) } })), p && l.push("") } "object" == typeof s.chars && i(s.chars, f); const h = Object.create(null); if ("object" == typeof s.aliases) { const e = s.aliases; Object.keys(e).forEach((t => { const n = e[t]; if (void 0 !== f[n]) { const e = f[n]; return void 0 === e.aliases && (e.aliases = []), void e.aliases.push(t) } void 0 === h[n] && (h[n] = []), h[n].push(t) })) } if (s.hidden instanceof Array) { let e = []; s.hidden.forEach((t => { e.push(t), void 0 !== h[t] && (e = e.concat(h[t])) })), c.hidden = e } const g = o(f); return l.length > 1 ? c.tags = l.sort(r) : p && g.forEach((e => { delete e.tags })), n(s, g, c), c.icons = g, c.total = c.icons.length, c.info && (c.info.total = c.total), c }, t.rawDataToCollection = function (e) { function t(n, i = 0) { if (i > 3) return null; if (void 0 !== a[n]) return n; if (void 0 !== e.icons[n]) return e.icons[n].hidden ? null : (a[n] = { provider: c.provider, prefix: c.prefix, name: n, tags: [] }, n); if (e.aliases && void 0 !== e.aliases[n] && !e.aliases[n].hidden) { const o = e.aliases[n], r = t(o.parent, i + 1); if (null !== r) { if (o.rotate || o.hFlip || o.vFlip) return a[n] = { provider: c.provider, prefix: c.prefix, name: n, tags: [] }, n; { const e = a[r]; return e.aliases ? -1 === e.aliases.indexOf(n) && e.aliases.push(n) : e.aliases = [n], r } } } return null } function s(e, t) { let n = !1; return e.forEach((e => { void 0 !== a[e] && -1 === a[e].tags.indexOf(t) && (a[e].tags.push(t), n = !0) })), n } if ("string" != typeof e.prefix) return null; const c = { provider: "string" == typeof e.provider ? e.provider : "", prefix: e.prefix, name: "", total: 0, icons: [] }; if ("object" != typeof e.info || null === e.info) return null; const l = Te.dataToCollectionInfo(e.info, c.prefix); if (null === l) return null; c.info = l, c.name = c.info.name; const a = Object.create(null); Object.keys(e.icons).forEach((e => t(e))), "object" == typeof e.aliases && Object.keys(e.aliases).forEach((e => t(e))); const u = Object.keys(a), f = []; if ("object" == typeof e.categories && null !== e.categories) { let t = !1; const n = e.categories; Object.keys(n).forEach((e => { const t = n[e]; t instanceof Array ? s(t, e) && f.push(e) : "object" == typeof t && Object.keys(t).forEach((n => { const i = t[n]; i instanceof Array && s(i, e) && -1 === f.indexOf(e) && f.push(e) })) })), u.forEach((e => { a[e].tags.length || (a[e].tags.push(""), t = !0) })), t && f.push("") } f.length < 2 ? Object.keys(a).forEach((e => { delete a[e].tags })) : c.tags = f.sort(r), "object" == typeof e.chars && i(e.chars, a); const d = o(a); return n(e, d, c), c.icons = d, c.total = c.info.total = c.icons.length, c } })), Be = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeCollections = t.convertCustomSets = t.emptyConvertedSet = void 0, t.emptyConvertedSet = { merge: "custom-last", providers: Object.create(null) }, t.convertCustomSets = function (e, n = !0) { if (!e.iconSets || !e.iconSets.length) return t.emptyConvertedSet; let i = "only-custom"; switch (e.merge) { case "custom-first": case "custom-last": case "only-custom": i = e.merge; break; case void 0: break; default: e.merge }const o = { merge: i, providers: Object.create(null) }, r = Object.create(null); return e.iconSets.forEach((t => { if ("string" != typeof t.prefix) return; "string" == typeof e.provider && (t.provider = e.provider); const i = "string" == typeof t.provider ? t.provider : ""; !t.info && e.info && e.info[t.prefix] && (t.info = e.info[t.prefix]); const s = Ne.rawDataToCollection(t); if (!s) return; void 0 === o.providers[i] && (o.providers[i] = { total: 0, data: Object.create(null), collections: {} }); const c = o.providers[i]; if (void 0 !== c.data[s.prefix]) return; c.data[s.prefix] = s, c.total++, void 0 === r[i] && (r[i] = Object.create(null)); const l = Object.assign({}, t.info); l.total = s.total, r[i][s.prefix] = l, n && we.Iconify.addCollection && we.Iconify.addCollection(t) })), Object.keys(r).forEach((e => { o.providers[e].collections = Ae.dataToCollections(r[e]) })), o }, t.mergeCollections = function (e, t, n) { const i = []; if (t && i.push({ isCustom: !1, categories: t }), n) { const t = n.providers[e].collections; i["custom-first" === n.merge ? "unshift" : "push"]({ isCustom: !0, categories: t }) } const o = Object.create(null), r = Object.create(null); return i.forEach((e => { const t = e.categories; Object.keys(t).forEach((n => { const i = t[n]; Object.keys(i).forEach((t => { if (void 0 !== r[t]) { if (!e.isCustom) return; delete o[r[t]][t] } r[t] = n, void 0 === o[n] && (o[n] = Object.create(null)), o[n][t] = i[t] })) })) })), o } })), Ve = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.CollectionsView = void 0; class n extends Ee.BaseView { constructor(e, t, n = null) { super(), this._data = null, this._blocks = null, this.type = "collections", this._instance = e, this.route = t, this.provider = t.params.provider, this.parent = n; const i = Pe.getRegistry(this._instance), o = i.customIconSets; void 0 !== o.providers[this.provider] ? this._sources = { custom: !0, api: "only-custom" !== o.merge, merge: o.merge } : this._sources = { custom: !1, api: !0 }; const r = i.getCustom("core-cache"); if ("object" == typeof r) { const e = r[this.provider]; e && e.collections && (this._data = e.collections) } } _startLoadingData() { !this._data && this._sources.api ? this._loadAPI(this.provider, "/collections", {}, je.collectionsCacheKey()) : this._parseAPIData(null) } action(e, t) { switch (e) { case "parent": return void this._parentAction(t); case "provider": return void (t !== this.provider && this._providerAction(t)); case "search": return void (this._sources.api && this._searchAction(this.provider, t)); case "filter": if ("string" != typeof t) return; if (t = t.trim().toLowerCase(), this.route.params.filter === t) return; this.route.params.filter = t, this.blocksRequireUpdate = !0; break; case "categories": if (null !== t && "string" != typeof t || t === this.route.params.category) return; this.route.params.category = t, this.blocksRequireUpdate = !0; break; case "collections-internal": if ("string" != typeof t || "" === t) return; return void this._triggerCollectionAction(t, 1); case "collections": if ("string" != typeof t || "" === t) return; return void this._triggerCollectionAction(t, 0); default: return }this._triggerUpdated() } _triggerCollectionAction(e, t) { if (!this.loading && null !== this._data && "" === this.error) { const t = Object.keys(this._data); let n = !1; for (let i = 0; i < t.length; i++)if (void 0 !== this._data[t[i]][e]) { n = !0; break } if (!n) return } Pe.getRegistry(this._instance).router.createChildView({ type: "collection", params: { provider: this.provider, prefix: e } }, t) } render() { if (this.loading || null === this._blocks || null === this._data) return null; if (!this.blocksRequireUpdate || "" !== this.error) return this._blocks; this.blocksRequireUpdate = !1; const e = this._blocks, t = "string" == typeof this.route.params.filter ? this.route.params.filter : "", n = "string" == typeof this.route.params.category ? this.route.params.category : null; return e.filter.keyword = t, e.categories.active = n, e.collections.collections = this._data, e.collections = Fe.applyCollectionsFilter(e.collections, e.filter, e.categories), null !== n && (e.collections = Fe.disableInactiveCategories(e.collections, n)), e } getCollectionsBlock() { if (this.loading || "" !== this.error) return null; const e = this.render(); return null !== e && null !== e.collections ? e.collections : null } _parseAPIData(e) { if (!this._sources.api || e || this._data ? this._data || (this._data = Be.mergeCollections(this.route.params.provider, this._sources.api ? Ae.dataToCollections(e) : null, this._sources.custom ? Pe.getRegistry(this._instance).customIconSets : null)) : this._data = null, this.loading = !1, this.blocksRequireUpdate = !0, this.error = "", this._blocks = { filter: Me.defaultCollectionsFilterBlock(), categories: Re.defaultFiltersBlock(), collections: Fe.defaultCollectionsListBlock() }, this._blocks.categories.filterType = "categories", null === this._data) this.error = null === e ? "not_found" : "invalid_data"; else { Ae.autoIndexCollections(this._data), this._blocks.collections.collections = this._data; const e = Fe.getCollectionsBlockCategories(this._blocks.collections, !0); if (0 === e.length) this.error = "empty"; else { if (e.length > 1) { this._blocks.collections.showCategories = !0; const t = this._blocks.categories.filters; e.forEach((e => { t[e] = Re.defaultFilter(e) })), Re.autoIndexFilters(this._blocks.categories) } else this._blocks.collections.showCategories = !1; const t = Pe.getRegistry(this._instance).collections; Fe.iterateCollectionsBlock(this._blocks.collections, ((e, n) => { Le.setCollectionInfo(t, this.provider, n, e) })) } } this._triggerLoaded() } } t.CollectionsView = n })), De = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.isCollectionInfoBlockEmpty = t.defaultCollectionInfoBlock = void 0; t.defaultCollectionInfoBlock = () => ({ type: "collection-info", prefix: "", info: null }), t.isCollectionInfoBlockEmpty = function (e) { return null == e || null === e.info } })), ze = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.applyIconFilters = t.isIconsListBlockEmpty = t.defaultIconsListBlock = void 0; t.defaultIconsListBlock = () => ({ type: "icons-list", icons: [] }), t.isIconsListBlockEmpty = function (e) { return null == e || e.icons.length < 1 }; const n = ["name", "chars", "aliases"], i = ["prefix", "name", "chars", "aliases"]; t.applyIconFilters = function (e, t, o = [], r = !1) { let s = e.icons.slice(0); const c = r ? i : n, l = t ? t.keyword.trim() : ""; if ("" !== l) { const e = l.toLowerCase().split(/[\s:]/).map((e => e.trim())).filter((e => e.length > 0)); if (e.length) { const t = c.slice(0); e.forEach((e => { let n = !1; ("-" !== e.slice(0, 1) || (n = !0, (e = e.slice(1)).length)) && (s = s.filter((i => { const o = i; let r = !1; return t.forEach((t => { r || void 0 === o[t] || ("string" != typeof o[t] ? o[t] instanceof Array && o[t].forEach((t => { r = r || -1 !== t.indexOf(e) })) : r = -1 !== o[t].indexOf(e)) })), n ? !r : r }))) })) } } const a = s.length !== e.icons.length; return o.forEach((e => { if (Re.enableFilters(e, !0), !a) return; const t = e.filterType; null !== t && Object.keys(e.filters).forEach((n => { for (let e = s.length - 1; e >= 0; e--) { const i = s[e][t]; if (null != i) if ("string" != typeof i) { if (i instanceof Array && -1 !== i.indexOf(n)) return } else if (i === n) return } e.filters[n].disabled = !0 })) })), o.forEach((e => { if (null === e.active) return; const t = e.active, n = e.filterType; null !== n && (s = s.filter((e => { const i = e[n]; return null != i && ("string" == typeof i ? i === t : i instanceof Array && -1 !== i.indexOf(t)) }))) })), e.icons = s, e } })), qe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.showPagination = t.getPageForIndex = t.maxPage = t.isPaginationEmpty = t.defaultPaginationBlock = void 0; function n(e) { return e.perPage && e.length > 0 ? Math.floor((e.length - 1) / e.perPage) : 0 } t.defaultPaginationBlock = () => ({ type: "pagination", page: 0, length: 0, perPage: 24, more: !1 }), t.isPaginationEmpty = function (e) { return null == e || e.length <= e.perPage }, t.maxPage = n, t.getPageForIndex = function (e, t) { return e && t > 0 ? Math.floor(t / e) : 0 }, t.showPagination = function (e) { const t = e.length ? n(e) + 1 : 0, i = []; let o, r; if (t < 2) return i; if (t < 14) { for (o = 0; o < t; o++)i.push(o); return i } for (o = 0; o < Math.min(t, 3); o++)i.push(o); if ((r = o) >= t) return i; for (o = r === e.page - 3 ? r : Math.max(e.page - 2, r); o < Math.min(e.page + 3, t); o++)i.push(o); if ((r = o) >= t) return i; for (o = r === t - 4 ? t - 4 : Math.max(t - 3, r); o < t; o++)i.push(o); return i } })), Ue = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.isSearchBlockEmpty = t.defaultSearchBlock = void 0; t.defaultSearchBlock = () => ({ type: "search", keyword: "" }), t.isSearchBlockEmpty = function (e) { return null == e || "" === e.keyword.trim() } })), He = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.CollectionView = void 0; const n = ["tags", "themePrefixes", "themeSuffixes"]; class i extends Ee.BaseView { constructor(e, t, n = null) { super(), this._data = null, this._blocks = null, this.type = "collection", this._instance = e, this.route = t, this.provider = t.params.provider, this.parent = n, this.prefix = t.params.prefix; const i = Pe.getRegistry(this._instance), o = i.customIconSets; if (void 0 !== o.providers[this.provider] && void 0 !== o.providers[this.provider].data[this.prefix] ? (this._isCustom = !0, this._data = o.providers[this.provider].data[this.prefix]) : this._isCustom = !1, this._mustWaitForParent = null !== n && ("search" === n.type || "collections" === n.type), !this._data) { const e = i.getCustom("core-cache"); if ("object" == typeof e && e[this.provider]) { const t = e[this.provider].collection; t && t[this.prefix] && (this._data = t[this.prefix]) } } } _startLoadingData() { if (this._data) this._parseAPIData(null); else { const e = { prefix: this.prefix, info: "true", chars: "true", aliases: "true" }; "" !== this.route.params.icon && (e.hidden = "true"), this._loadAPI(this.provider, "/collection", e, je.collectionCacheKey(this.prefix)) } } action(e, t) { switch (e) { case "parent": return void this._parentAction(t); case "provider": return void (t !== this.provider && this._providerAction(t)); case "search": return void this._searchAction(this.provider, t); case "filter": if ("string" != typeof t) return; if ((t = t.trim().toLowerCase()) === this.route.params.filter) return; this.route.params.filter = t, this.blocksRequireUpdate = !0; break; case "pagination": if ("string" == typeof t && (t = parseInt(t)), "number" != typeof t || isNaN(t) || t < 0 || t === this.route.params.page) return; this.route.params.page = t, this.blocksRequireUpdate = !0; break; case "icons-nav": if ("" === t || null === t) { this.route.params.icon = ""; break } if ("string" != typeof t) return; this.route.params.icon = t, this.route.params.page = null, this.blocksRequireUpdate = !0; break; case "tags": return void this._filterAction("tag", t); case "themePrefixes": return void this._filterAction("themePrefix", t); case "themeSuffixes": return void this._filterAction("themeSuffix", t); case "collections": return void this._collectionsAction(t); default: return }this._triggerUpdated() } _filterAction(e, t) { null !== t && "string" != typeof t || this.route.params[e] !== t && (this.route.params[e] = t, this.blocksRequireUpdate = !0, this._triggerUpdated()) } _collectionsAction(e) { null === this.parent || "search" !== this.parent.type && "collections" !== this.parent.type || (e !== this.prefix && null !== e ? "string" == typeof e && this.parent.action("collections-internal", e) : this._parentAction(1)) } _getIconIndex(e, t) { for (let n = 0; n < e.length; n++) { const i = e[n]; if (i.name === t) return n; if (i.aliases) { const e = i.aliases; for (let i = 0; i < e.length; i++)if (e[i] === t) return n } } return !1 } render() { if (this.loading || null === this._blocks || null === this._data) return null; if (!this.blocksRequireUpdate || "" !== this.error) return this._blocks; this.blocksRequireUpdate = !1; const e = this._blocks; e.icons.icons = this._data.icons.slice(0), e.filter.keyword = this.route.params.filter, null !== e.tags && (e.tags.active = this.route.params.tag), null !== e.themePrefixes && (e.themePrefixes.active = this.route.params.themePrefix), null !== e.themeSuffixes && (e.themeSuffixes.active = this.route.params.themeSuffix); let t = e.icons.icons; const i = this.route.params.icon; let o = "" !== i && this._getIconIndex(t, i); if (!1 !== o) { const n = t.length - 1; e["icons-nav"] = { type: "icons-nav", first: t[0], last: t[n], reference: t[o], prev: o > 0 ? t[o - 1] : void 0, next: o < n ? t[o + 1] : void 0 } } else "" !== i && this._data.hidden && -1 !== this._data.hidden.indexOf(i) ? e["icons-nav"] = { type: "icons-nav", first: t[0], last: t[t.length - 1], reference: { provider: this.provider, prefix: this.prefix, name: i } } : e["icons-nav"] = null; e.icons = ze.applyIconFilters(e.icons, e.filter, n.filter((t => null !== e[t])).map((t => e[t]))), t = e.icons.icons; const r = e.pagination.perPage; let s; null !== this.route.params.page ? s = this.route.params.page : "" === i ? s = 0 : (t.length !== this._data.icons.length && (o = this._getIconIndex(t, i)), s = !1 === o ? 0 : qe.getPageForIndex(r, o)), e.pagination.length = e.icons.icons.length, e.pagination.page = s; const c = qe.maxPage(e.pagination); c < e.pagination.page && (this.route.params.page = e.pagination.page = c); const l = e.pagination.page * r; return e.icons.icons = t.slice(l, l + r), this._blocks } _parseAPIData(e) { this._data || this._isCustom || (this._data = Ne.dataToCollection(this.provider, e)), this.loading = !1, this.blocksRequireUpdate = !0, this.error = "", this._blocks = { info: De.defaultCollectionInfoBlock(), filter: Object.assign(Ue.defaultSearchBlock(), { keyword: this.route.params.filter, searchType: "collection", title: this.prefix }), collections: null, tags: null, themePrefixes: null, themeSuffixes: null, icons: ze.defaultIconsListBlock(), pagination: qe.defaultPaginationBlock(), "icons-nav": null }; const t = this._blocks; if (null === this._data) return this.error = null === e ? "not_found" : "invalid_data", void this._triggerLoaded(); const i = this._data; if (this.prefix !== i.prefix) return this.error = "invalid_data", void this._triggerLoaded(); const o = Pe.getRegistry(this._instance), r = o.config, s = o.collections; if (t.info.prefix = this.prefix, void 0 !== i.info && Le.setCollectionInfo(s, this.provider, this.prefix, i.info), t.info.info = Le.getCollectionInfo(s, this.provider, this.prefix), null !== t.info.info && (t.filter.title = t.info.info.name), i.total < 1) this.error = "empty"; else { const e = t.pagination; e.perPage = r.ui.itemsPerPage, e.fullLength = e.length = i.icons.length; const o = this.route.params.page; if (e.page = null === o ? 0 : Math.min(o, qe.maxPage(e)), this.parent && !this.parent.loading) if ("search" === this.parent.type) { const e = this.parent.getCollectionsBlock(); null !== e && (this._blocks.collections = e, this._blocks.collections.active = this.prefix) } else "collections" === this.parent.type && (this._blocks.collections = this._findSiblingCollections()); let s = 0; n.forEach((e => { const n = e; if (void 0 !== i[n]) { const o = i[n]; if (o instanceof Array && o.length > 1) { const n = Re.defaultFiltersBlock(); n.filterType = e, t[e] = n, o.forEach((e => { n.filters[e] = Re.defaultFilter(e) })), s = Re.autoIndexFilters(n, s) } } })) } this._triggerLoaded() } _findSiblingCollections() { const e = this.parent.getCollectionsBlock(); if (null === e) return null; const t = Fe.collectionsPrefixesWithInfo(e), n = t.find((e => e.prefix === this.prefix)); if (void 0 === n || t.length < 2) return null; const i = Pe.getRegistry(this._instance).config.ui.showSiblingCollections; let o = []; if (t.length < 2 * i + 2) o = t.slice(0); else { const e = t.indexOf(n); for (let n = e - i; n < e; n++)o.push(t[(n + t.length) % t.length]); o.push(n); for (let n = e + 1; n <= e + i; n++)o.push(t[n % t.length]) } const r = Re.defaultFiltersBlock(); return r.filterType = "collections", r.active = this.prefix, o.forEach((e => { const t = Re.defaultFilter(e.name); t.index = e.index, r.filters[e.prefix] = t })), r } } t.CollectionView = i })), Ke = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateIcon = t.stringToIcon = void 0; t.stringToIcon = (e, n, i, o = "") => { const r = e.split(":"); if ("@" === e.slice(0, 1)) { if (r.length < 2 || r.length > 3) return null; o = r.shift().slice(1) } if (r.length > 3 || !r.length) return null; if (r.length > 1) { const e = r.pop(), i = r.pop(), s = { provider: r.length > 0 ? r[0] : o, prefix: i, name: e }; return n && !t.validateIcon(s) ? null : s } const s = r[0], c = s.split("-"); if (c.length > 1) { const e = { provider: o, prefix: c.shift(), name: c.join("-") }; return n && !t.validateIcon(e) ? null : e } if (i && "" === o) { const e = { provider: o, prefix: "", name: s }; return n && !t.validateIcon(e, i) ? null : e } return null }; t.validateIcon = (e, t) => !!e && !("" !== e.provider && !e.provider.match(xe.matchName) || !(t && "" === e.prefix || e.prefix.match(xe.matchName)) || !e.name.match(xe.matchName)) })), Ge = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.iconToString = t.compareIcons = t.validateIcon = t.stringToIcon = t.match = void 0, Object.defineProperty(t, "validateIcon", { enumerable: !0, get: function () { return Ke.validateIcon } }), t.match = /^[a-z0-9]+(-[a-z0-9]+)*$/; t.stringToIcon = (e, t = !1, n = "") => Ke.stringToIcon(e, t, !1, n); t.compareIcons = (e, t) => null !== e && null !== t && e.provider === t.provider && e.name === t.name && e.prefix === t.prefix; t.iconToString = e => ("" === e.provider ? "" : "@" + e.provider + ":") + e.prefix + ":" + e.name })), Je = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.dataToSearchResults = void 0, t.dataToSearchResults = function (e, t) { if ("object" != typeof t || null === t) return null; const n = t; if ("object" != typeof n.request || null === n.request) return null; const i = n.request; if ("string" != typeof i.query) return null; if ("number" != typeof n.total || "number" != typeof n.limit) return null; const o = { provider: e, query: i.query, total: n.total, limit: n.limit, icons: [], collections: Object.create(null) }; if ("object" != typeof n.collections || !(n.icons instanceof Array)) return null; const r = n.icons, s = n.collections; try { r.forEach((t => { const n = Ge.stringToIcon(t, !0, e); if (null === n) throw new Error("Invalid icon"); o.icons.push(n); const i = n.prefix; if (void 0 === o.collections[i]) { if (void 0 === s[i]) throw new Error(`Missing data for prefix ${i}`); const e = Te.dataToCollectionInfo(s[i], i); if (null === e) throw new Error(`Invalid data for prefix ${i}`); o.collections[i] = e } })) } catch (e) { return null } return o.total = o.icons.length, o } })), We = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.SearchView = void 0; class n extends Ee.BaseView { constructor(e, t, n = null) { super(), this._data = null, this._blocks = null, this.type = "search", this._instance = e, this.route = t, this.provider = t.params.provider, this.parent = n, this.keyword = t.params.search; const i = Pe.getRegistry(this._instance), o = i.config; this.itemsPerPage = o.ui.itemsPerPage, this.route.params.page > 1 && (this.route.params.short = !1); const r = i.getCustom("core-cache"); if ("object" == typeof r && r[this.provider]) { const e = r[this.provider].search; e && e[this.keyword] && (this._data = e[this.keyword], this.route.params.short = !1) } this.itemsLimit = this.route.params.short ? 2 * this.itemsPerPage : 999 } _startLoadingData() { if (this._data) this._parseAPIData(null); else { const e = this.keyword, t = this.itemsLimit; this._loadAPI(this.provider, "/search", { query: e, limit: t }, je.searchCacheKey(e, t)) } } action(e, t) { switch (e) { case "parent": return void this._parentAction(t); case "provider": return void (t !== this.provider && this._providerAction(t)); case "search": if ("string" != typeof t) return; if ((t = t.trim().toLowerCase()) === this.keyword) return; return void this._searchAction(this.provider, t); case "pagination": if ("more" === t && this._showMoreButton() && (t = this.route.params.page + 1), "string" == typeof t && (t = parseInt(t)), "number" != typeof t || isNaN(t) || t === this.route.params.page || t < 0) return; if (t > 0 && this._showMoreButton()) return void this._triggerFullResults(t); this.route.params.page = t, this.blocksRequireUpdate = !0; break; case "collections": return void this._collectionsAction(t, 0); case "collections-internal": return void this._collectionsAction(t, 1); default: return }this._triggerUpdated() } _collectionsAction(e, t) { if (null !== e && "string" != typeof e) return; if (this.loading || null === this._blocks || null === this._blocks.collections) return; const n = Pe.getRegistry(this._instance).router; if (null === e) return void n.setParentView(t); const i = e; n.createChildView({ type: "collection", params: { provider: this.provider, prefix: i, filter: this.keyword } }, t) } _triggerFullResults(e) { Pe.getRegistry(this._instance).router.createChildView({ type: "search", params: Object.assign({}, this.route.params, { page: e, short: !1 }) }, 1) } render() { if (this.loading || null === this._blocks || null === this._data) return null; if (!this.blocksRequireUpdate || "" !== this.error) return this._blocks; this.blocksRequireUpdate = !1; const e = this._blocks; e.icons.icons = this._data.icons.slice(0), null !== e.collections && (e.collections.active = null), e.pagination.length = e.icons.icons.length, e.pagination.page = this.route.params.page; const t = qe.maxPage(e.pagination); t < e.pagination.page && (this.route.params.page = e.pagination.page = t); const n = e.pagination.page * this.itemsPerPage; return e.icons.icons = e.icons.icons.slice(n, n + this.itemsPerPage), this._blocks } getCollectionsBlock() { if (this.loading || "" !== this.error) return null; const e = this.render(); return null !== e && null !== e.collections ? be.cloneObject(e.collections) : null } _showMoreButton() { return null !== this._data && (this.route.params.short && this._data.total === this._data.limit) } _parseAPIData(e) { this._data || (this._data = Je.dataToSearchResults(this.provider, e)), this.loading = !1, this.blocksRequireUpdate = !0, this.error = "", this._blocks = { collections: null, icons: ze.defaultIconsListBlock(), pagination: qe.defaultPaginationBlock() }; const t = this._blocks; if (null === this._data) return this.error = null === e ? "not_found" : "invalid_data", void this._triggerLoaded(); const n = this._data; if (this.keyword !== n.query) return this.error = "invalid_data", void this._triggerLoaded(); if (n.limit && (this.itemsLimit = n.limit), n.total < 1) this.error = "empty"; else { const e = t.pagination; e.perPage = this.itemsPerPage, e.fullLength = e.length = n.icons.length, e.page = Math.min(this.route.params.page, qe.maxPage(e)), e.more = this._showMoreButton(); const i = Object.keys(n.collections), o = Pe.getRegistry(this._instance).collections; if (i.forEach((e => { Le.setCollectionInfo(o, this.provider, e, n.collections[e]) })), i.length > 1) { const e = Re.defaultFiltersBlock(); this._blocks.collections = e, e.filterType = "collections", i.forEach((t => { e.filters[t] = Re.defaultFilter(n.collections[t].name) })), Re.autoIndexFilters(e) } } this._triggerLoaded() } } t.SearchView = n })), Qe = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomView = void 0; class n extends Ee.BaseView { constructor(e, t, n = null) { super(), this._data = null, this._blocks = null, this.type = "custom", this._instance = e, this.route = t, this.parent = n, this.customType = t.params.customType, this._mustWaitForParent = !0 } _startLoadingData() { if (null !== this._data) return; Pe.getRegistry(this._instance).events.fire("load-" + this.customType, this.setIcons.bind(this)) } action(e, t) { switch (e) { case "parent": return void this._parentAction(t); case "provider": return void this._providerAction(t); case "set": return void this.setIcons(t); case "filter": if ("string" != typeof t) return; if ((t = t.trim().toLowerCase()) === this.route.params.filter) return; this.route.params.filter = t, this.blocksRequireUpdate = !0; break; case "pagination": if ("string" == typeof t && (t = parseInt(t)), "number" != typeof t || isNaN(t) || t < 0 || t === this.route.params.page) return; this.route.params.page = t, this.blocksRequireUpdate = !0; break; default: return }this._triggerUpdated() } render() { if (this.loading || null === this._blocks || null === this._data) return null; if (!this.blocksRequireUpdate || "" !== this.error) return this._blocks; this.blocksRequireUpdate = !1; const e = this._blocks; e.icons.icons = this._data.slice(0), e.filter.keyword = this.route.params.filter, e.icons = ze.applyIconFilters(e.icons, e.filter, [], !0); const t = Pe.getRegistry(this._instance).config.ui.itemsPerPage; e.pagination.length = e.icons.icons.length, e.pagination.page = this.route.params.page; const n = qe.maxPage(e.pagination); n < e.pagination.page && (this.route.params.page = e.pagination.page = n); const i = e.pagination.page * t; return e.icons.icons = e.icons.icons.slice(i, i + t), this._blocks } setIcons(e) { this._waitForParent((() => { this._checkSync() ? this._setIcons(e) : setTimeout((() => { this._setIcons(e) })) })) } _setIcons(e) { let t = e, n = !1; t instanceof Array || (n = !0, t = []); const i = t.map((e => { if ("string" == typeof e && (e = Ge.stringToIcon(e)), "object" == typeof e && Ge.validateIcon(e)) { const t = e; return { provider: t.provider, prefix: t.prefix, name: t.name } } return null })).filter((e => null !== e)); this._data = i, this.loading = !1, this.blocksRequireUpdate = !0, this.error = "", this._blocks = { filter: Object.assign(Ue.defaultSearchBlock(), { keyword: this.route.params.filter, searchType: "custom", title: this.customType }), icons: ze.defaultIconsListBlock(), pagination: qe.defaultPaginationBlock() }; const o = this._blocks; if (n) return this.error = null === e ? "not_found" : "invalid_data", void this._triggerLoaded(); if (i.length < 1) this.error = "empty"; else { const e = Pe.getRegistry(this._instance).config, t = o.pagination; t.perPage = e.ui.itemsPerPage, t.fullLength = t.length = i.length, t.page = Math.min(this.route.params.page, qe.maxPage(t)) } this._triggerLoaded() } getIcons() { return this.loading || null === this._blocks || null === this._data ? null : be.cloneObject(this._data) } } t.CustomView = n })), Ye = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.EmptyView = void 0; class n extends Ee.BaseView { constructor(e, t, n = null) { super(), this.type = "empty", this._instance = e, this.route = t, this.parent = n } _startLoadingData() { this.loading = !1, this._triggerLoaded() } action(e, t) { switch (e) { case "parent": return void this._parentAction(t); case "provider": return void this._providerAction(t) } } render() { return {} } } t.EmptyView = n })), Xe = ve((function (e, t) { function n(e, t) { switch (e.type) { case "collections": case "collection": case "search": void 0 === e.params && (e.params = {}), e.params.provider = t }e.parent && n(e.parent, t) } Object.defineProperty(t, "__esModule", { value: !0 }), t.Router = void 0; t.Router = class { constructor(e) { this._view = null, this._visibleView = null, this._timer = null, this.defaultProvider = "", this._instance = e; const t = Pe.getRegistry(this._instance).events; t.subscribe("view-loaded", (e => { this._viewEvent(e) })), t.subscribe("view-updated", (e => { this._viewEvent(e) })) } error() { return null === this._visibleView || this._visibleView.loading ? "loading" : this._visibleView.error } render() { return null === this._visibleView ? null : this._visibleView.render() } set partialRoute(e) { this._setRoute(e ? Se.objectToRoute(e) : null) } get partialRoute() { return this._visibleView ? Se.routeToObject(this._visibleView.route) : null } set fullRoute(e) { this._setRoute(e) } get fullRoute() { return this._visibleView ? this._visibleView.route : null } home(e = null) { const t = Pe.getRegistry(this._instance), i = t.config.router.home; let o = null; if ("" !== i) o = Se.objectToRoute(JSON.parse(i)); else { const n = t.customIconSets, i = "string" == typeof e ? e : this.defaultProvider; if (void 0 === n.providers[i]) o = Se.objectToRoute({ type: "collections" }); else { const e = n.providers[i]; let t = e.total > 1; t || "only-custom" === n.merge || (t = this._checkProvider(i, !1)), o = Se.objectToRoute(t ? { type: "collections", params: { provider: i } } : { type: "collection", params: { provider: i, prefix: Object.keys(e.data).shift() } }) } } if (null === o) throw new Error("Error resetting route"); n(o, null !== e && this._checkProvider(e) ? e : this.defaultProvider); const r = this._viewFromRoute(o); if (null === r) throw new Error("Error resetting route"); this._setView(r, !0) } action(e, t) { null !== this._visibleView && (this._changeCurrentView(), this._visibleView.action(e, t)) } setCustomIcons(e, t) { const n = this._getCustomView(e); return null !== n && (n.setIcons(t), !0) } getCustomIcons(e) { const t = this._getCustomView(e); return null === t ? null : t.getIcons() } _setRoute(e) { let t; if (e && e.params) { const t = e.params.provider; "string" != typeof t || "" === t || this._checkProvider(t) || (e = null) } null === e || null === (t = this._viewFromRoute(e)) ? this.home() : this._setView(t, !0) } _getCustomView(e) { return null === this._visibleView || null === this._view ? null : "custom" === this._visibleView.type && this._visibleView.type === e ? this._visibleView : "custom" === this._view.type && this._view.type === e ? this._view : null } createChildView(e, t = 0) { const n = null === e ? null : Se.objectToRoute(e); if (null === n) return; let i = this._visibleView; for (let e = 0; e < t; e++)null !== i && (i = i.parent); const o = this._viewFromRoute(n, i); null !== o && (this._changeCurrentView(), this._setView(o, !1)) } setParentView(e = 1) { let t = this._visibleView; for (let n = 0; n < e; n++) { if (null === t || null === t.parent) return; t = t.parent } t !== this._visibleView && this._setView(t, !0) } _setView(e, t) { this._view = e, e.startLoading(), this._visibleView !== e && (t || !e.loading || null === this._visibleView ? (this._visibleView = e, this._triggerChange(!0)) : this._startTimer()) } _changeCurrentView() { return this._view !== this._visibleView && (this._view = this._visibleView, this._stopTimer(), !0) } _changeVisibleView() { return this._view !== this._visibleView && (this._visibleView = this._view, this._stopTimer(), this._triggerChange(!0), !0) } _viewFromRoute(e, t) { let n = null; if (void 0 !== t) n = t, e.parent = null === t ? null : t.route; else if (null !== e.parent && (n = this._viewFromRoute(e.parent), null === n)) return null; switch (e.type) { case "collections": return new Ve.CollectionsView(this._instance, e, n); case "collection": return new He.CollectionView(this._instance, e, n); case "search": return new We.SearchView(this._instance, e, n); case "custom": return new Qe.CustomView(this._instance, e, n); case "empty": return new Ye.EmptyView(this._instance, e, n); default: return null } } _viewEvent(e) { e === this._view && (this._changeVisibleView() || this._triggerChange(!1)) } _triggerChange(e) { const t = Pe.getRegistry(this._instance).events, n = this.render(), i = { viewChanged: e, error: this.error(), route: this.partialRoute, blocks: n }; t.fire("render", i) } _startTimer() { this._stopTimer(); const e = Pe.getRegistry(this._instance).config.ui.viewUpdateDelay; if (e) { const t = this._view; this._timer = setTimeout((() => { this._view === t && this._changeVisibleView() }), e) } else this._changeVisibleView() } _stopTimer() { null !== this._timer && (clearTimeout(this._timer), this._timer = null) } _checkProvider(e, t = !0) { if (null !== Ce.getProvider(e)) return !0; if (!t) return !1; return void 0 !== Pe.getRegistry(this._instance).customIconSets.providers[e] } } })), Ze = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.Registry = void 0; t.Registry = class { constructor(e) { this._data = Object.create(null); const t = "string" == typeof e ? e : "object" == typeof e && "string" == typeof e.namespace ? e.namespace : "iconify"; this.namespace = t, this.id = Pe.uniqueId(t), this.initialised = Pe.addRegistry(this), this._sharedData = Pe.getSharedData(t), this.params = "object" == typeof e ? e : {}, this._save() } _save() { Pe.saveRegistry(this) } get config() { return void 0 === this._sharedData.config && (this._sharedData.config = ke.createConfig(this.params.config)), this._sharedData.config } set config(e) { this._sharedData.config = e } get events() { return void 0 === this._data.events && (this._data.events = new _e.Events), this._data.events } set events(e) { this._data.events = e } get api() { return void 0 === this._sharedData.api && (this._sharedData.api = new Ie.API(this)), this._sharedData.api } set api(e) { this._sharedData.api = e } get customIconSets() { return void 0 === this._data.customIconSets && (this._data.customIconSets = Be.emptyConvertedSet), this._data.customIconSets } set customIconSets(e) { this._data.customIconSets = e } get collections() { return void 0 === this._sharedData.collections && (this._sharedData.collections = Object.create(null)), this._sharedData.collections } set collections(e) { this._sharedData.collections = e } get router() { return void 0 === this._data.router && (this._data.router = new Xe.Router(this.id)), this._data.router } set router(e) { this._data.router = e } get fullRoute() { return this.router.fullRoute } set fullRoute(e) { this.router.fullRoute = e } get partialRoute() { return this.router.partialRoute } set partialRoute(e) { this.router.partialRoute = e } getCustom(e, t = !0) { const n = t ? this._data : this._sharedData; if (void 0 !== n.custom) return n.custom[e] } setCustom(e, t, n = !0) { const i = n ? this._data : this._sharedData; void 0 === i.custom && (i.custom = Object.create(null)); const o = i.custom; n && void 0 === o[e] && Object.defineProperty(this, e, { get: () => o[e], set(t) { o[e] = t } }), o[e] = t } destroy() { Pe.destroyRegistry(this) } } })), et = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.isBlockEmpty = void 0, t.isBlockEmpty = function (e) { if (null == e) return !0; switch (e.type) { case "collection-info": return De.isCollectionInfoBlockEmpty(e); case "collections-filter": return Me.isCollectionsFilterBlockEmpty(e); case "collections-list": return Fe.isCollectionsBlockEmpty(e); case "filters": return Re.isFiltersBlockEmpty(e); case "icons-list": return ze.isIconsListBlockEmpty(e); case "pagination": return qe.isPaginationEmpty(e); case "search": return Ue.isSearchBlockEmpty(e); case "icons-nav": return !1; default: return !0 } } })), tt = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getCoreInstance = t.IconFinderCore = t.cloneObject = t.compareObjects = t.stringToIcon = t.compareIcons = t.validateIcon = t.iconToString = t.setComponentsConfig = t.mergeConfig = t.customisedConfig = t.getCollectionTitle = t.getCollectionInfo = t.objectToRoute = t.listProviders = t.convertProviderData = t.getProvider = t.addProvider = t.setIconify = t.maxPage = t.showPagination = t.iterateCollectionsBlock = t.getCollectionsBlockPrefixes = t.getCollectionsBlockCategories = t.isBlockEmpty = void 0, Object.defineProperty(t, "getCollectionInfo", { enumerable: !0, get: function () { return Le.getCollectionInfo } }), Object.defineProperty(t, "isBlockEmpty", { enumerable: !0, get: function () { return et.isBlockEmpty } }), Object.defineProperty(t, "getCollectionsBlockCategories", { enumerable: !0, get: function () { return Fe.getCollectionsBlockCategories } }), Object.defineProperty(t, "getCollectionsBlockPrefixes", { enumerable: !0, get: function () { return Fe.getCollectionsBlockPrefixes } }), Object.defineProperty(t, "iterateCollectionsBlock", { enumerable: !0, get: function () { return Fe.iterateCollectionsBlock } }), Object.defineProperty(t, "showPagination", { enumerable: !0, get: function () { return qe.showPagination } }), Object.defineProperty(t, "maxPage", { enumerable: !0, get: function () { return qe.maxPage } }), Object.defineProperty(t, "setIconify", { enumerable: !0, get: function () { return we.setIconify } }), Object.defineProperty(t, "addProvider", { enumerable: !0, get: function () { return Ce.addProvider } }), Object.defineProperty(t, "getProvider", { enumerable: !0, get: function () { return Ce.getProvider } }), Object.defineProperty(t, "convertProviderData", { enumerable: !0, get: function () { return Ce.convertProviderData } }), Object.defineProperty(t, "listProviders", { enumerable: !0, get: function () { return Ce.listProviders } }), Object.defineProperty(t, "objectToRoute", { enumerable: !0, get: function () { return Se.objectToRoute } }); var n = Le; Object.defineProperty(t, "getCollectionTitle", { enumerable: !0, get: function () { return n.getCollectionTitle } }), Object.defineProperty(t, "customisedConfig", { enumerable: !0, get: function () { return ke.customisedConfig } }), Object.defineProperty(t, "mergeConfig", { enumerable: !0, get: function () { return ke.mergeConfig } }), Object.defineProperty(t, "setComponentsConfig", { enumerable: !0, get: function () { return ke.setComponentsConfig } }), Object.defineProperty(t, "iconToString", { enumerable: !0, get: function () { return Ge.iconToString } }), Object.defineProperty(t, "validateIcon", { enumerable: !0, get: function () { return Ge.validateIcon } }), Object.defineProperty(t, "compareIcons", { enumerable: !0, get: function () { return Ge.compareIcons } }), Object.defineProperty(t, "stringToIcon", { enumerable: !0, get: function () { return Ge.stringToIcon } }), Object.defineProperty(t, "compareObjects", { enumerable: !0, get: function () { return be.compareObjects } }), Object.defineProperty(t, "cloneObject", { enumerable: !0, get: function () { return be.cloneObject } }); t.IconFinderCore = class { constructor(e) { this.params = e; const t = this.registry = new Ze.Registry(e); this.id = t.id, t.setCustom("core", this, !0), e.iconSets && (t.customIconSets = Be.convertCustomSets(e.iconSets)); const n = this.router = t.router, i = t.events; i.subscribe("render", this._routerEvent.bind(this)), "object" == typeof e.custom && null !== e.custom && Object.keys(e.custom).forEach((e => { i.subscribe("load-" + e, this._loadCustomIconsEvent.bind(this, e)) })), setTimeout((() => { null === n.fullRoute && (void 0 !== e.route ? n.partialRoute = e.route : n.home()) })) } getCollection(e, t) { return Le.getCollectionInfo(this.registry.collections, e, t) } _routerEvent(e) { this.params.callback(e, this) } _loadCustomIconsEvent(e, t) { void 0 !== this.params.custom && this.params.custom[e](t) } destroy() { this.registry.destroy() } }, t.getCoreInstance = function (e) { const t = Pe.getRegistry(e); return t ? t.getCustom("core", !0) : void 0 } })), nt = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeCustomisations = t.defaults = void 0, t.defaults = Object.freeze({ inline: !1, width: null, height: null, hAlign: "center", vAlign: "middle", slice: !1, hFlip: !1, vFlip: !1, rotate: 0 }), t.mergeCustomisations = function (e, t) { const n = {}; for (const i in e) { const o = i; if (n[o] = e[o], void 0 === t[o]) continue; const r = t[o]; switch (o) { case "inline": case "slice": "boolean" == typeof r && (n[o] = r); break; case "hFlip": case "vFlip": !0 === r && (n[o] = !n[o]); break; case "hAlign": case "vAlign": "string" == typeof r && "" !== r && (n[o] = r); break; case "width": case "height": ("string" == typeof r && "" !== r || "number" == typeof r && r || null === r) && (n[o] = r); break; case "rotate": "number" == typeof r && (n[o] += r) } } return n } })), it = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.filterCustomisations = t.mergeCustomisations = t.defaultCustomisations = t.emptyCustomisations = void 0; const n = { color: "" }; t.emptyCustomisations = { ...nt.defaults, ...n }, t.defaultCustomisations = { ...t.emptyCustomisations }, t.mergeCustomisations = function (e, t) { const i = nt.mergeCustomisations(e, t); for (const o in n) { const n = o; i[n] = t && typeof t[n] == typeof e[n] ? t[n] : e[n] } return i }, t.filterCustomisations = function (e) { const n = {}; for (const i in t.defaultCustomisations) { const o = i; e[o] !== t.defaultCustomisations[o] && e[o] !== t.emptyCustomisations[o] && (n[o] = e[o]) } return n } })); function ot(e, t) { void 0 === e[t.provider] && (e[t.provider] = Object.create(null)); const n = e[t.provider]; void 0 === n[t.prefix] && (n[t.prefix] = []); const i = n[t.prefix]; return -1 === i.indexOf(t.name) && (i.push(t.name), !0) } function rt(e, t) { if (void 0 === e[t.provider]) return !1; const n = e[t.provider]; if (void 0 === n[t.prefix]) return !1; const i = n[t.prefix]; if (-1 !== i.indexOf(t.name)) return !0; if (t.aliases) for (let e = 0; e < t.aliases.length; e++)if (-1 !== i.indexOf(t.aliases[e])) return !0; return !1 } function st(e) { const t = []; return Object.keys(e).forEach((n => { Object.keys(e[n]).forEach((i => { e[n][i].forEach((e => { t.push({ provider: n, prefix: i, name: e }) })) })) })), t } const ct = []; const lt = "icon-finder-theme"; const at = { reset: "line-md:close", search: "line-md:search", down: "line-md:chevron-down", left: "line-md:chevron-left", right: "line-md:chevron-right", parent: "line-md:chevron-small-left", expand: "line-md:chevron-small-right", grid: "line-md:grid-3-solid", list: "line-md:list-3-solid", "check-list": "line-md:check-list-3-solid", "check-list-checked": "line-md:check-list-3-twotone", "error-loading": "icon-finder-theme:error-loading", "icon-width": "line-md:double-arrow-horizontal", "icon-height": "line-md:double-arrow-vertical", color: "line-md:paint-drop-half-twotone", "color-filled": "line-md:paint-drop-filled", rotate0: "line-md:close", rotate1: "line-md:rotate-90", rotate2: "line-md:rotate-180", rotate3: "line-md:rotate-270", "h-flip": "line-md:double-arrow-horizontal", "v-flip": "line-md:double-arrow-vertical", plus: "line-md:plus", link: "line-md:external-link", clipboard: "line-md:clipboard-arrow-twotone", confirm: "line-md:confirm", docs: "line-md:document-list-twotone", "mode-block": "line-md:valign-baseline", "mode-inline": "line-md:valign-middle", "selecting-selected": "line-md:confirm", "selecting-unselected": "icon-finder-theme:empty" }; function ut() { } function ft(e, t) { for (const n in t) e[n] = t[n]; return e } function dt(e) { return e() } function pt() { return Object.create(null) } function ht(e) { e.forEach(dt) } function gt(e) { return "function" == typeof e } function mt(e, t) { return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e } function yt(e, t, n, i) { if (e) { const o = $t(e, t, n, i); return e[0](o) } } function $t(e, t, n, i) { return e[1] && i ? ft(n.ctx.slice(), e[1](i(t))) : n.ctx } function vt(e, t, n, i, o, r, s) { const c = function (e, t, n, i) { if (e[2] && i) { const o = e[2](i(n)); if (void 0 === t.dirty) return o; if ("object" == typeof o) { const e = [], n = Math.max(t.dirty.length, o.length); for (let i = 0; i < n; i += 1)e[i] = t.dirty[i] | o[i]; return e } return t.dirty | o } return t.dirty }(t, i, o, r); if (c) { const o = $t(t, n, i, s); e.p(o, c) } } function bt(e, t) { e.appendChild(t) } function kt(e, t, n) { e.insertBefore(t, n || null) } function _t(e) { e.parentNode.removeChild(e) } function wt(e, t) { for (let n = 0; n < e.length; n += 1)e[n] && e[n].d(t) } function xt(e) { return document.createElement(e) } function Ct(e) { return document.createTextNode(e) } function jt() { return Ct(" ") } function It() { return Ct("") } function Pt(e, t, n, i) { return e.addEventListener(t, n, i), () => e.removeEventListener(t, n, i) } function Ot(e) { return function (t) { return t.preventDefault(), e.call(this, t) } } function St(e, t, n) { null == n ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n) } function Et(e, t) { t = "" + t, e.wholeText !== t && (e.data = t) } function Mt(e, t) { e.value = null == t ? "" : t } class Tt { constructor(e = null) { this.a = e, this.e = this.n = null } m(e, t, n = null) { this.e || (this.e = xt(t.nodeName), this.t = t, this.h(e)), this.i(n) } h(e) { this.e.innerHTML = e, this.n = Array.from(this.e.childNodes) } i(e) { for (let t = 0; t < this.n.length; t += 1)kt(this.t, this.n[t], e) } p(e) { this.d(), this.h(e), this.i(this.a) } d() { this.n.forEach(_t) } } let At; function Rt(e) { At = e } function Ft() { if (!At) throw new Error("Function called outside component initialization"); return At } function Lt(e) { Ft().$$.on_mount.push(e) } function Nt(e) { Ft().$$.on_destroy.push(e) } function Bt(e) { return Ft().$$.context.get(e) } const Vt = [], Dt = [], zt = [], qt = [], Ut = Promise.resolve(); let Ht = !1; function Kt(e) { zt.push(e) } function Gt(e) { qt.push(e) } let Jt = !1; const Wt = new Set; function Qt() { if (!Jt) { Jt = !0; do { for (let e = 0; e < Vt.length; e += 1) { const t = Vt[e]; Rt(t), Yt(t.$$) } for (Rt(null), Vt.length = 0; Dt.length;)Dt.pop()(); for (let e = 0; e < zt.length; e += 1) { const t = zt[e]; Wt.has(t) || (Wt.add(t), t()) } zt.length = 0 } while (Vt.length); for (; qt.length;)qt.pop()(); Ht = !1, Jt = !1, Wt.clear() } } function Yt(e) { if (null !== e.fragment) { e.update(), ht(e.before_update); const t = e.dirty; e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Kt) } } const Xt = new Set; let Zt; function en() { Zt = { r: 0, c: [], p: Zt } } function tn() { Zt.r || ht(Zt.c), Zt = Zt.p } function nn(e, t) { e && e.i && (Xt.delete(e), e.i(t)) } function on(e, t, n, i) { if (e && e.o) { if (Xt.has(e)) return; Xt.add(e), Zt.c.push((() => { Xt.delete(e), i && (n && e.d(1), i()) })), e.o(t) } } function rn(e, t) { e.d(1), t.delete(e.key) } function sn(e, t) { on(e, 1, 1, (() => { t.delete(e.key) })) } function cn(e, t, n, i, o, r, s, c, l, a, u, f) { let d = e.length, p = r.length, h = d; const g = {}; for (; h--;)g[e[h].key] = h; const m = [], y = new Map, $ = new Map; for (h = p; h--;) { const e = f(o, r, h), c = n(e); let l = s.get(c); l ? i && l.p(e, t) : (l = a(c, e), l.c()), y.set(c, m[h] = l), c in g && $.set(c, Math.abs(h - g[c])) } const v = new Set, b = new Set; function k(e) { nn(e, 1), e.m(c, u), s.set(e.key, e), u = e.first, p-- } for (; d && p;) { const t = m[p - 1], n = e[d - 1], i = t.key, o = n.key; t === n ? (u = t.first, d--, p--) : y.has(o) ? !s.has(i) || v.has(i) ? k(t) : b.has(o) ? d-- : $.get(i) > $.get(o) ? (b.add(i), k(t)) : (v.add(o), d--) : (l(n, s), d--) } for (; d--;) { const t = e[d]; y.has(t.key) || l(t, s) } for (; p;)k(m[p - 1]); return m } function ln(e, t) { const n = {}, i = {}, o = { $$scope: 1 }; let r = e.length; for (; r--;) { const s = e[r], c = t[r]; if (c) { for (const e in s) e in c || (i[e] = 1); for (const e in c) o[e] || (n[e] = c[e], o[e] = 1); e[r] = c } else for (const e in s) o[e] = 1 } for (const e in i) e in n || (n[e] = void 0); return n } function an(e) { return "object" == typeof e && null !== e ? e : {} } function un(e, t, n) { const i = e.$$.props[t]; void 0 !== i && (e.$$.bound[i] = n, n(e.$$.ctx[i])) } function fn(e) { e && e.c() } function dn(e, t, n, i) { const { fragment: o, on_mount: r, on_destroy: s, after_update: c } = e.$$; o && o.m(t, n), i || Kt((() => { const t = r.map(dt).filter(gt); s ? s.push(...t) : ht(t), e.$$.on_mount = [] })), c.forEach(Kt) } function pn(e, t) { const n = e.$$; null !== n.fragment && (ht(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []) } function hn(e, t) { -1 === e.$$.dirty[0] && (Vt.push(e), Ht || (Ht = !0, Ut.then(Qt)), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31 } function gn(e, t, n, i, o, r, s = [-1]) { const c = At; Rt(e); const l = e.$$ = { fragment: null, ctx: null, props: r, update: ut, not_equal: o, bound: pt(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(c ? c.$$.context : t.context || []), callbacks: pt(), dirty: s, skip_bound: !1 }; let a = !1; if (l.ctx = n ? n(e, t.props || {}, ((t, n, ...i) => { const r = i.length ? i[0] : n; return l.ctx && o(l.ctx[t], l.ctx[t] = r) && (!l.skip_bound && l.bound[t] && l.bound[t](r), a && hn(e, t)), n })) : [], l.update(), a = !0, ht(l.before_update), l.fragment = !!i && i(l.ctx), t.target) { if (t.hydrate) { const e = function (e) { return Array.from(e.childNodes) }(t.target); l.fragment && l.fragment.l(e), e.forEach(_t) } else l.fragment && l.fragment.c(); t.intro && nn(e.$$.fragment), dn(e, t.target, t.anchor, t.customElement), Qt() } Rt(c) } class mn { $destroy() { pn(this, 1), this.$destroy = ut } $on(e, t) { const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []); return n.push(t), () => { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } $set(e) { var t; this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1) } } function yn(e) { let t, n; const i = e[1].default, o = yt(i, e, e[0], null); return { c() { t = xt("div"), o && o.c(), St(t, "class", "iif-wrapper") }, m(e, i) { kt(e, t, i), o && o.m(t, null), n = !0 }, p(e, [t]) { o && o.p && (!n || 1 & t) && vt(o, i, e, e[0], t, null, null) }, i(e) { n || (nn(o, e), n = !0) }, o(e) { on(o, e), n = !1 }, d(e) { e && _t(t), o && o.d(e) } } } function $n(e, t, n) { let { $$slots: i = {}, $$scope: o } = t; return e.$$set = e => { "$$scope" in e && n(0, o = e.$$scope) }, [o, i] } class vn extends mn { constructor(e) { super(), gn(this, e, $n, yn, mt, {}) } } const bn = "#000", kn = 200, _n = 300, wn = { submit: { type: "primary", display: "icons" }, cancel: { type: "secondary" } }, xn = { lang: "English", search: { placeholder: { collection: "Search {name}", collections: "Lọc bộ sưu tập" }, defaultPlaceholder: "Tìm kiếm toàn bộ icon", button: "Tìm kiếm icons" }, errors: { noCollections: "No matching icon sets found.", noIconsFound: "No icons found.", defaultError: "Error loading Iconify Icon Finder.", custom: { loading: "Loading...", timeout: "Could not connect to Iconify API.", invalid_data: "Invalid response from Iconify API.", empty: "Nothing to show.", not_found: "Collection {prefix} does not exist.", bad_route: "Invalid route.", home: "Click here to return to main page." } }, icons: { header: { full: "Displaying {count} icons:", more: "Displaying {count} icons (click second page to load more results):", modes: { list: "Display icons as list", grid: "Display icons as grid" }, select: "Select multiple icons" }, headerWithCount: { 0: "No icons to display.", 1: "Displaying 1 icon:" }, tooltip: { size: "\nSize: {size}", colorless: "", colorful: "\nHas palette", char: "\nIcon font character: {char}", length: "" }, more: "Find more icons", moreAsNumber: !1 }, pagination: { prev: "Previous page", next: "Next page" }, filters: { uncategorised: "Uncategorised", collections: "Filter search results by icon set:", "collections-collections": "", tags: "Filter by category:", themePrefixes: "Icon type:", themeSuffixes: "Icon type:" }, collectionInfo: { total: "Number of icons:", height: "Height of icons:", author: "Author:", license: "License:", palette: "Palette:", colorless: "Colorless", colorful: "Has colors", link: "Show all icons" }, parent: { default: "Return to previous page", collections: "Return to collections list", collection: "Return to {name}", search: "Return to search results" }, collection: { by: "by " }, providers: { section: "Icons source:", add: "Add Provider", addForm: { title: "Enter API provider's host name:", placeholder: "https://api.iconify.design", submit: "Add API Provider", invalid: "Example of a valid API host name: https://api.iconify.design" }, status: { loading: "Checking {host}...", error: "{host} is not a valid Iconify API.", exists: "API from {host} is already available or API has wrong configuration.", unsupported: "API from {host} does not support icon search." } }, footer: { iconName: "Selected icon:", iconNamePlaceholder: "Enter icon by name...", inlineSample: { before: "Text with icon sample", after: "to show icon alignment in text." }, remove: "Remove {name}", select: "Select {name}", about: "Aboout {title}" }, footerButtons: { submit: "Submit", change: "Change", select: "Select", cancel: "Cancel", close: "Close" }, footerBlocks: { title: "Customize icon", title2: "Customize icons", color: "Color", flip: "Flip", hFlip: "Horizontal", vFlip: "Vertical", rotate: "Rotate", width: "Width", height: "Height", size: "Size", alignment: "Alignment", mode: "Mode", icons: "Selected icons" }, footerOptionButtons: { hFlip: "Horizontal", vFlip: "Vertical", rotate: "{num}" + String.fromCharCode(176), rotateTitle: "Rotate {num}" + String.fromCharCode(176), inline: "Inline", block: "Block", inlineHint: "Icon is vertically aligned slightly below baseline, like icon font, fitting perfectly in text.", blockHint: "Icon is rendered as is, without custom vertical alignment." }, codeSamples: { copy: "Copy to clipboard", copied: "Copied to clipboard.", heading: 'How to use "{name}" icon', childTabTitle: "{key} versions:", childTabTitles: { react: "React component versions:", svg: "SVG options:" }, docsDefault: "Click here for more information about {title} component.", docs: { iconify: "Click here for more information about Iconify SVG framework." }, intro: { "svg-box": "This SVG contains extra empty rectangle that matches viewBox. It is needed to keep icon dimensions when importing icon in software that ignores viewBox attribute.", "svg-uri": "You can use this as background image or as content for pseudo element in stylesheet." }, component: { install: "Install component and icon set:", install1: "Install component:", import: "Import component and icon data:", import1: "Import component:", vue: "Add icon data and icon component to your component:", use: "Use it in your code:" }, iconify: { intro1: 'Iconify SVG framework makes using icons as easy as icon fonts. To use "{name}" in HTML, add this code to the document:', intro2: "Iconify SVG framework will load icon data from Iconify API and replace that placeholder with SVG.", head: "Make sure you import Iconify SVG framework:" } } }; function Cn(e) { let t; const n = e[6].default, i = yt(n, e, e[5], null); return { c() { i && i.c() }, m(e, n) { i && i.m(e, n), t = !0 }, p(e, o) { i && i.p && (!t || 32 & o) && vt(i, n, e, e[5], o, null, null) }, i(e) { t || (nn(i, e), t = !0) }, o(e) { on(i, e), t = !1 }, d(e) { i && i.d(e) } } } function jn(e) { let t, n, i; t = new $e({ props: { icon: e[1], class: "iconify--line-md", onLoad: e[2] } }); let o = !e[0] && In(e); return { c() { fn(t.$$.fragment), o && o.c(), n = It() }, m(e, r) { dn(t, e, r), o && o.m(e, r), kt(e, n, r), i = !0 }, p(e, i) { const r = {}; 2 & i && (r.icon = e[1]), t.$set(r), e[0] ? o && (en(), on(o, 1, 1, (() => { o = null })), tn()) : o ? (o.p(e, i), 1 & i && nn(o, 1)) : (o = In(e), o.c(), nn(o, 1), o.m(n.parentNode, n)) }, i(e) { i || (nn(t.$$.fragment, e), nn(o), i = !0) }, o(e) { on(t.$$.fragment, e), on(o), i = !1 }, d(e) { pn(t, e), o && o.d(e), e && _t(n) } } } function In(e) { let t; const n = e[6].default, i = yt(n, e, e[5], null); return { c() { i && i.c() }, m(e, n) { i && i.m(e, n), t = !0 }, p(e, o) { i && i.p && (!t || 32 & o) && vt(i, n, e, e[5], o, null, null) }, i(e) { t || (nn(i, e), t = !0) }, o(e) { on(i, e), t = !1 }, d(e) { i && i.d(e) } } } function Pn(e) { let t, n, i, o; const r = [jn, Cn], s = []; function c(e, t) { return null !== e[1] ? 0 : 1 } return t = c(e), n = s[t] = r[t](e), { c() { n.c(), i = It() }, m(e, n) { s[t].m(e, n), kt(e, i, n), o = !0 }, p(e, [o]) { let l = t; t = c(e), t === l ? s[t].p(e, o) : (en(), on(s[l], 1, 1, (() => { s[l] = null })), tn(), n = s[t], n ? n.p(e, o) : (n = s[t] = r[t](e), n.c()), nn(n, 1), n.m(i.parentNode, i)) }, i(e) { o || (nn(n), o = !0) }, o(e) { on(n), o = !1 }, d(e) { s[t].d(e), e && _t(i) } } } let On = !0; function Sn(e, t, n) { let i, { $$slots: o = {}, $$scope: r } = t, { icon: s } = t, { onLoad: c = null } = t, l = !1; return Lt((() => { On && (On = !1, ue(Object.values(at).filter((e => !!e)))) })), e.$$set = e => { "icon" in e && n(3, s = e.icon), "onLoad" in e && n(4, c = e.onLoad), "$$scope" in e && n(5, r = e.$$scope) }, e.$$.update = () => { 8 & e.$$.dirty && n(1, i = "string" == typeof at[s] ? at[s] : -1 === s.indexOf(":") ? null : s) }, [l, i, function () { n(0, l = !0), c && c() }, s, c, r, o] } class En extends mn { constructor(e) { super(), gn(this, e, Sn, Pn, mt, { icon: 3, onLoad: 4 }) } } function Mn(e) { let t, n, i; return n = new En({ props: { icon: e[4], onLoad: e[10] } }), { c() { t = xt("div"), fn(n.$$.fragment), St(t, "class", "iif-input-icon"), St(t, "style", e[7]) }, m(e, o) { kt(e, t, o), dn(n, t, null), i = !0 }, p(e, o) { const r = {}; 16 & o && (r.icon = e[4]), n.$set(r), (!i || 128 & o) && St(t, "style", e[7]) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n) } } } function Tn(e) { let t, n; return { c() { t = xt("div"), n = Ct(e[1]), St(t, "class", "iif-input-placeholder") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 2 & t && Et(n, e[1]) }, d(e) { e && _t(t) } } } function An(e) { let t, n, i, o, r; return n = new En({ props: { icon: "reset", $$slots: { default: [Rn] }, $$scope: { ctx: e } } }), { c() { t = xt("a"), fn(n.$$.fragment), St(t, "class", "iif-input-reset"), St(t, "href", "# ") }, m(s, c) { kt(s, t, c), dn(n, t, null), i = !0, o || (r = Pt(t, "click", Ot(e[11])), o = !0) }, p(e, t) { const i = {}; 4194304 & t && (i.$$scope = { dirty: t, ctx: e }), n.$set(i) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n), o = !1, r() } } } function Rn(e) { let t; return { c() { t = Ct("x") }, m(e, n) { kt(e, t, n) }, d(e) { e && _t(t) } } } function Fn(e) { let t, n, i, o, r, s, c, l, a, u, f = e[9] && "" !== e[4] && Mn(e), d = e[9] && "" === e[0] && "" !== e[1] && Tn(e), p = e[9] && "" !== e[0] && An(e); return { c() { t = xt("div"), n = xt("div"), f && f.c(), i = jt(), o = xt("input"), s = jt(), d && d.c(), c = jt(), p && p.c(), St(o, "type", "text"), St(o, "title", r = e[2] ? e[2] : e[1]), St(o, "spellcheck", !1), St(o, "autocomplete", "off"), St(o, "autocorrect", "off"), St(o, "autocapitalize", "off"), o.disabled = e[3], St(n, "class", e[6]), St(t, "class", e[5]) }, m(r, h) { kt(r, t, h), bt(t, n), f && f.m(n, null), bt(n, i), bt(n, o), Mt(o, e[0]), e[21](o), bt(n, s), d && d.m(n, null), bt(n, c), p && p.m(n, null), l = !0, a || (u = [Pt(o, "input", e[20]), Pt(o, "input", e[12]), Pt(o, "blur", e[13])], a = !0) }, p(e, [s]) { e[9] && "" !== e[4] ? f ? (f.p(e, s), 528 & s && nn(f, 1)) : (f = Mn(e), f.c(), nn(f, 1), f.m(n, i)) : f && (en(), on(f, 1, 1, (() => { f = null })), tn()), (!l || 6 & s && r !== (r = e[2] ? e[2] : e[1])) && St(o, "title", r), (!l || 8 & s) && (o.disabled = e[3]), 1 & s && o.value !== e[0] && Mt(o, e[0]), e[9] && "" === e[0] && "" !== e[1] ? d ? d.p(e, s) : (d = Tn(e), d.c(), d.m(n, c)) : d && (d.d(1), d = null), e[9] && "" !== e[0] ? p ? (p.p(e, s), 513 & s && nn(p, 1)) : (p = An(e), p.c(), nn(p, 1), p.m(n, null)) : p && (en(), on(p, 1, 1, (() => { p = null })), tn()), (!l || 64 & s) && St(n, "class", e[6]), (!l || 32 & s) && St(t, "class", e[5]) }, i(e) { l || (nn(f), nn(p), l = !0) }, o(e) { on(f), on(p), l = !1 }, d(n) { n && _t(t), f && f.d(), e[21](null), d && d.d(), p && p.d(), a = !1, ht(u) } } } function Ln(e, t, n) { let i, o, r, s, { placeholder: c = "" } = t, { title: l = "" } = t, { value: a = "" } = t, { disabled: u = !1 } = t, { icon: f = "" } = t, { type: d = "" } = t, { extra: p = "" } = t, { onInput: h = null } = t, { onBlur: g = null } = t, { autofocus: m = !1 } = t, y = !1; function $() { h && h(a) } let v = !1; return Lt((() => { n(9, v = !0), m && s.focus() })), e.$$set = e => { "placeholder" in e && n(1, c = e.placeholder), "title" in e && n(2, l = e.title), "value" in e && n(0, a = e.value), "disabled" in e && n(3, u = e.disabled), "icon" in e && n(4, f = e.icon), "type" in e && n(14, d = e.type), "extra" in e && n(15, p = e.extra), "onInput" in e && n(16, h = e.onInput), "onBlur" in e && n(17, g = e.onBlur), "autofocus" in e && n(18, m = e.autofocus) }, e.$$.update = () => { 41 & e.$$.dirty && (n(5, i = "iif-input-wrapper"), n(5, i += " " + i + ("" === a ? "--empty" : "--has-content") + (u ? " " + i + "--disabled" : ""))), 540682 & e.$$.dirty && n(6, o = "iif-input iif-input--with" + ("" === c ? "out" : "") + "-placeholder" + (y ? " iif-input--with-icon" : "") + ("" !== d ? " iif-input--" + d : "") + (u ? " iif-input--disabled" : "")), 49152 & e.$$.dirty && (n(7, r = ""), "color" === d && "" !== p && n(7, r = "opacity: 1; color: " + p)) }, [a, c, l, u, f, i, o, r, s, v, function () { n(19, y = !0) }, function () { n(0, a = ""), $() }, $, function () { g && g(a) }, d, p, h, g, m, y, function () { a = this.value, n(0, a) }, function (e) { Dt[e ? "unshift" : "push"]((() => { s = e, n(8, s) })) }] } class Nn extends mn { constructor(e) { super(), gn(this, e, Ln, Fn, mt, { placeholder: 1, title: 2, value: 0, disabled: 3, icon: 4, type: 14, extra: 15, onInput: 16, onBlur: 17, autofocus: 18 }) } } function Bn(e) { let t, n; const i = e[5].default, o = yt(i, e, e[4], null); return { c() { t = xt("div"), o && o.c(), St(t, "class", e[0]) }, m(e, i) { kt(e, t, i), o && o.m(t, null), n = !0 }, p(e, [r]) { o && o.p && (!n || 16 & r) && vt(o, i, e, e[4], r, null, null), (!n || 1 & r) && St(t, "class", e[0]) }, i(e) { n || (nn(o, e), n = !0) }, o(e) { on(o, e), n = !1 }, d(e) { e && _t(t), o && o.d(e) } } } const Vn = "iif-block"; function Dn(e, t, n) { let i, { $$slots: o = {}, $$scope: r } = t, { type: s = "" } = t, { name: c = "" } = t, { extra: l = "" } = t; return e.$$set = e => { "type" in e && n(1, s = e.type), "name" in e && n(2, c = e.name), "extra" in e && n(3, l = e.extra), "$$scope" in e && n(4, r = e.$$scope) }, e.$$.update = () => { if (15 & e.$$.dirty) { if (n(0, i = Vn), "" !== s) { let e = " iif-block--" + s; n(0, i += e), "" !== c && n(0, i += e + "--" + c) } "" !== l && n(0, i += " iif-block--" + l) } }, [i, s, c, l, r, o] } class zn extends mn { constructor(e) { super(), gn(this, e, Dn, Bn, mt, { type: 1, name: 2, extra: 3 }) } } function qn(e, t, n) { const i = e.slice(); return i[10] = t[n], i[12] = n, i } function Un(e, t) { let n, i, o, r; function s(e) { t[6](e) } let c = { type: "text", placeholder: t[2].defaultPlaceholder, icon: "search", autofocus: t[10] }; return void 0 !== t[0] && (c.value = t[0]), i = new Nn({ props: c }), Dt.push((() => un(i, "value", s))), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), r = !0 }, p(e, n) { t = e; const r = {}; 2 & n && (r.autofocus = t[10]), !o && 1 & n && (o = !0, r.value = t[0], Gt((() => o = !1))), i.$set(r) }, i(e) { r || (nn(i.$$.fragment, e), r = !0) }, o(e) { on(i.$$.fragment, e), r = !1 }, d(e) { e && _t(n), pn(i, e) } } } function Hn(e) { let t, n, i, o, r, s, c = [], l = new Map, a = [e[1]]; const u = e => e[10]; for (let t = 0; t < 1; t += 1) { let n = qn(e, a, t), i = u(n); l.set(i, c[t] = Un(i, n)) } return { c() { t = xt("form"); for (let e = 0; e < 1; e += 1)c[e].c(); n = jt(), i = xt("button"), i.textContent = `${e[2].button}`, St(i, "class", "iif-form-button iif-form-button--primary"), St(i, "type", "submit"), St(t, "class", "iif-block--search-form") }, m(l, a) { kt(l, t, a); for (let e = 0; e < 1; e += 1)c[e].m(t, null); bt(t, n), bt(t, i), o = !0, r || (s = Pt(t, "submit", Ot(e[3])), r = !0) }, p(e, i) { 7 & i && (a = [e[1]], en(), c = cn(c, i, u, 1, e, a, l, t, sn, Un, n, qn), tn()) }, i(e) { if (!o) { for (let e = 0; e < 1; e += 1)nn(c[e]); o = !0 } }, o(e) { for (let e = 0; e < 1; e += 1)on(c[e]); o = !1 }, d(e) { e && _t(t); for (let e = 0; e < 1; e += 1)c[e].d(); r = !1, s() } } } function Kn(e) { let t, n; return t = new zn({ props: { type: "search", name: "global", $$slots: { default: [Hn] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 8195 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Gn(e, t, n) { let { viewChanged: i } = t, { route: o } = t; const r = Bt("registry"), s = xn.search; let c, l = ""; function a(e) { return !(!e || "search" !== e.type || !e.params || "" !== l && l === e.params.search) && (n(0, c = e.params.search), l = c, !0) } return e.$$set = e => { "viewChanged" in e && n(4, i = e.viewChanged), "route" in e && n(5, o = e.route) }, e.$$.update = () => { 49 & e.$$.dirty && (null === c ? (n(0, c = ""), null !== o && !a(o) && o.parent && a(o.parent)) : i ? a(o) : l = ""), e.$$.dirty }, [c, !1, s, function () { if ("string" == typeof c) { const e = c.trim().toLowerCase(); "" !== e && (l = e, r.router.action("search", e)) } }, i, o, function (e) { c = e, n(0, c), n(5, o), n(4, i) }] } class Jn extends mn { constructor(e) { super(), gn(this, e, Gn, Kn, mt, { viewChanged: 4, route: 5 }) } } function Wn(e) { let t, n, i, o, r, s, c, l; return n = new En({ props: { icon: "parent" } }), { c() { t = xt("div"), fn(n.$$.fragment), i = jt(), o = xt("a"), r = Ct(e[0]), St(o, "href", "# "), St(t, "class", "iif-parent-link") }, m(a, u) { kt(a, t, u), dn(n, t, null), bt(t, i), bt(t, o), bt(o, r), s = !0, c || (l = Pt(o, "click", Ot((function () { gt(e[1]) && e[1].apply(this, arguments) }))), c = !0) }, p(t, [n]) { e = t, (!s || 1 & n) && Et(r, e[0]) }, i(e) { s || (nn(n.$$.fragment, e), s = !0) }, o(e) { on(n.$$.fragment, e), s = !1 }, d(e) { e && _t(t), pn(n), c = !1, l() } } } function Qn(e, t, n) { let { text: i } = t, { onClick: o } = t; return e.$$set = e => { "text" in e && n(0, i = e.text), "onClick" in e && n(1, o = e.onClick) }, [i, o] } class Yn extends mn { constructor(e) { super(), gn(this, e, Qn, Wn, mt, { text: 0, onClick: 1 }) } } function Xn(e, t, n) { const i = e.slice(); return i[7] = t[n], i[9] = n, i } function Zn(e) { let t, n; return t = new zn({ props: { type: "parent", $$slots: { default: [ti] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1025 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ei(e, t) { let n, i, o; function r() { return t[3](t[7]) } return i = new Yn({ props: { text: t[7].text, onClick: r } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 1 & n && (o.text = t[7].text), 1 & n && (o.onClick = r), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function ti(e) { let t, n, i = [], o = new Map, r = e[0]; const s = e => e[7].key; for (let t = 0; t < r.length; t += 1) { let n = Xn(e, r, t), c = s(n); o.set(c, i[t] = ei(c, n)) } return { c() { for (let e = 0; e < i.length; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < i.length; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, n) { 3 & n && (r = e[0], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, ei, t, Xn), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < i.length; t += 1)i[t].d(e); e && _t(t) } } } function ni(e) { let t, n, i = e[0].length > 0 && Zn(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { e[0].length > 0 ? i ? (i.p(e, n), 1 & n && nn(i, 1)) : (i = Zn(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function ii(e, t, n) { let { route: i } = t; const o = Bt("registry"), r = xn.parent, s = o.collections; function c(e) { o.router.action("parent", e) } let l; return e.$$set = e => { "route" in e && n(2, i = e.route) }, e.$$.update = () => { if (5 & e.$$.dirty) { n(0, l = []), i.parent && function e(t, n) { const i = t.params; let o = r.default; "custom" === t.type && void 0 !== r[t.params.customType] ? o = r[i.customType] : void 0 !== r[t.type] && (o = r[t.type], "collection" === t.type && (o = o.replace("{name}", tt.getCollectionTitle(s, i.provider, i.prefix)))); let c = t.type + "-" + n + "-"; switch (t.type) { case "collection": c += i.provider + ":" + i.prefix; break; case "custom": c += i.customType }l.unshift({ key: c, level: n, route: t, text: o }), t.parent && e(t.parent, n + 1) }(i.parent, 1) } }, [l, c, i, e => c(e.level)] } class oi extends mn { constructor(e) { super(), gn(this, e, ii, ni, mt, { route: 2 }) } } function ri(e, t, n) { const i = e.slice(); return i[4] = t[n], i[6] = n, i } function si(e, t, n) { const i = e.slice(); return i[7] = t[n], i[9] = n, i } function ci(e) { let t, n, i, o, r = [], s = new Map, c = e[4].items; const l = e => e[7].key; for (let t = 0; t < c.length; t += 1) { let n = si(e, c, t), i = l(n); s.set(i, r[t] = ui(i, n)) } return { c() { t = xt("div"); for (let e = 0; e < r.length; e += 1)r[e].c(); n = jt(), St(t, "class", i = pi + "-" + e[4].side) }, m(e, i) { kt(e, t, i); for (let e = 0; e < r.length; e += 1)r[e].m(t, null); bt(t, n), o = !0 }, p(e, a) { 1 & a && (c = e[4].items, en(), r = cn(r, a, l, 1, e, c, s, t, sn, ui, n, si), tn()), (!o || 1 & a && i !== (i = pi + "-" + e[4].side)) && St(t, "class", i) }, i(e) { if (!o) { for (let e = 0; e < c.length; e += 1)nn(r[e]); o = !0 } }, o(e) { for (let e = 0; e < r.length; e += 1)on(r[e]); o = !1 }, d(e) { e && _t(t); for (let e = 0; e < r.length; e += 1)r[e].d() } } } function li(e) { let t, n; return t = new En({ props: { icon: e[7].icon } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icon = e[7].icon), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ai(e) { let t, n = e[7].title + ""; return { c() { t = Ct(n) }, m(e, n) { kt(e, t, n) }, p(e, i) { 1 & i && n !== (n = e[7].title + "") && Et(t, n) }, d(e) { e && _t(t) } } } function ui(e, t) { let n, i, o, r, s, c, l, a, u = t[7].icon && li(t), f = "" !== t[7].title && ai(t); return { key: e, first: null, c() { n = xt("a"), u && u.c(), i = jt(), f && f.c(), St(n, "href", o = t[7].href), St(n, "class", r = t[7].className), St(n, "title", s = t[7].hint), this.first = n }, m(e, o) { kt(e, n, o), u && u.m(n, null), bt(n, i), f && f.m(n, null), c = !0, l || (a = Pt(n, "click", Ot((function () { gt(t[7].onClick) && t[7].onClick.apply(this, arguments) }))), l = !0) }, p(e, l) { (t = e)[7].icon ? u ? (u.p(t, l), 1 & l && nn(u, 1)) : (u = li(t), u.c(), nn(u, 1), u.m(n, i)) : u && (en(), on(u, 1, 1, (() => { u = null })), tn()), "" !== t[7].title ? f ? f.p(t, l) : (f = ai(t), f.c(), f.m(n, null)) : f && (f.d(1), f = null), (!c || 1 & l && o !== (o = t[7].href)) && St(n, "href", o), (!c || 1 & l && r !== (r = t[7].className)) && St(n, "class", r), (!c || 1 & l && s !== (s = t[7].hint)) && St(n, "title", s) }, i(e) { c || (nn(u), c = !0) }, o(e) { on(u), c = !1 }, d(e) { e && _t(n), u && u.d(), f && f.d(), l = !1, a() } } } function fi(e, t) { let n, i, o, r = !t[4].empty && ci(t); return { key: e, first: null, c() { n = It(), r && r.c(), i = It(), this.first = n }, m(e, t) { kt(e, n, t), r && r.m(e, t), kt(e, i, t), o = !0 }, p(e, n) { (t = e)[4].empty ? r && (en(), on(r, 1, 1, (() => { r = null })), tn()) : r ? (r.p(t, n), 1 & n && nn(r, 1)) : (r = ci(t), r.c(), nn(r, 1), r.m(i.parentNode, i)) }, i(e) { o || (nn(r), o = !0) }, o(e) { on(r), o = !1 }, d(e) { e && _t(n), r && r.d(e), e && _t(i) } } } function di(e) { let t, n, i = [], o = new Map, r = e[0]; const s = e => e[4].side; for (let t = 0; t < r.length; t += 1) { let n = ri(e, r, t), c = s(n); o.set(c, i[t] = fi(c, n)) } return { c() { t = xt("div"); for (let e = 0; e < i.length; e += 1)i[e].c(); St(t, "class", pi) }, m(e, o) { kt(e, t, o); for (let e = 0; e < i.length; e += 1)i[e].m(t, null); n = !0 }, p(e, [n]) { 1 & n && (r = e[0], en(), i = cn(i, n, s, 1, e, r, o, t, sn, fi, null, ri), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { e && _t(t); for (let e = 0; e < i.length; e += 1)i[e].d() } } } const pi = "iif-tabs"; function hi(e, t, n) { let { tabs: i } = t, { selected: o } = t, { onClick: r } = t, s = []; return e.$$set = e => { "tabs" in e && n(1, i = e.tabs), "selected" in e && n(2, o = e.selected), "onClick" in e && n(3, r = e.onClick) }, e.$$.update = () => { if (15 & e.$$.dirty) { const e = [], t = []; i.forEach((n => { const i = n.key, c = (void 0 === n.index ? s.length : n.index) % 11, l = "iif-tab iif-tab--" + c + (i === o ? " iif-tab--selected" : "") + (n.type ? " iif-tab--" + n.type : ""), a = { key: i, className: l, title: n.title, index: c, href: void 0 === n.href ? "# " : n.href, icon: n.icon, hint: n.hint, onClick: void 0 === n.onClick ? () => r(i) : n.onClick }; n.right ? t.push(a) : e.push(a) })), n(0, s = [{ side: "left", items: e, empty: !e.length }, { side: "right", items: t, empty: !t.length }]) } }, [s, i, o, r] } class gi extends mn { constructor(e) { super(), gn(this, e, hi, di, mt, { tabs: 1, selected: 2, onClick: 3 }) } } function mi(e) { let t, n, i = e[1].title + ""; return { c() { t = xt("div"), n = Ct(i), St(t, "class", "iif-block--add-form-title") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 2 & t && i !== (i = e[1].title + "") && Et(n, i) }, d(e) { e && _t(t) } } } function yi(e) { let t, n; return t = new En({ props: { icon: "plus" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function $i(e) { let t, n; return { c() { t = xt("div"), n = Ct(e[4]), St(t, "class", "iif-block--add-form-status") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 16 & t && Et(n, e[4]) }, d(e) { e && _t(t) } } } function vi(e) { let t, n, i = e[1].invalid + ""; return { c() { t = xt("div"), n = Ct(i), St(t, "class", "iif-block--add-form-invalid") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 2 & t && i !== (i = e[1].invalid + "") && Et(n, i) }, d(e) { e && _t(t) } } } function bi(e) { let t, n, i, o, r, s, c, l, a, u, f, d, p, h, g = e[1].submit + "", m = e[1].title && mi(e); function y(t) { e[10](t) } let $ = { type: "text", placeholder: e[1].placeholder, icon: e[3] }; void 0 !== e[0] && ($.value = e[0]), o = new Nn({ props: $ }), Dt.push((() => un(o, "value", y))); let v = e[2] && yi(), b = e[4] && $i(e), k = !e[5] && e[1].invalid && vi(e); return { c() { t = xt("div"), m && m.c(), n = jt(), i = xt("form"), fn(o.$$.fragment), s = jt(), c = xt("button"), v && v.c(), l = jt(), a = Ct(g), u = jt(), b && b.c(), f = jt(), k && k.c(), St(c, "class", e[6]), St(c, "type", "submit"), St(i, "class", "iif-block--add-form-form"), St(t, "class", "iif-block--add-form") }, m(r, g) { kt(r, t, g), m && m.m(t, null), bt(t, n), bt(t, i), dn(o, i, null), bt(i, s), bt(i, c), v && v.m(c, null), bt(c, l), bt(c, a), bt(t, u), b && b.m(t, null), bt(t, f), k && k.m(t, null), d = !0, p || (h = Pt(i, "submit", Ot(e[7])), p = !0) }, p(e, [i]) { e[1].title ? m ? m.p(e, i) : (m = mi(e), m.c(), m.m(t, n)) : m && (m.d(1), m = null); const s = {}; 2 & i && (s.placeholder = e[1].placeholder), 8 & i && (s.icon = e[3]), !r && 1 & i && (r = !0, s.value = e[0], Gt((() => r = !1))), o.$set(s), e[2] ? v ? 4 & i && nn(v, 1) : (v = yi(), v.c(), nn(v, 1), v.m(c, l)) : v && (en(), on(v, 1, 1, (() => { v = null })), tn()), (!d || 2 & i) && g !== (g = e[1].submit + "") && Et(a, g), (!d || 64 & i) && St(c, "class", e[6]), e[4] ? b ? b.p(e, i) : (b = $i(e), b.c(), b.m(t, f)) : b && (b.d(1), b = null), !e[5] && e[1].invalid ? k ? k.p(e, i) : (k = vi(e), k.c(), k.m(t, null)) : k && (k.d(1), k = null) }, i(e) { d || (nn(o.$$.fragment, e), nn(v), d = !0) }, o(e) { on(o.$$.fragment, e), on(v), d = !1 }, d(e) { e && _t(t), m && m.d(), pn(o), v && v.d(), b && b.d(), k && k.d(), p = !1, h() } } } function ki(e, t, n) { let i, o, { phrases: r } = t, { buttonIcon: s = !1 } = t, { inputIcon: c = "" } = t, { value: l } = t, { onSubmit: a } = t, { onValidate: u = null } = t, { status: f = "" } = t; return e.$$set = e => { "phrases" in e && n(1, r = e.phrases), "buttonIcon" in e && n(2, s = e.buttonIcon), "inputIcon" in e && n(3, c = e.inputIcon), "value" in e && n(0, l = e.value), "onSubmit" in e && n(8, a = e.onSubmit), "onValidate" in e && n(9, u = e.onValidate), "status" in e && n(4, f = e.status) }, e.$$.update = () => { 1 & e.$$.dirty && n(5, i = function (e) { return "function" != typeof u || u(e) }(l)), 4 & e.$$.dirty && n(6, o = "iif-form-button iif-form-button--primary" + (s ? " iif-form-button--with-icon" : "")) }, [l, r, s, c, f, i, o, function () { a(l) }, a, u, function (e) { l = e, n(0, l) }] } class _i extends mn { constructor(e) { super(), gn(this, e, ki, bi, mt, { phrases: 1, buttonIcon: 2, inputIcon: 3, value: 0, onSubmit: 8, onValidate: 9, status: 4 }) } } function wi(e) { let t = e.toLowerCase().split("/"); const n = t.shift(); switch (n) { case "http:": case "https:": break; default: return null }if ("" !== t.shift()) return null; const i = t.shift(); if ("string" != typeof i) return null; const o = i.split(":"); if (o.length > 2) return null; const r = o.shift(); if (!r || !r.match(/^[a-z0-9.-]+$/)) return null; const s = o.shift(); return void 0 === s || s.match(/^[0-9]+$/) ? n + "//" + i : null } function xi(e) { let t, n; return t = new _i({ props: { phrases: e[4].addForm, inputIcon: "link", buttonIcon: !0, value: "", onValidate: e[6], onSubmit: e[7], status: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.status = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ci(e) { let t, n, i, o; t = new gi({ props: { tabs: e[2], selected: e[0], onClick: e[5] } }); let r = e[1] && xi(e); return { c() { fn(t.$$.fragment), n = jt(), r && r.c(), i = It() }, m(e, s) { dn(t, e, s), kt(e, n, s), r && r.m(e, s), kt(e, i, s), o = !0 }, p(e, n) { const o = {}; 4 & n && (o.tabs = e[2]), 1 & n && (o.selected = e[0]), t.$set(o), e[1] ? r ? (r.p(e, n), 2 & n && nn(r, 1)) : (r = xi(e), r.c(), nn(r, 1), r.m(i.parentNode, i)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()) }, i(e) { o || (nn(t.$$.fragment, e), nn(r), o = !0) }, o(e) { on(t.$$.fragment, e), on(r), o = !1 }, d(e) { pn(t, e), e && _t(n), r && r.d(e), e && _t(i) } } } function ji(e) { let t, n; return t = new zn({ props: { type: "providers", $$slots: { default: [Ci] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 2063 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ii(e, t, n) { let { activeProvider: i } = t, { providers: o } = t; const r = Bt("registry"), s = xn.providers; let c, l = !1, a = ""; return e.$$set = e => { "activeProvider" in e && n(0, i = e.activeProvider), "providers" in e && n(8, o = e.providers) }, e.$$.update = () => { 262 & e.$$.dirty && (n(2, c = []), o.forEach(((e, t) => { const n = tt.getProvider(e); n && c.push({ key: e, title: n.title, index: t }) }))) }, [i, l, c, a, s, function (e) { n(1, l = !1), r.router.action("provider", e) }, function (e) { return "" !== a && n(3, a = ""), null !== wi(e) }, function (e) { const t = wi(e); t && (n(3, a = s.status.loading.replace("{host}", t)), function (e, t, n) { e.api.sendQuery(t, "/provider", ((e, i) => { const o = i; let r, s = "error"; switch (e) { case "success": if ("object" != typeof o) break; if ("string" != typeof o.provider) { s = "unsupported"; break } if (r = tt.convertProviderData(t, o), !r) break; const e = o.provider; if (-1 !== tt.listProviders().indexOf(e)) { s = "exists"; break } return tt.addProvider(e, r), void n(t, !0, e) }n(t, !1, s) })) }(r, t, ((e, t, i) => { if (t) n(3, a = ""), n(1, l = !1), r.router.action("provider", i); else { const t = i; n(3, a = s.status[t].replace("{host}", e)) } }))) }, o] } class Pi extends mn { constructor(e) { super(), gn(this, e, Ii, ji, mt, { activeProvider: 0, providers: 8 }) } } function Oi(e) { let t, n, i, o, r; return { c() { t = xt("button"), n = Ct(e[1]), St(t, "class", e[4]), t.disabled = i = e[0].disabled }, m(i, s) { kt(i, t, s), bt(t, n), o || (r = Pt(t, "click", Ot((function () { gt(e[2]) && e[2].apply(this, arguments) }))), o = !0) }, p(o, r) { e = o, 2 & r && Et(n, e[1]), 16 & r && St(t, "class", e[4]), 1 & r && i !== (i = e[0].disabled) && (t.disabled = i) }, d(e) { e && _t(t), o = !1, r() } } } function Si(e) { let t, n, i, o; return { c() { t = xt("a"), n = Ct(e[1]), St(t, "class", e[4]), St(t, "href", e[3]) }, m(r, s) { kt(r, t, s), bt(t, n), i || (o = Pt(t, "click", Ot((function () { gt(e[2]) && e[2].apply(this, arguments) }))), i = !0) }, p(i, o) { e = i, 2 & o && Et(n, e[1]), 16 & o && St(t, "class", e[4]), 8 & o && St(t, "href", e[3]) }, d(e) { e && _t(t), i = !1, o() } } } function Ei(e) { let t; function n(e, t) { return e[3] ? Si : Oi } let i = n(e), o = i(e); return { c() { o.c(), t = It() }, m(e, n) { o.m(e, n), kt(e, t, n) }, p(e, [r]) { i === (i = n(e)) && o ? o.p(e, r) : (o.d(1), o = i(e), o && (o.c(), o.m(t.parentNode, t))) }, i: ut, o: ut, d(e) { o.d(e), e && _t(t) } } } const Mi = "iif-filter"; function Ti(e, t, n) { let i, { active: o = !1 } = t, { hasActive: r = !1 } = t, { filter: s } = t, { title: c } = t, { onClick: l } = t, { link: a = "# " } = t; return e.$$set = e => { "active" in e && n(5, o = e.active), "hasActive" in e && n(6, r = e.hasActive), "filter" in e && n(0, s = e.filter), "title" in e && n(1, c = e.title), "onClick" in e && n(2, l = e.onClick), "link" in e && n(3, a = e.link) }, e.$$.update = () => { 97 & e.$$.dirty && n(4, i = Mi + (o ? " iif-filter--selected" : r ? " iif-filter--unselected" : "") + (s.index ? " iif-filter--" + s.index % 11 : "")) }, [s, c, l, a, i, o, r] } class Ai extends mn { constructor(e) { super(), gn(this, e, Ti, Ei, mt, { active: 5, hasActive: 6, filter: 0, title: 1, onClick: 2, link: 3 }) } } function Ri(e, t, n) { const i = e.slice(); return i[13] = t[n][0], i[14] = t[n][1], i[16] = n, i } function Fi(e) { let t, n; return t = new zn({ props: { type: "filters", name: e[0], extra: e[5], $$slots: { default: [Bi] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.name = e[0]), 32 & n && (i.extra = e[5]), 131086 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Li(e) { let t, n; return { c() { t = xt("div"), n = Ct(e[3]), St(t, "class", "iif-filters-header") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 8 & t && Et(n, e[3]) }, d(e) { e && _t(t) } } } function Ni(e, t) { let n, i, o; function r() { return t[11](t[13]) } return i = new Ai({ props: { active: t[13] === t[1].active, hasActive: null !== t[1].active, filter: t[14], link: t[2] ? t[2].replace("{prefix}", t[13]) : void 0, title: "" === t[14].title ? xn.filters.uncategorised : t[14].title, onClick: r } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 2 & n && (o.active = t[13] === t[1].active), 2 & n && (o.hasActive = null !== t[1].active), 2 & n && (o.filter = t[14]), 6 & n && (o.link = t[2] ? t[2].replace("{prefix}", t[13]) : void 0), 2 & n && (o.title = "" === t[14].title ? xn.filters.uncategorised : t[14].title), 2 & n && (o.onClick = r), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function Bi(e) { let t, n, i, o = [], r = new Map, s = "" !== e[3] && Li(e), c = Object.entries(e[1].filters); const l = e => e[13]; for (let t = 0; t < c.length; t += 1) { let n = Ri(e, c, t), i = l(n); r.set(i, o[t] = Ni(i, n)) } return { c() { s && s.c(), t = jt(), n = xt("div"); for (let e = 0; e < o.length; e += 1)o[e].c(); St(n, "class", "iif-filters-list") }, m(e, r) { s && s.m(e, r), kt(e, t, r), kt(e, n, r); for (let e = 0; e < o.length; e += 1)o[e].m(n, null); i = !0 }, p(e, i) { "" !== e[3] ? s ? s.p(e, i) : (s = Li(e), s.c(), s.m(t.parentNode, t)) : s && (s.d(1), s = null), 70 & i && (c = Object.entries(e[1].filters), en(), o = cn(o, i, l, 1, e, c, r, n, sn, Ni, null, Ri), tn()) }, i(e) { if (!i) { for (let e = 0; e < c.length; e += 1)nn(o[e]); i = !0 } }, o(e) { for (let e = 0; e < o.length; e += 1)on(o[e]); i = !1 }, d(e) { s && s.d(e), e && _t(t), e && _t(n); for (let e = 0; e < o.length; e += 1)o[e].d() } } } function Vi(e) { let t, n, i = e[4].length > 1 && Fi(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { e[4].length > 1 ? i ? (i.p(e, n), 16 & n && nn(i, 1)) : (i = Fi(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function Di(e, t, n) { let { name: i } = t, { block: o } = t, { parent: r = "" } = t, { link: s = "" } = t, { onClick: c = null } = t, { showTitle: l = !1 } = t, { title: a = "" } = t; const u = Bt("registry"); function f(e) { "function" == typeof c ? c(e) : u.router.action(i, e === o.active ? null : e) } let d, p, h; return e.$$set = e => { "name" in e && n(0, i = e.name), "block" in e && n(1, o = e.block), "parent" in e && n(7, r = e.parent), "link" in e && n(2, s = e.link), "onClick" in e && n(8, c = e.onClick), "showTitle" in e && n(9, l = e.showTitle), "title" in e && n(10, a = e.title) }, e.$$.update = () => { if (1665 & e.$$.dirty) if (!1 === l) n(3, d = ""); else if ("string" == typeof a) n(3, d = a); else { let e = i; "" !== r && void 0 !== xn.filters[i + "-" + r] && (e = i + "-" + r), n(3, d = void 0 === xn.filters[e] ? "" : xn.filters[e]) } 2 & e.$$.dirty && n(4, p = null === o ? [] : Object.keys(o.filters)), 2 & e.$$.dirty && n(5, h = null === o || null === o.active ? "" : "filters--active") }, [i, o, s, d, p, h, f, r, c, l, a, e => f(e)] } class zi extends mn { constructor(e) { super(), gn(this, e, Di, Vi, mt, { name: 0, block: 1, parent: 7, link: 2, onClick: 8, showTitle: 9, title: 10 }) } } function qi(e) { let t, n, i; function o(t) { e[4](t) } let r = { type: "text", icon: "search", placeholder: e[1] }; return void 0 !== e[0] && (r.value = e[0]), t = new Nn({ props: r }), Dt.push((() => un(t, "value", o))), { c() { fn(t.$$.fragment) }, m(e, n) { dn(t, e, n), i = !0 }, p(e, i) { const o = {}; !n && 1 & i && (n = !0, o.value = e[0], Gt((() => n = !1))), t.$set(o) }, i(e) { i || (nn(t.$$.fragment, e), i = !0) }, o(e) { on(t.$$.fragment, e), i = !1 }, d(e) { pn(t, e) } } } function Ui(e) { let t, n; return t = new zn({ props: { type: "filter", $$slots: { default: [qi] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 129 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Hi(e, t, n) { let { name: i } = t, { block: o } = t; const r = Bt("registry"); let s = o.keyword; const c = xn.search, l = void 0 === c.placeholder.collections ? c.defaultPlaceholder : c.placeholder.collections; return e.$$set = e => { "name" in e && n(2, i = e.name), "block" in e && n(3, o = e.block) }, e.$$.update = () => { 13 & e.$$.dirty && s !== o.keyword && r.router.action(i, s) }, [s, l, i, o, function (e) { s = e, n(0, s) }] } class Ki extends mn { constructor(e) { super(), gn(this, e, Hi, Ui, mt, { name: 2, block: 3 }) } } function Gi(e) { let t, n; return { c() { n = It(), t = new Tt(n) }, m(i, o) { t.m(e[1], i, o), kt(i, n, o) }, p(e, n) { 2 & n && t.p(e[1]) }, d(e) { e && _t(n), e && t.d() } } } function Ji(e) { let t, n = e[0] && Gi(e); return { c() { n && n.c(), t = It() }, m(e, i) { n && n.m(e, i), kt(e, t, i) }, p(e, [i]) { e[0] ? n ? n.p(e, i) : (n = Gi(e), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null) }, i: ut, o: ut, d(e) { n && n.d(e), e && _t(t) } } } function Wi(e, t, n) { let { text: i } = t, o = !1; Lt((() => { n(0, o = !0) })); const r = { 0: { paths: ["M24 68h8c6 0 12 6 12 12v32c0 6-6 12-12 12H16c-6 0-12-6-12-12V80c0-6 5-12 12-12h8z"], width: 48 }, 1: { paths: ["M4 68c6 0 12 6 12 12v44H4h24"], width: 32 }, 2: { paths: ["M4 80c0-6 6-12 12-12h16c6 0 12 6 12 12v8c0 6-6 12-12 12H16c-6 0-12 6-12 12v12h40"], width: 48 }, 3: { paths: ["M4 80c0-6 6-12 12-12h16c6 0 12 6 12 12v4c0 6-6 12-12 12h-4 4c6 0 12 6 12 12v4c0 6-6 12-12 12H16c-6 0-12-6-12-12"], width: 48 }, 4: { paths: ["M4 68v20c0 6 6 12 12 12h16c6 0 12-6 12-12V68v56"], width: 48 }, 5: { paths: ["M44 68H4v24h28c6 0 12 6 12 12v8c0 6-6 12-12 12H16c-6 0-12-6-12-12"], width: 48 }, 6: { paths: ["M44 80c0-6-6-12-12-12H16c-6 0-12 6-12 12v32c0 6 6 12 12 12h16c6 0 12-6 12-12v-8c0-6-6-12-12-12H16c-6 0-12 6-12 12"], width: 48 }, 7: { paths: ["M4 68h28c6 0 12 6 12 12 0 4-6.667 18.667-20 44"], width: 48 }, 8: { paths: ["M24 68h8c6 0 12 6 12 12v4c0 6-6 12-12 12 6 0 12 6 12 12v4c0 6-6 12-12 12H16c-6 0-12-6-12-12v-4c0-6 6-12 12-12-6 0-12-6-12-12v-4c0-6 6-12 12-12h8z"], width: 48 }, 9: { paths: ["M44 88c0 6-6 12-12 12H16c-6 0-12-6-12-12v-8c0-6 6-12 12-12h16c6 0 12 6 12 12v32c0 6-6 12-12 12H16c-6 0-12-6-12-12"], width: 48 }, "|": { paths: ["M4 48l24-24 24 24", "M4 144l24 24 24-24", "M28 48v96"], width: 56 }, ",": { paths: ["M8 124c-2 0-4-2-4-4s2-4 4-4 4 2 4 4v8c0 2-2 6-4 8"], width: 16 }, ".": { paths: ["M8 116c2 0 4 2 4 4s-2 4-4 4-4-2-4-4 2-4 4-4z"], width: 16 } }, s = { line: !1, animate: !1, height: 24 }; let c; return e.$$set = e => { "text" in e && n(2, i = e.text) }, e.$$.update = () => { 4 & e.$$.dirty && n(1, c = function (e, t) { let n, i, o, c, l = 8, a = 192, u = ""; "number" == typeof e && (e = "" + e); const f = Object.assign({}, s, "object" == typeof t ? t : {}); for (c = a / f.height, f.line && (l += 8), n = 0; n < e.length; n++)i = e.slice(n, n + 1), void 0 !== r[i] ? ("|" === i && (f.line = !0), o = r[i], l > 8 && (u += '<g transform="translate(' + l + ')">'), o.paths.forEach((e => { u += '<path d="' + e + '" />' })), l > 8 && (u += "</g>"), l += o.width + 8) : " " === i && (l += 16); return f.line && (u += '<path d="M4 4h' + (l - 8) + '" />', u += '<path d="M4 188h' + (l - 8) + '" />'), u = '<g stroke-width="8" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">' + u + "</g>", '<svg xmlns="http://www.w3.org/2000/svg" focusable="false" width="' + l / c + '" height="' + a / c + '" viewBox="0 0 ' + l + ' 192"> ' + u + "</svg>" }(i)) }, [o, c, i] } class Qi extends mn { constructor(e) { super(), gn(this, e, Wi, Ji, mt, { text: 2 }) } } function Yi(e, t, n) { const i = e.slice(); return i[15] = t[n], i } function Xi(e) { let t, n, i, o = xn.collection.by + ""; function r(e, t) { return e[2].author.url ? eo : Zi } let s = r(e), c = s(e); return { c() { t = xt("small"), n = Ct(o), i = jt(), c.c() }, m(e, o) { kt(e, t, o), bt(t, n), bt(t, i), c.m(t, null) }, p(e, n) { s === (s = r(e)) && c ? c.p(e, n) : (c.d(1), c = s(e), c && (c.c(), c.m(t, null))) }, d(e) { e && _t(t), c.d() } } } function Zi(e) { let t, n = e[2].author.name + ""; return { c() { t = Ct(n) }, m(e, n) { kt(e, t, n) }, p(e, i) { 4 & i && n !== (n = e[2].author.name + "") && Et(t, n) }, d(e) { e && _t(t) } } } function eo(e) { let t, n, i, o, r, s = e[2].author.name + ""; return { c() { t = xt("a"), n = Ct(s), St(t, "href", i = e[2].author.url), St(t, "target", "_blank") }, m(i, s) { kt(i, t, s), bt(t, n), o || (r = Pt(t, "click", e[6]), o = !0) }, p(e, o) { 4 & o && s !== (s = e[2].author.name + "") && Et(n, s), 4 & o && i !== (i = e[2].author.url) && St(t, "href", i) }, d(e) { e && _t(t), o = !1, r() } } } function to(e) { let t, n; return t = new $e({ props: { class: "iconify", icon: ("" === e[0] ? "" : "@" + e[0] + ":") + e[1] + ":" + e[15] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 3 & n && (i.icon = ("" === e[0] ? "" : "@" + e[0] + ":") + e[1] + ":" + e[15]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function no(e) { let t, n, i; return n = new Qi({ props: { text: e[9] } }), { c() { t = xt("div"), fn(n.$$.fragment), St(t, "class", "iif-collection-height") }, m(e, o) { kt(e, t, o), dn(n, t, null), i = !0 }, p: ut, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n) } } } function io(e) { let t, n, i, o, r, s, c, l, a, u, f, d, p, h, g = e[2].name + "", m = e[2].author && Xi(e), y = e[7].length > 0 && function (e) { let t, n, i = e[7], o = []; for (let t = 0; t < i.length; t += 1)o[t] = to(Yi(e, i, t)); const r = e => on(o[e], 1, 1, (() => { o[e] = null })); return { c() { t = xt("div"); for (let e = 0; e < o.length; e += 1)o[e].c(); St(t, "class", "iif-collection-samples" + (e[8] ? " iif-collection-samples--" + e[8] : "")) }, m(e, i) { kt(e, t, i); for (let e = 0; e < o.length; e += 1)o[e].m(t, null); n = !0 }, p(e, n) { if (131 & n) { let s; for (i = e[7], s = 0; s < i.length; s += 1) { const r = Yi(e, i, s); o[s] ? (o[s].p(r, n), nn(o[s], 1)) : (o[s] = to(r), o[s].c(), nn(o[s], 1), o[s].m(t, null)) } for (en(), s = i.length; s < o.length; s += 1)r(s); tn() } }, i(e) { if (!n) { for (let e = 0; e < i.length; e += 1)nn(o[e]); n = !0 } }, o(e) { o = o.filter(Boolean); for (let e = 0; e < o.length; e += 1)on(o[e]); n = !1 }, d(e) { e && _t(t), wt(o, e) } } }(e), $ = e[2].height && no(e); return f = new Qi({ props: { text: e[2].total + "" } }), { c() { t = xt("li"), n = xt("div"), i = xt("a"), o = Ct(g), r = jt(), m && m.c(), s = jt(), c = xt("div"), y && y.c(), l = jt(), $ && $.c(), a = jt(), u = xt("div"), fn(f.$$.fragment), St(i, "href", e[4]), St(n, "class", "iif-collection-text"), St(u, "class", "iif-collection-total"), St(c, "class", "iif-collection-data"), St(t, "class", e[5]) }, m(g, v) { kt(g, t, v), bt(t, n), bt(n, i), bt(i, o), bt(n, r), m && m.m(n, null), bt(t, s), bt(t, c), y && y.m(c, null), bt(c, l), $ && $.m(c, null), bt(c, a), bt(c, u), dn(f, u, null), d = !0, p || (h = [Pt(i, "click", Ot(e[11])), Pt(t, "click", e[10])], p = !0) }, p(e, [r]) { (!d || 4 & r) && g !== (g = e[2].name + "") && Et(o, g), (!d || 16 & r) && St(i, "href", e[4]), e[2].author ? m ? m.p(e, r) : (m = Xi(e), m.c(), m.m(n, null)) : m && (m.d(1), m = null), e[7].length > 0 && y.p(e, r), e[2].height ? $ ? ($.p(e, r), 4 & r && nn($, 1)) : ($ = no(e), $.c(), nn($, 1), $.m(c, a)) : $ && (en(), on($, 1, 1, (() => { $ = null })), tn()); const s = {}; 4 & r && (s.text = e[2].total + ""), f.$set(s), (!d || 32 & r) && St(t, "class", e[5]) }, i(e) { d || (nn(y), nn($), nn(f.$$.fragment, e), d = !0) }, o(e) { on(y), on($), on(f.$$.fragment, e), d = !1 }, d(e) { e && _t(t), m && m.d(), y && y.d(), $ && $.d(), pn(f), p = !1, ht(h) } } } const oo = "iif-collection"; function ro(e, t, n) { let { provider: i } = t, { prefix: o } = t, { info: r } = t, { onClick: s } = t; const c = Bt("registry").link; let l, a; const u = function () { if (r.samples instanceof Array) return r.samples.slice(0, 3); return [] }(), f = function () { if (r.displayHeight) return r.displayHeight; if ("number" == typeof r.height) return r.height; return 0 }(), d = "|" + ("object" != typeof r.height ? r.height : r.height.join(", ")); return e.$$set = e => { "provider" in e && n(0, i = e.provider), "prefix" in e && n(1, o = e.prefix), "info" in e && n(2, r = e.info), "onClick" in e && n(3, s = e.onClick) }, e.$$.update = () => { if (19 & e.$$.dirty) { const e = tt.getProvider(i); e ? (n(4, l = e.links.collection.replace("{prefix}", o)), "" === l && n(4, l = "#")) : n(4, l = "#") } 7 & e.$$.dirty && n(5, a = oo + " " + oo + "--prefix--" + o + ("" === i ? "" : " iif-collection--provider--" + i) + (r.index ? " iif-collection--" + r.index % 11 : "")) }, [i, o, r, s, l, a, c, u, f, d, function (e) { }, () => s(o)] } class so extends mn { constructor(e) { super(), gn(this, e, ro, io, mt, { provider: 0, prefix: 1, info: 2, onClick: 3 }) } } function co(e, t, n) { const i = e.slice(); return i[5] = t[n][0], i[6] = t[n][1], i[8] = n, i } function lo(e) { let t, n; return { c() { t = xt("div"), n = Ct(e[1]), St(t, "class", "iif-collections-list-title") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 2 & t && Et(n, e[1]) }, d(e) { e && _t(t) } } } function ao(e, t) { let n, i, o; return i = new so({ props: { provider: t[3], prefix: t[5], info: t[6], onClick: t[4] } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 8 & n && (o.provider = t[3]), 4 & n && (o.prefix = t[5]), 4 & n && (o.info = t[6]), 16 & n && (o.onClick = t[4]), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function uo(e) { let t, n, i, o, r = [], s = new Map, c = e[0] && lo(e), l = Object.entries(e[2]); const a = e => e[5]; for (let t = 0; t < l.length; t += 1) { let n = co(e, l, t), i = a(n); s.set(i, r[t] = ao(i, n)) } return { c() { t = xt("div"), c && c.c(), n = jt(), i = xt("ul"); for (let e = 0; e < r.length; e += 1)r[e].c(); St(i, "class", "iif-collections-list-items"), St(t, "class", "iif-collections-list-category") }, m(e, s) { kt(e, t, s), c && c.m(t, null), bt(t, n), bt(t, i); for (let e = 0; e < r.length; e += 1)r[e].m(i, null); o = !0 }, p(e, [o]) { e[0] ? c ? c.p(e, o) : (c = lo(e), c.c(), c.m(t, n)) : c && (c.d(1), c = null), 28 & o && (l = Object.entries(e[2]), en(), r = cn(r, o, a, 1, e, l, s, i, sn, ao, null, co), tn()) }, i(e) { if (!o) { for (let e = 0; e < l.length; e += 1)nn(r[e]); o = !0 } }, o(e) { for (let e = 0; e < r.length; e += 1)on(r[e]); o = !1 }, d(e) { e && _t(t), c && c.d(); for (let e = 0; e < r.length; e += 1)r[e].d() } } } function fo(e, t, n) { let { showCategories: i } = t, { category: o = "" } = t, { items: r } = t, { provider: s } = t, { onClick: c } = t; return e.$$set = e => { "showCategories" in e && n(0, i = e.showCategories), "category" in e && n(1, o = e.category), "items" in e && n(2, r = e.items), "provider" in e && n(3, s = e.provider), "onClick" in e && n(4, c = e.onClick) }, [i, o, r, s, c] } class po extends mn { constructor(e) { super(), gn(this, e, fo, uo, mt, { showCategories: 0, category: 1, items: 2, provider: 3, onClick: 4 }) } } function ho(e) { let t, n; return { c() { t = xt("div"), n = Ct(e[0]), St(t, "class", "iif-content-error") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, [t]) { 1 & t && Et(n, e[0]) }, i: ut, o: ut, d(e) { e && _t(t) } } } function go(e, t, n) { let { error: i } = t; return e.$$set = e => { "error" in e && n(0, i = e.error) }, [i] } class mo extends mn { constructor(e) { super(), gn(this, e, go, ho, mt, { error: 0 }) } } function yo(e, t, n) { const i = e.slice(); return i[5] = t[n][0], i[6] = t[n][1], i[8] = n, i } function $o(e) { let t, n; return t = new mo({ props: { error: xn.errors.noCollections } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p: ut, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function vo(e, t) { let n, i, o; return i = new po({ props: { onClick: t[2], showCategories: t[0].showCategories, category: t[5], provider: t[1], items: t[6] } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 1 & n && (o.showCategories = t[0].showCategories), 1 & n && (o.category = t[5]), 2 & n && (o.provider = t[1]), 1 & n && (o.items = t[6]), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function bo(e) { let t, n, i = [], o = new Map, r = Object.entries(e[0].collections); const s = e => e[5]; for (let t = 0; t < r.length; t += 1) { let n = yo(e, r, t), c = s(n); o.set(c, i[t] = vo(c, n)) } let c = null; return r.length || (c = $o()), { c() { for (let e = 0; e < i.length; e += 1)i[e].c(); t = It(), c && c.c() }, m(e, o) { for (let t = 0; t < i.length; t += 1)i[t].m(e, o); kt(e, t, o), c && c.m(e, o), n = !0 }, p(e, n) { 7 & n && (r = Object.entries(e[0].collections), en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, vo, t, yo), tn(), !r.length && c ? c.p(e, n) : r.length ? c && (en(), on(c, 1, 1, (() => { c = null })), tn()) : (c = $o(), c.c(), nn(c, 1), c.m(t.parentNode, t))) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < i.length; t += 1)i[t].d(e); e && _t(t), c && c.d(e) } } } function ko(e) { let t, n; return t = new zn({ props: { type: "collections", $$slots: { default: [bo] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 515 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function _o(e, t, n) { let { name: i } = t, { block: o } = t, { provider: r } = t; const s = Bt("registry"); return e.$$set = e => { "name" in e && n(3, i = e.name), "block" in e && n(0, o = e.block), "provider" in e && n(1, r = e.provider) }, [o, r, function (e) { s.router.action(i, e) }, i] } class wo extends mn { constructor(e) { super(), gn(this, e, _o, ko, mt, { name: 3, block: 0, provider: 1 }) } } function xo(e) { let t, n; return t = new zi({ props: { name: "categories", block: e[0].categories } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.block = e[0].categories), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Co(e) { let t, n, i, o, r, s, c, l = e[0].categories && xo(e); return o = new Ki({ props: { name: "filter", block: e[0].filter } }), s = new wo({ props: { provider: e[1].params.provider, name: "collections", block: e[0].collections } }), { c() { t = xt("div"), n = xt("div"), l && l.c(), i = jt(), fn(o.$$.fragment), r = jt(), fn(s.$$.fragment), St(n, "class", "iif-collections-header"), St(t, "class", "iif-view iif-view--collections") }, m(e, a) { kt(e, t, a), bt(t, n), l && l.m(n, null), bt(n, i), dn(o, n, null), bt(t, r), dn(s, t, null), c = !0 }, p(e, [t]) { e[0].categories ? l ? (l.p(e, t), 1 & t && nn(l, 1)) : (l = xo(e), l.c(), nn(l, 1), l.m(n, i)) : l && (en(), on(l, 1, 1, (() => { l = null })), tn()); const r = {}; 1 & t && (r.block = e[0].filter), o.$set(r); const c = {}; 2 & t && (c.provider = e[1].params.provider), 1 & t && (c.block = e[0].collections), s.$set(c) }, i(e) { c || (nn(l), nn(o.$$.fragment, e), nn(s.$$.fragment, e), c = !0) }, o(e) { on(l), on(o.$$.fragment, e), on(s.$$.fragment, e), c = !1 }, d(e) { e && _t(t), l && l.d(), pn(o), pn(s) } } } function jo(e, t, n) { let { blocks: i } = t, { route: o } = t; return e.$$set = e => { "blocks" in e && n(0, i = e.blocks), "route" in e && n(1, o = e.route) }, [i, o] } class Io extends mn { constructor(e) { super(), gn(this, e, jo, Co, mt, { blocks: 0, route: 1 }) } } function Po(e) { let t, n; return t = new zn({ props: { type: "collection-info", extra: e[0], $$slots: { default: [No] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.extra = e[0]), 270 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Oo(e) { let t, n, i = e[3].name + ""; return { c() { t = xt("div"), n = Ct(i), St(t, "class", "iif-collection-info-title") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 8 & t && i !== (i = e[3].name + "") && Et(n, i) }, d(e) { e && _t(t) } } } function So(e) { let t, n, i; function o(e, t) { return e[3].author.url ? Mo : Eo } let r = o(e), s = r(e); return { c() { t = xt("dl"), n = xt("dt"), n.textContent = `${e[4].author}`, i = xt("dd"), s.c() }, m(e, o) { kt(e, t, o), bt(t, n), bt(t, i), s.m(i, null) }, p(e, t) { r === (r = o(e)) && s ? s.p(e, t) : (s.d(1), s = r(e), s && (s.c(), s.m(i, null))) }, d(e) { e && _t(t), s.d() } } } function Eo(e) { let t, n = e[3].author.name + ""; return { c() { t = Ct(n) }, m(e, n) { kt(e, t, n) }, p(e, i) { 8 & i && n !== (n = e[3].author.name + "") && Et(t, n) }, d(e) { e && _t(t) } } } function Mo(e) { let t, n, i, o, r, s = e[3].author.name + ""; return { c() { t = xt("a"), n = Ct(s), St(t, "href", i = e[3].author.url), St(t, "target", "_blank") }, m(i, s) { kt(i, t, s), bt(t, n), o || (r = Pt(t, "click", e[5]), o = !0) }, p(e, o) { 8 & o && s !== (s = e[3].author.name + "") && Et(n, s), 8 & o && i !== (i = e[3].author.url) && St(t, "href", i) }, d(e) { e && _t(t), o = !1, r() } } } function To(e) { let t, n, i; function o(e, t) { return e[3].license.url ? Ro : Ao } let r = o(e), s = r(e); return { c() { t = xt("dl"), n = xt("dt"), n.textContent = `${e[4].license}`, i = xt("dd"), s.c() }, m(e, o) { kt(e, t, o), bt(t, n), bt(t, i), s.m(i, null) }, p(e, t) { r === (r = o(e)) && s ? s.p(e, t) : (s.d(1), s = r(e), s && (s.c(), s.m(i, null))) }, d(e) { e && _t(t), s.d() } } } function Ao(e) { let t, n = e[3].license.title + ""; return { c() { t = Ct(n) }, m(e, n) { kt(e, t, n) }, p(e, i) { 8 & i && n !== (n = e[3].license.title + "") && Et(t, n) }, d(e) { e && _t(t) } } } function Ro(e) { let t, n, i, o, r, s = e[3].license.title + ""; return { c() { t = xt("a"), n = Ct(s), St(t, "href", i = e[3].license.url), St(t, "target", "_blank") }, m(i, s) { kt(i, t, s), bt(t, n), o || (r = Pt(t, "click", e[5]), o = !0) }, p(e, o) { 8 & o && s !== (s = e[3].license.title + "") && Et(n, s), 8 & o && i !== (i = e[3].license.url) && St(t, "href", i) }, d(e) { e && _t(t), o = !1, r() } } } function Fo(e) { let t, n, i, o, r, s, c = e[3].total + "", l = e[3].height && Lo(e); return { c() { t = xt("dl"), n = xt("dt"), n.textContent = `${e[4].total}`, i = xt("dd"), o = Ct(c), r = jt(), l && l.c(), s = It() }, m(e, c) { kt(e, t, c), bt(t, n), bt(t, i), bt(i, o), kt(e, r, c), l && l.m(e, c), kt(e, s, c) }, p(e, t) { 8 & t && c !== (c = e[3].total + "") && Et(o, c), e[3].height ? l ? l.p(e, t) : (l = Lo(e), l.c(), l.m(s.parentNode, s)) : l && (l.d(1), l = null) }, d(e) { e && _t(t), e && _t(r), l && l.d(e), e && _t(s) } } } function Lo(e) { let t, n, i, o, r = ("object" == typeof e[3].height ? e[3].height.join(", ") : e[3].height) + ""; return { c() { t = xt("dl"), n = xt("dt"), n.textContent = `${e[4].height}`, i = xt("dd"), o = Ct(r) }, m(e, r) { kt(e, t, r), bt(t, n), bt(t, i), bt(i, o) }, p(e, t) { 8 & t && r !== (r = ("object" == typeof e[3].height ? e[3].height.join(", ") : e[3].height) + "") && Et(o, r) }, d(e) { e && _t(t) } } } function No(e) { let t, n, i, o, r = e[2] && Oo(e), s = e[3].author && So(e), c = e[3].license && To(e), l = !e[1] && Fo(e); return { c() { r && r.c(), t = jt(), s && s.c(), n = jt(), c && c.c(), i = jt(), l && l.c(), o = It() }, m(e, a) { r && r.m(e, a), kt(e, t, a), s && s.m(e, a), kt(e, n, a), c && c.m(e, a), kt(e, i, a), l && l.m(e, a), kt(e, o, a) }, p(e, a) { e[2] ? r ? r.p(e, a) : (r = Oo(e), r.c(), r.m(t.parentNode, t)) : r && (r.d(1), r = null), e[3].author ? s ? s.p(e, a) : (s = So(e), s.c(), s.m(n.parentNode, n)) : s && (s.d(1), s = null), e[3].license ? c ? c.p(e, a) : (c = To(e), c.c(), c.m(i.parentNode, i)) : c && (c.d(1), c = null), e[1] ? l && (l.d(1), l = null) : l ? l.p(e, a) : (l = Fo(e), l.c(), l.m(o.parentNode, o)) }, d(e) { r && r.d(e), e && _t(t), s && s.d(e), e && _t(n), c && c.d(e), e && _t(i), l && l.d(e), e && _t(o) } } } function Bo(e) { let t, n, i = e[3] && Po(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { e[3] ? i ? (i.p(e, n), 8 & n && nn(i, 1)) : (i = Po(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function Vo(e, t, n) { let { name: i } = t, { block: o } = t, { short: r = !1 } = t, { showTitle: s = !0 } = t; const c = xn.collectionInfo, l = Bt("registry").link; let a; return e.$$set = e => { "name" in e && n(0, i = e.name), "block" in e && n(6, o = e.block), "short" in e && n(1, r = e.short), "showTitle" in e && n(2, s = e.showTitle) }, e.$$.update = () => { 64 & e.$$.dirty && n(3, a = o.info) }, [i, r, s, a, c, l, o] } class Do extends mn { constructor(e) { super(), gn(this, e, Vo, Bo, mt, { name: 0, block: 6, short: 1, showTitle: 2 }) } } function zo(e, t, n) { const i = e.slice(); return i[14] = t[n], i } function qo(e) { let t, n, i, o; t = new $e({ props: { icon: e[0], width: "1em", height: "1em" } }); let r = e[7] && Uo(e); return { c() { fn(t.$$.fragment), n = jt(), r && r.c(), i = It() }, m(e, s) { dn(t, e, s), kt(e, n, s), r && r.m(e, s), kt(e, i, s), o = !0 }, p(e, n) { const o = {}; 1 & n && (o.icon = e[0]), t.$set(o), e[7] ? r ? (r.p(e, n), 128 & n && nn(r, 1)) : (r = Uo(e), r.c(), nn(r, 1), r.m(i.parentNode, i)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()) }, i(e) { o || (nn(t.$$.fragment, e), nn(r), o = !0) }, o(e) { on(t.$$.fragment, e), on(r), o = !1 }, d(e) { pn(t, e), e && _t(n), r && r.d(e), e && _t(i) } } } function Uo(e) { let t, n; return t = new En({ props: { icon: e[4] ? "selecting-selected" : "selecting-unselected" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 16 & n && (i.icon = e[4] ? "selecting-selected" : "selecting-unselected"), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ho(e) { let t, n, i, o, r = e[9].width + "", s = e[9].height + ""; return { c() { t = xt("div"), n = Ct(r), i = Ct(" x "), o = Ct(s), St(t, "class", "iif-icon-size") }, m(e, r) { kt(e, t, r), bt(t, n), bt(t, i), bt(t, o) }, p(e, t) { 512 & t && r !== (r = e[9].width + "") && Et(n, r), 512 & t && s !== (s = e[9].height + "") && Et(o, s) }, d(e) { e && _t(t) } } } function Ko(e) { let t, n, i = e[8], o = []; for (let t = 0; t < i.length; t += 1)o[t] = Go(zo(e, i, t)); const r = e => on(o[e], 1, 1, (() => { o[e] = null })); return { c() { for (let e = 0; e < o.length; e += 1)o[e].c(); t = It() }, m(e, i) { for (let t = 0; t < o.length; t += 1)o[t].m(e, i); kt(e, t, i), n = !0 }, p(e, n) { if (320 & n) { let s; for (i = e[8], s = 0; s < i.length; s += 1) { const r = zo(e, i, s); o[s] ? (o[s].p(r, n), nn(o[s], 1)) : (o[s] = Go(r), o[s].c(), nn(o[s], 1), o[s].m(t.parentNode, t)) } for (en(), s = i.length; s < o.length; s += 1)r(s); tn() } }, i(e) { if (!n) { for (let e = 0; e < i.length; e += 1)nn(o[e]); n = !0 } }, o(e) { o = o.filter(Boolean); for (let e = 0; e < o.length; e += 1)on(o[e]); n = !1 }, d(e) { wt(o, e), e && _t(t) } } } function Go(e) { let t, n; function i() { return e[13](e[14]) } return t = new Ai({ props: { filter: e[14].item, title: "" === e[14].item.title ? xn.filters.uncategorised : e[14].item.title, onClick: i } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(n, o) { e = n; const r = {}; 256 & o && (r.filter = e[14].item), 256 & o && (r.title = "" === e[14].item.title ? xn.filters.uncategorised : e[14].item.title), 320 & o && (r.onClick = i), t.$set(r) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Jo(e) { let t, n, i, o, r, s, c, l, a, u, f, d, p, h = e[3] && qo(e), g = e[9] && Ho(e), m = e[8] && Ko(e); return { c() { t = xt("li"), n = xt("div"), i = xt("a"), h && h.c(), o = jt(), r = xt("div"), s = xt("a"), c = Ct(e[2]), l = jt(), g && g.c(), a = jt(), m && m.c(), St(i, "href", e[5]), St(i, "target", "_blank"), St(i, "title", e[1]), St(n, "class", "iif-icon-sample"), St(s, "class", "iif-icon-name"), St(s, "href", e[5]), St(s, "title", e[1]), St(r, "class", u = "iif-icon-data iif-icon-data--filters--" + e[8].length), St(t, "class", e[10]) }, m(u, y) { kt(u, t, y), bt(t, n), bt(n, i), h && h.m(i, null), bt(t, o), bt(t, r), bt(r, s), bt(s, c), bt(r, l), g && g.m(r, null), bt(r, a), m && m.m(r, null), f = !0, d || (p = [Pt(i, "click", Ot(e[11])), Pt(s, "click", Ot(e[11]))], d = !0) }, p(e, [n]) { e[3] ? h ? (h.p(e, n), 8 & n && nn(h, 1)) : (h = qo(e), h.c(), nn(h, 1), h.m(i, null)) : h && (en(), on(h, 1, 1, (() => { h = null })), tn()), (!f || 32 & n) && St(i, "href", e[5]), (!f || 2 & n) && St(i, "title", e[1]), (!f || 4 & n) && Et(c, e[2]), (!f || 32 & n) && St(s, "href", e[5]), (!f || 2 & n) && St(s, "title", e[1]), e[9] ? g ? g.p(e, n) : (g = Ho(e), g.c(), g.m(r, a)) : g && (g.d(1), g = null), e[8] ? m ? (m.p(e, n), 256 & n && nn(m, 1)) : (m = Ko(e), m.c(), nn(m, 1), m.m(r, null)) : m && (en(), on(m, 1, 1, (() => { m = null })), tn()), (!f || 256 & n && u !== (u = "iif-icon-data iif-icon-data--filters--" + e[8].length)) && St(r, "class", u), (!f || 1024 & n) && St(t, "class", e[10]) }, i(e) { f || (nn(h), nn(m), f = !0) }, o(e) { on(h), on(m), f = !1 }, d(e) { e && _t(t), h && h.d(), g && g.d(), m && m.d(), d = !1, ht(p) } } } const Wo = "iif-icon-list"; function Qo(e, t, n) { let i, { name: o } = t, { tooltip: r } = t, { text: s } = t, { icon: c } = t, { exists: l } = t, { selected: a } = t, { link: u } = t, { onClick: f } = t, { isSelecting: d } = t, { filters: p } = t, h = null; return e.$$set = e => { "name" in e && n(0, o = e.name), "tooltip" in e && n(1, r = e.tooltip), "text" in e && n(2, s = e.text), "icon" in e && n(12, c = e.icon), "exists" in e && n(3, l = e.exists), "selected" in e && n(4, a = e.selected), "link" in e && n(5, u = e.link), "onClick" in e && n(6, f = e.onClick), "isSelecting" in e && n(7, d = e.isSelecting), "filters" in e && n(8, p = e.filters) }, e.$$.update = () => { if (24 & e.$$.dirty && n(10, i = Wo + " " + Wo + (l ? "--loaded" : "--loading") + (a ? " iif-icon-list--selected" : "")), 521 & e.$$.dirty) { const e = l ? ce(o) : null; e !== h && n(9, h = e) } }, [o, r, s, l, a, u, f, d, p, h, i, function () { f(d ? a ? "deselect" : "select" : "toggle", c) }, c, e => f(e.action, e.value)] } class Yo extends mn { constructor(e) { super(), gn(this, e, Qo, Jo, mt, { name: 0, tooltip: 1, text: 2, icon: 12, exists: 3, selected: 4, link: 5, onClick: 6, isSelecting: 7, filters: 8 }) } } function Xo(e) { let t, n, i = e[2].name + ""; return { c() { t = xt("span"), n = Ct(i), St(t, "class", "iif-icon-loading") }, m(e, i) { kt(e, t, i), bt(t, n) }, p(e, t) { 4 & t && i !== (i = e[2].name + "") && Et(n, i) }, i: ut, o: ut, d(e) { e && _t(t) } } } function Zo(e) { let t, n, i, o; t = new $e({ props: { icon: e[0], width: "1em", height: "1em" } }); let r = e[6] && er(e); return { c() { fn(t.$$.fragment), n = jt(), r && r.c(), i = It() }, m(e, s) { dn(t, e, s), kt(e, n, s), r && r.m(e, s), kt(e, i, s), o = !0 }, p(e, n) { const o = {}; 1 & n && (o.icon = e[0]), t.$set(o), e[6] ? r ? (r.p(e, n), 64 & n && nn(r, 1)) : (r = er(e), r.c(), nn(r, 1), r.m(i.parentNode, i)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()) }, i(e) { o || (nn(t.$$.fragment, e), nn(r), o = !0) }, o(e) { on(t.$$.fragment, e), on(r), o = !1 }, d(e) { pn(t, e), e && _t(n), r && r.d(e), e && _t(i) } } } function er(e) { let t, n; return t = new En({ props: { icon: e[4] ? "selecting-selected" : "selecting-unselected" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 16 & n && (i.icon = e[4] ? "selecting-selected" : "selecting-unselected"), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function tr(e) { let t, n, i, o, r, s, c; const l = [Zo, Xo], a = []; function u(e, t) { return e[3] ? 0 : 1 } return i = u(e), o = a[i] = l[i](e), { c() { t = xt("li"), n = xt("a"), o.c(), St(n, "href", e[5]), St(n, "target", "_blank"), St(n, "title", e[1]), St(t, "class", e[7]) }, m(o, l) { kt(o, t, l), bt(t, n), a[i].m(n, null), r = !0, s || (c = Pt(n, "click", Ot(e[8])), s = !0) }, p(e, [s]) { let c = i; i = u(e), i === c ? a[i].p(e, s) : (en(), on(a[c], 1, 1, (() => { a[c] = null })), tn(), o = a[i], o ? o.p(e, s) : (o = a[i] = l[i](e), o.c()), nn(o, 1), o.m(n, null)), (!r || 32 & s) && St(n, "href", e[5]), (!r || 2 & s) && St(n, "title", e[1]), (!r || 128 & s) && St(t, "class", e[7]) }, i(e) { r || (nn(o), r = !0) }, o(e) { on(o), r = !1 }, d(e) { e && _t(t), a[i].d(), s = !1, c() } } } const nr = "iif-icon-grid"; function ir(e, t, n) { let i, { name: o } = t, { tooltip: r } = t, { icon: s } = t, { exists: c } = t, { selected: l } = t, { link: a } = t, { onClick: u } = t, { isSelecting: f } = t; return e.$$set = e => { "name" in e && n(0, o = e.name), "tooltip" in e && n(1, r = e.tooltip), "icon" in e && n(2, s = e.icon), "exists" in e && n(3, c = e.exists), "selected" in e && n(4, l = e.selected), "link" in e && n(5, a = e.link), "onClick" in e && n(9, u = e.onClick), "isSelecting" in e && n(6, f = e.isSelecting) }, e.$$.update = () => { 24 & e.$$.dirty && n(7, i = nr + " " + nr + (c ? "--loaded" : "--loading") + (l ? " iif-icon-grid--selected" : "")) }, [o, r, s, c, l, a, f, i, function () { u(f ? l ? "deselect" : "select" : "toggle", s) }, u] } class or extends mn { constructor(e) { super(), gn(this, e, ir, tr, mt, { name: 0, tooltip: 1, icon: 2, exists: 3, selected: 4, link: 5, onClick: 9, isSelecting: 6 }) } } function rr(e, t, n) { const i = e.slice(); return i[16] = t[n], i[18] = n, i } function sr(e) { let t, n; const i = [e[16], { onClick: e[3] }, { isSelecting: e[1] }]; let o = {}; for (let e = 0; e < i.length; e += 1)o = ft(o, i[e]); return t = new or({ props: o }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const o = 14 & n ? ln(i, [4 & n && an(e[16]), 8 & n && { onClick: e[3] }, 2 & n && { isSelecting: e[1] }]) : {}; t.$set(o) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function cr(e) { let t, n; const i = [e[16], { onClick: e[3] }, { isSelecting: e[1] }]; let o = {}; for (let e = 0; e < i.length; e += 1)o = ft(o, i[e]); return t = new Yo({ props: o }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const o = 14 & n ? ln(i, [4 & n && an(e[16]), 8 & n && { onClick: e[3] }, 2 & n && { isSelecting: e[1] }]) : {}; t.$set(o) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function lr(e, t) { let n, i, o, r, s; const c = [cr, sr], l = []; function a(e, t) { return e[0] ? 0 : 1 } return i = a(t), o = l[i] = c[i](t), { key: e, first: null, c() { n = It(), o.c(), r = It(), this.first = n }, m(e, t) { kt(e, n, t), l[i].m(e, t), kt(e, r, t), s = !0 }, p(e, n) { let s = i; i = a(t = e), i === s ? l[i].p(t, n) : (en(), on(l[s], 1, 1, (() => { l[s] = null })), tn(), o = l[i], o ? o.p(t, n) : (o = l[i] = c[i](t), o.c()), nn(o, 1), o.m(r.parentNode, r)) }, i(e) { s || (nn(o), s = !0) }, o(e) { on(o), s = !1 }, d(e) { e && _t(n), l[i].d(e), e && _t(r) } } } function ar(e) { let t, n, i, o, r = [], s = new Map, c = e[2]; const l = e => e[16].name; for (let t = 0; t < c.length; t += 1) { let n = rr(e, c, t), i = l(n); s.set(i, r[t] = lr(i, n)) } return { c() { t = xt("div"), n = xt("ul"); for (let e = 0; e < r.length; e += 1)r[e].c(); St(t, "class", i = ur + " " + ur + (e[0] ? "--list" : "--grid") + (e[1] ? " " + ur + "--selecting" : "")) }, m(e, i) { kt(e, t, i), bt(t, n); for (let e = 0; e < r.length; e += 1)r[e].m(n, null); o = !0 }, p(e, [a]) { 15 & a && (c = e[2], en(), r = cn(r, a, l, 1, e, c, s, n, sn, lr, null, rr), tn()), (!o || 3 & a && i !== (i = ur + " " + ur + (e[0] ? "--list" : "--grid") + (e[1] ? " " + ur + "--selecting" : ""))) && St(t, "class", i) }, i(e) { if (!o) { for (let e = 0; e < c.length; e += 1)nn(r[e]); o = !0 } }, o(e) { for (let e = 0; e < r.length; e += 1)on(r[e]); o = !1 }, d(e) { e && _t(t); for (let e = 0; e < r.length; e += 1)r[e].d() } } } const ur = "iif-icons"; function fr(e, t, n) { let { route: i } = t, { selection: o } = t, { blocks: r } = t, { isList: s } = t, { isSelecting: c } = t; const l = Bt("registry"), a = ["tags", "themePrefixes", "themeSuffixes"], u = xn.icons.tooltip; let f, d = 0, p = null, h = 0; const g = () => { n(10, h++, h) }; Lt((() => { n(8, d = 1) })); let m = []; return Nt((() => { null !== p && (p(), n(9, p = null)) })), e.$$set = e => { "route" in e && n(4, i = e.route), "selection" in e && n(5, o = e.selection), "blocks" in e && n(6, r = e.blocks), "isList" in e && n(0, s = e.isList), "isSelecting" in e && n(1, c = e.isSelecting) }, e.$$.update = () => { if (16 & e.$$.dirty && n(7, f = "collection" !== i.type), 2021 & e.$$.dirty) { let e = [], t = []; const c = Object.create(null); 2 === d ? m.forEach((e => { c[e.name] = e })) : 1 === d && n(8, d = 2); let l = !1; r.icons.icons.forEach((n => { const d = tt.iconToString(n), p = ce(d), h = null !== p, g = f ? d : n.name; let m = g; p && (m += u.size.replace("{size}", p.width + " x " + p.height), m += u.length.replace("{length}", p.body.length + ""), void 0 !== n.chars && (m += u.char.replace("{char}", "string" == typeof n.chars ? n.chars : n.chars.join(", "))), m += u[-1 === p.body.indexOf("currentColor") ? "colorful" : "colorless"]); const y = tt.getProvider(n.provider); let $; y ? ($ = y.links.icon.replace("{prefix}", n.prefix).replace("{name}", n.name), "" === $ && ($ = "#")) : $ = "#"; let v = { name: d, text: g, tooltip: m, icon: tt.cloneObject(n), exists: h, link: $, selected: rt(o, n) }; s && (v.filters = function (e) { let t = []; const n = e.icon; if (a.forEach((e => { const i = e; if (!r[i]) return; if (void 0 === n[i]) return; const o = r[i], s = o.active, c = n[i]; ("string" == typeof c ? [c] : c instanceof Array ? c : []).forEach((e => { e !== s && void 0 !== o.filters[e] && t.push({ action: i, value: e, item: o.filters[e] }) })) })), "search" === i.type) { const n = r; if (n.collections) { const i = e.icon.prefix; n.collections.filters[i] && t.push({ action: "collections", value: i, item: n.collections.filters[i] }) } } return t }(v)), void 0 === c[d] ? (l = !0, h || t.push(d)) : tt.compareObjects(c[d], v) ? v = c[d] : l = !0, e.push(v) })), d > 0 && t.length && (null !== p && p(), n(9, p = ue(t, g))), (l || m.length !== e.length) && n(2, m = e) } }, [s, c, m, function (e, t) { "toggle" !== e ? "select" !== e && "deselect" !== e ? l.router.action(e, t) : l.callback({ type: "selection", icon: t, selected: "select" === e }) : l.callback({ type: "selection", icon: t }) }, i, o, r, f, d, p, h] } class dr extends mn { constructor(e) { super(), gn(this, e, fr, ar, mt, { route: 4, selection: 5, blocks: 6, isList: 0, isSelecting: 1 }) } } function pr(e) { let t, n, i, o, r; return n = new En({ props: { icon: e[0] } }), { c() { t = xt("button"), fn(n.$$.fragment), St(t, "class", "iif-icon-button"), St(t, "title", e[1]) }, m(s, c) { kt(s, t, c), dn(n, t, null), i = !0, o || (r = Pt(t, "click", (function () { gt(e[2]) && e[2].apply(this, arguments) })), o = !0) }, p(o, [r]) { e = o; const s = {}; 1 & r && (s.icon = e[0]), n.$set(s), (!i || 2 & r) && St(t, "title", e[1]) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n), o = !1, r() } } } function hr(e, t, n) { let { icon: i } = t, { title: o } = t, { onClick: r } = t; return e.$$set = e => { "icon" in e && n(0, i = e.icon), "title" in e && n(1, o = e.title), "onClick" in e && n(2, r = e.onClick) }, [i, o, r] } class gr extends mn { constructor(e) { super(), gn(this, e, hr, pr, mt, { icon: 0, title: 1, onClick: 2 }) } } function mr(e, t, n) { const i = e.slice(); return i[11] = t[n], i } function yr(e) { let t, n, i, o = e[3] && $r(e), r = e[1] && vr(e); return { c() { t = xt("div"), o && o.c(), n = jt(), r && r.c(), St(t, "class", "iif-icons-header-modes") }, m(e, s) { kt(e, t, s), o && o.m(t, null), bt(t, n), r && r.m(t, null), i = !0 }, p(e, i) { e[3] ? o ? (o.p(e, i), 8 & i && nn(o, 1)) : (o = $r(e), o.c(), nn(o, 1), o.m(t, n)) : o && (en(), on(o, 1, 1, (() => { o = null })), tn()), e[1] ? r ? (r.p(e, i), 2 & i && nn(r, 1)) : (r = vr(e), r.c(), nn(r, 1), r.m(t, null)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()) }, i(e) { i || (nn(o), nn(r), i = !0) }, o(e) { on(o), on(r), i = !1 }, d(e) { e && _t(t), o && o.d(), r && r.d() } } } function $r(e) { let t, n; return t = new gr({ props: { icon: e[7], onClick: e[4], title: e[8].select } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 128 & n && (i.icon = e[7]), 16 & n && (i.onClick = e[4]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function vr(e) { let t, n, i = [], o = new Map, r = [e[6]]; const s = e => e[11]; for (let t = 0; t < 1; t += 1) { let n = mr(e, r, t), c = s(n); o.set(c, i[t] = br(c, n)) } return { c() { for (let e = 0; e < 1; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < 1; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, n) { 324 & n && (r = [e[6]], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, br, t, mr), tn()) }, i(e) { if (!n) { for (let e = 0; e < 1; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < 1; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < 1; t += 1)i[t].d(e); e && _t(t) } } } function br(e, t) { let n, i, o; return i = new gr({ props: { icon: t[11], onClick: t[2], title: t[8].modes[t[11]] } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 64 & n && (o.icon = t[11]), 4 & n && (o.onClick = t[2]), 64 & n && (o.title = t[8].modes[t[11]]), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function kr(e) { let t, n, i, o, r, s = e[5] && (e[1] || e[3]) && yr(e); return { c() { t = xt("div"), n = xt("div"), i = Ct(e[0]), o = jt(), s && s.c(), St(n, "class", "iif-icons-header-text"), St(t, "class", "iif-icons-header") }, m(e, c) { kt(e, t, c), bt(t, n), bt(n, i), bt(t, o), s && s.m(t, null), r = !0 }, p(e, [n]) { (!r || 1 & n) && Et(i, e[0]), e[5] && (e[1] || e[3]) ? s ? (s.p(e, n), 42 & n && nn(s, 1)) : (s = yr(e), s.c(), nn(s, 1), s.m(t, null)) : s && (en(), on(s, 1, 1, (() => { s = null })), tn()) }, i(e) { r || (nn(s), r = !0) }, o(e) { on(s), r = !1 }, d(e) { e && _t(t), s && s.d() } } } function _r(e, t, n) { let { headerText: i } = t, { isList: o } = t, { canChangeLayout: r } = t, { changeLayout: s } = t, { canSelectMultiple: c } = t, { isSelecting: l } = t, { toggleSelection: a } = t, u = !1; Lt((() => { n(5, u = !0) })); const f = xn.icons.header; let d, p; return e.$$set = e => { "headerText" in e && n(0, i = e.headerText), "isList" in e && n(9, o = e.isList), "canChangeLayout" in e && n(1, r = e.canChangeLayout), "changeLayout" in e && n(2, s = e.changeLayout), "canSelectMultiple" in e && n(3, c = e.canSelectMultiple), "isSelecting" in e && n(10, l = e.isSelecting), "toggleSelection" in e && n(4, a = e.toggleSelection) }, e.$$.update = () => { 512 & e.$$.dirty && n(6, d = o ? "grid" : "list"), 1024 & e.$$.dirty && n(7, p = "check-list" + (l ? "-checked" : "")) }, [i, r, s, c, a, u, d, p, f, o, l] } class wr extends mn { constructor(e) { super(), gn(this, e, _r, kr, mt, { headerText: 0, isList: 9, canChangeLayout: 1, changeLayout: 2, canSelectMultiple: 3, isSelecting: 10, toggleSelection: 4 }) } } function xr(e, t, n) { const i = e.slice(); return i[13] = t[n], i[15] = n, i } function Cr(e) { let t, n, i, o, r, s = [], c = new Map, l = -1 !== e[2] && jr(e), a = e[1]; const u = e => e[13].page; for (let t = 0; t < a.length; t += 1) { let n = xr(e, a, t), i = u(n); c.set(i, s[t] = Or(i, n)) } let f = e[0].more && Sr(e), d = -1 !== e[3] && Er(e); return { c() { t = xt("div"), l && l.c(), n = jt(); for (let e = 0; e < s.length; e += 1)s[e].c(); i = jt(), f && f.c(), o = jt(), d && d.c(), St(t, "class", "iif-pagination") }, m(e, c) { kt(e, t, c), l && l.m(t, null), bt(t, n); for (let e = 0; e < s.length; e += 1)s[e].m(t, null); bt(t, i), f && f.m(t, null), bt(t, o), d && d.m(t, null), r = !0 }, p(e, r) { -1 !== e[2] ? l ? (l.p(e, r), 4 & r && nn(l, 1)) : (l = jr(e), l.c(), nn(l, 1), l.m(t, n)) : l && (en(), on(l, 1, 1, (() => { l = null })), tn()), 2 & r && (a = e[1], s = cn(s, r, u, 1, e, a, c, t, rn, Or, i, xr)), e[0].more ? f ? f.p(e, r) : (f = Sr(e), f.c(), f.m(t, o)) : f && (f.d(1), f = null), -1 !== e[3] ? d ? (d.p(e, r), 8 & r && nn(d, 1)) : (d = Er(e), d.c(), nn(d, 1), d.m(t, null)) : d && (en(), on(d, 1, 1, (() => { d = null })), tn()) }, i(e) { r || (nn(l), nn(d), r = !0) }, o(e) { on(l), on(d), r = !1 }, d(e) { e && _t(t), l && l.d(); for (let e = 0; e < s.length; e += 1)s[e].d(); f && f.d(), d && d.d() } } } function jr(e) { let t, n, i, o, r; return n = new En({ props: { icon: "left", $$slots: { default: [Ir] }, $$scope: { ctx: e } } }), { c() { t = xt("a"), fn(n.$$.fragment), St(t, "href", "# "), St(t, "class", e[4] + "prev"), St(t, "title", xn.pagination.prev) }, m(s, c) { kt(s, t, c), dn(n, t, null), i = !0, o || (r = Pt(t, "click", Ot(e[8])), o = !0) }, p(e, t) { const i = {}; 65536 & t && (i.$$scope = { dirty: t, ctx: e }), n.$set(i) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n), o = !1, r() } } } function Ir(e) { let t; return { c() { t = Ct("<") }, m(e, n) { kt(e, t, n) }, d(e) { e && _t(t) } } } function Pr(e) { let t; return { c() { t = xt("span"), t.textContent = "..." }, m(e, n) { kt(e, t, n) }, d(e) { e && _t(t) } } } function Or(e, t) { let n, i, o, r, s, c, l, a, u = t[13].text + "", f = t[13].dot && Pr(); return { key: e, first: null, c() { n = It(), f && f.c(), i = jt(), o = xt("a"), r = Ct(u), St(o, "href", s = t[13].selected ? void 0 : "# "), St(o, "class", c = t[13].className), this.first = n }, m(e, s) { kt(e, n, s), f && f.m(e, s), kt(e, i, s), kt(e, o, s), bt(o, r), l || (a = Pt(o, "click", Ot((function () { gt(t[13].onClick) && t[13].onClick.apply(this, arguments) }))), l = !0) }, p(e, n) { (t = e)[13].dot ? f || (f = Pr(), f.c(), f.m(i.parentNode, i)) : f && (f.d(1), f = null), 2 & n && u !== (u = t[13].text + "") && Et(r, u), 2 & n && s !== (s = t[13].selected ? void 0 : "# ") && St(o, "href", s), 2 & n && c !== (c = t[13].className) && St(o, "class", c) }, d(e) { e && _t(n), f && f.d(e), e && _t(i), e && _t(o), l = !1, a() } } } function Sr(e) { let t, n, i, o, r = xn.icons.more + ""; return { c() { t = xt("a"), n = Ct(r), St(t, "href", "# "), St(t, "class", e[5]) }, m(r, s) { kt(r, t, s), bt(t, n), i || (o = Pt(t, "click", Ot(e[9])), i = !0) }, p: ut, d(e) { e && _t(t), i = !1, o() } } } function Er(e) { let t, n, i, o, r; return n = new En({ props: { icon: "right", $$slots: { default: [Mr] }, $$scope: { ctx: e } } }), { c() { t = xt("a"), fn(n.$$.fragment), St(t, "href", "# "), St(t, "class", e[4] + "next"), St(t, "title", xn.pagination.next) }, m(s, c) { kt(s, t, c), dn(n, t, null), i = !0, o || (r = Pt(t, "click", Ot(e[10])), o = !0) }, p(e, t) { const i = {}; 65536 & t && (i.$$scope = { dirty: t, ctx: e }), n.$set(i) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n), o = !1, r() } } } function Mr(e) { let t; return { c() { t = Ct(">") }, m(e, n) { kt(e, t, n) }, d(e) { e && _t(t) } } } function Tr(e) { let t, n, i = e[1].length > 0 && Cr(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { e[1].length > 0 ? i ? (i.p(e, n), 2 & n && nn(i, 1)) : (i = Cr(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } const Ar = "iif-page"; function Rr(e, t, n) { let { name: i } = t, { block: o } = t; const r = Bt("registry"); let s, c, l = []; function a(e) { r.router.action(i, e) } return e.$$set = e => { "name" in e && n(7, i = e.name), "block" in e && n(0, o = e.block) }, e.$$.update = () => { if (3 & e.$$.dirty) { const e = tt.showPagination(o); e.length ? (n(3, c = o.more || e[e.length - 1] > o.page ? o.page + 1 : -1), n(2, s = o.page > 0 ? o.page - 1 : -1), n(1, l = e.map(((t, n) => { const i = n > 0 && e[n - 1] < t - 1, r = t === o.page; return { selected: r, dot: i, page: t, text: t + 1 + "", className: r ? "iif-page iif-page--selected" : Ar, onClick: () => a(t) } })))) : l.length && (n(1, l = []), n(2, s = -1), n(3, c = -1)) } }, [o, l, s, c, "iif-page iif-page--arrow iif-page--", "iif-page iif-page--more", a, i, () => a(s), () => a("more"), () => a(c)] } class Fr extends mn { constructor(e) { super(), gn(this, e, Rr, Tr, mt, { name: 7, block: 0 }) } } function Lr(e) { let t, n; return t = new zn({ props: { type: "icons", $$slots: { default: [Br] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 33007 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Nr(e) { let t, n; return t = new mo({ props: { error: xn.errors.noIconsFound } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p: ut, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Br(e) { let t, n, i, o, r, s; return t = new wr({ props: { headerText: e[5], isList: e[6], canChangeLayout: e[8], changeLayout: e[9], canSelectMultiple: e[10], isSelecting: e[7], toggleSelection: e[11] } }), i = new dr({ props: { selection: e[1], blocks: e[2], route: e[0], isList: e[6], isSelecting: e[7] } }), r = new Fr({ props: { name: "pagination", block: e[3] } }), { c() { fn(t.$$.fragment), n = jt(), fn(i.$$.fragment), o = jt(), fn(r.$$.fragment) }, m(e, c) { dn(t, e, c), kt(e, n, c), dn(i, e, c), kt(e, o, c), dn(r, e, c), s = !0 }, p(e, n) { const o = {}; 32 & n && (o.headerText = e[5]), 64 & n && (o.isList = e[6]), 128 & n && (o.isSelecting = e[7]), t.$set(o); const s = {}; 2 & n && (s.selection = e[1]), 4 & n && (s.blocks = e[2]), 1 & n && (s.route = e[0]), 64 & n && (s.isList = e[6]), 128 & n && (s.isSelecting = e[7]), i.$set(s); const c = {}; 8 & n && (c.block = e[3]), r.$set(c) }, i(e) { s || (nn(t.$$.fragment, e), nn(i.$$.fragment, e), nn(r.$$.fragment, e), s = !0) }, o(e) { on(t.$$.fragment, e), on(i.$$.fragment, e), on(r.$$.fragment, e), s = !1 }, d(e) { pn(t, e), e && _t(n), pn(i, e), e && _t(o), pn(r, e) } } } function Vr(e) { let t, n, i, o; const r = [Nr, Lr], s = []; function c(e, t) { return e[4] ? 0 : 1 } return t = c(e), n = s[t] = r[t](e), { c() { n.c(), i = It() }, m(e, n) { s[t].m(e, n), kt(e, i, n), o = !0 }, p(e, [o]) { let l = t; t = c(e), t === l ? s[t].p(e, o) : (en(), on(s[l], 1, 1, (() => { s[l] = null })), tn(), n = s[t], n ? n.p(e, o) : (n = s[t] = r[t](e), n.c()), nn(n, 1), n.m(i.parentNode, i)) }, i(e) { o || (nn(n), o = !0) }, o(e) { on(n), o = !1 }, d(e) { s[t].d(e), e && _t(i) } } } function Dr(e, t, n) { let { route: i } = t, { selection: o } = t, { blocks: r } = t; const s = Bt("registry"), c = s.config.components; let l, a, u; const f = c.toggleList; let d = c.list; const p = c.multiSelect; let h = !1; return e.$$set = e => { "route" in e && n(0, i = e.route), "selection" in e && n(1, o = e.selection), "blocks" in e && n(2, r = e.blocks) }, e.$$.update = () => { 4 & e.$$.dirty && n(3, l = r.pagination), 28 & e.$$.dirty && (n(4, a = !l || !r.icons || r.icons.icons.length < 1), a || n(5, u = function () { const e = l.length, t = xn.icons; return l.more && e > 0 ? t.header.full : void 0 !== t.headerWithCount[e] ? t.headerWithCount[e] : t.header.full }().replace("{count}", l.length + ""))) }, [i, o, r, l, a, u, d, h, f, function () { f && (n(6, d = c.list = !c.list), s.callback({ type: "config" })) }, p, function () { n(7, h = !h) }] } class zr extends mn { constructor(e) { super(), gn(this, e, Dr, Vr, mt, { route: 0, selection: 1, blocks: 2 }) } } function qr(e) { let t, n; return t = new Nn({ props: { type: "text", value: e[1].keyword, onInput: e[3], placeholder: e[2], icon: "search", autofocus: false } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.value = e[1].keyword), 4 & n && (i.placeholder = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ur(e) { let t, n; return t = new zn({ props: { type: "search", name: e[0], extra: "search-form", $$slots: { default: [qr] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 1 & n && (i.name = e[0]), 262 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Hr(e, t, n) { let { name: i } = t, { block: o } = t, { info: r = null } = t, { customType: s = "" } = t; const c = Bt("registry"), l = xn.search; let a; return e.$$set = e => { "name" in e && n(0, i = e.name), "block" in e && n(1, o = e.block), "info" in e && n(4, r = e.info), "customType" in e && n(5, s = e.customType) }, e.$$.update = () => { 48 & e.$$.dirty && ("" !== s && void 0 !== l.placeholder[s] ? n(2, a = l.placeholder[s]) : r && r.name && void 0 !== l.placeholder.collection ? n(2, a = l.placeholder.collection.replace("{name}", r.name)) : n(2, a = l.defaultPlaceholder)) }, [i, o, a, function (e) { c.router.action(i, e.trim().toLowerCase()) }, r, s] } class Kr extends mn { constructor(e) { super(), gn(this, e, Hr, Ur, mt, { name: 0, block: 1, info: 4, customType: 5 }) } } function Gr(e, t, n) { const i = e.slice(); return i[9] = t[n], i[11] = n, i } function Jr(e) { let t, n, i; return n = new zi({ props: { name: "collections", parent: e[2].parent ? e[2].parent.type : "collections", link: e[6], block: e[1].collections } }), { c() { t = xt("div"), fn(n.$$.fragment), St(t, "class", "iff-filters") }, m(e, o) { kt(e, t, o), dn(n, t, null), i = !0 }, p(e, t) { const i = {}; 4 & t && (i.parent = e[2].parent ? e[2].parent.type : "collections"), 64 & t && (i.link = e[6]), 2 & t && (i.block = e[1].collections), n.$set(i) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n) } } } function Wr(e) { let t, n; return t = new Do({ props: { name: "info", block: e[1].info } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.block = e[1].info), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Qr(e) { let t, n, i = [], o = new Map, r = e[7]; const s = e => e[9].key; for (let t = 0; t < r.length; t += 1) { let n = Gr(e, r, t), c = s(n); o.set(c, i[t] = Yr(c, n)) } return { c() { t = xt("div"); for (let e = 0; e < i.length; e += 1)i[e].c(); St(t, "class", "iff-filters") }, m(e, o) { kt(e, t, o); for (let e = 0; e < i.length; e += 1)i[e].m(t, null); n = !0 }, p(e, n) { 128 & n && (r = e[7], en(), i = cn(i, n, s, 1, e, r, o, t, sn, Yr, null, Gr), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { e && _t(t); for (let e = 0; e < i.length; e += 1)i[e].d() } } } function Yr(e, t) { let n, i, o; return i = new zi({ props: { name: t[9].key, block: t[9].item } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 128 & n && (o.name = t[9].key), 128 & n && (o.block = t[9].item), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function Xr(e) { let t, n, i, o, r, s, c, l, a, u = e[1].collections && Jr(e), f = null !== e[5] && Wr(e); o = new Kr({ props: { name: "filter", block: e[1].filter, info: e[5] } }); let d = e[7].length > 0 && Qr(e); return c = new zr({ props: { blocks: e[1], selection: e[0], route: e[2] } }), { c() { t = xt("div"), u && u.c(), n = jt(), f && f.c(), i = jt(), fn(o.$$.fragment), r = jt(), d && d.c(), s = jt(), fn(c.$$.fragment), St(t, "class", l = "iif-view " + Zr + "\r\n\t\t" + Zr + "--prefix--" + e[4] + ("" === e[3] ? "" : " " + Zr + "--provider--" + e[3])) }, m(e, l) { kt(e, t, l), u && u.m(t, null), bt(t, n), f && f.m(t, null), bt(t, i), dn(o, t, null), bt(t, r), d && d.m(t, null), bt(t, s), dn(c, t, null), a = !0 }, p(e, [r]) { e[1].collections ? u ? (u.p(e, r), 2 & r && nn(u, 1)) : (u = Jr(e), u.c(), nn(u, 1), u.m(t, n)) : u && (en(), on(u, 1, 1, (() => { u = null })), tn()), null !== e[5] ? f ? (f.p(e, r), 32 & r && nn(f, 1)) : (f = Wr(e), f.c(), nn(f, 1), f.m(t, i)) : f && (en(), on(f, 1, 1, (() => { f = null })), tn()); const p = {}; 2 & r && (p.block = e[1].filter), 32 & r && (p.info = e[5]), o.$set(p), e[7].length > 0 ? d ? (d.p(e, r), 128 & r && nn(d, 1)) : (d = Qr(e), d.c(), nn(d, 1), d.m(t, s)) : d && (en(), on(d, 1, 1, (() => { d = null })), tn()); const h = {}; 2 & r && (h.blocks = e[1]), 1 & r && (h.selection = e[0]), 4 & r && (h.route = e[2]), c.$set(h), (!a || 24 & r && l !== (l = "iif-view " + Zr + "\r\n\t\t" + Zr + "--prefix--" + e[4] + ("" === e[3] ? "" : " " + Zr + "--provider--" + e[3]))) && St(t, "class", l) }, i(e) { a || (nn(u), nn(f), nn(o.$$.fragment, e), nn(d), nn(c.$$.fragment, e), a = !0) }, o(e) { on(u), on(f), on(o.$$.fragment, e), on(d), on(c.$$.fragment, e), a = !1 }, d(e) { e && _t(t), u && u.d(), f && f.d(), pn(o), d && d.d(), pn(c) } } } const Zr = "iif-view--collection"; function es(e, t, n) { let { selection: i } = t, { blocks: o } = t, { route: r } = t; const s = ["tags", "themePrefixes", "themeSuffixes"]; let c, l, a, u, f; return e.$$set = e => { "selection" in e && n(0, i = e.selection), "blocks" in e && n(1, o = e.blocks), "route" in e && n(2, r = e.route) }, e.$$.update = () => { if (14 & e.$$.dirty) { n(3, c = r.params.provider), "string" != typeof c && n(3, c = ""), n(4, l = r.params.prefix), n(5, a = null === o.info ? null : o.info.info); const e = tt.getProvider(c); n(6, u = e ? e.links.collection : "") } 2 & e.$$.dirty && n(7, f = s.filter((e => !!o[e])).map((e => ({ key: e, item: o[e] })))) }, [i, o, r, c, l, a, u, f] } class ts extends mn { constructor(e) { super(), gn(this, e, es, Xr, mt, { selection: 0, blocks: 1, route: 2 }) } } function ns(e) { let t, n; return t = new zi({ props: { name: "collections", block: e[2].collections, link: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 4 & n && (i.block = e[2].collections), 8 & n && (i.link = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function is(e) { let t, n, i, o, r = e[2].collections && ns(e); return i = new zr({ props: { blocks: e[2], selection: e[1], route: e[0] } }), { c() { t = xt("div"), r && r.c(), n = jt(), fn(i.$$.fragment), St(t, "class", "iif-view iif-view--search") }, m(e, s) { kt(e, t, s), r && r.m(t, null), bt(t, n), dn(i, t, null), o = !0 }, p(e, [o]) { e[2].collections ? r ? (r.p(e, o), 4 & o && nn(r, 1)) : (r = ns(e), r.c(), nn(r, 1), r.m(t, n)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()); const s = {}; 4 & o && (s.blocks = e[2]), 2 & o && (s.selection = e[1]), 1 & o && (s.route = e[0]), i.$set(s) }, i(e) { o || (nn(r), nn(i.$$.fragment, e), o = !0) }, o(e) { on(r), on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(t), r && r.d(), pn(i) } } } function os(e, t, n) { let i, { route: o } = t, { selection: r } = t, { blocks: s } = t; return e.$$set = e => { "route" in e && n(0, o = e.route), "selection" in e && n(1, r = e.selection), "blocks" in e && n(2, s = e.blocks) }, e.$$.update = () => { if (1 & e.$$.dirty) { let e = o.params.provider; "string" != typeof e && (e = ""); const t = tt.getProvider(e); n(3, i = t ? t.links.collection : "") } }, [o, r, s, i] } class rs extends mn { constructor(e) { super(), gn(this, e, os, is, mt, { route: 0, selection: 1, blocks: 2 }) } } function ss(e) { let t, n, i, o, r, s; return n = new Kr({ props: { name: "filter", block: e[2].filter, customType: e[0].params.customType } }), o = new zr({ props: { blocks: e[2], selection: e[1], route: e[0] } }), { c() { t = xt("div"), fn(n.$$.fragment), i = jt(), fn(o.$$.fragment), St(t, "class", r = "iif-view iif-view--custom iif-view--custom--" + e[0].params.customType) }, m(e, r) { kt(e, t, r), dn(n, t, null), bt(t, i), dn(o, t, null), s = !0 }, p(e, [i]) { const c = {}; 4 & i && (c.block = e[2].filter), 1 & i && (c.customType = e[0].params.customType), n.$set(c); const l = {}; 4 & i && (l.blocks = e[2]), 2 & i && (l.selection = e[1]), 1 & i && (l.route = e[0]), o.$set(l), (!s || 1 & i && r !== (r = "iif-view iif-view--custom iif-view--custom--" + e[0].params.customType)) && St(t, "class", r) }, i(e) { s || (nn(n.$$.fragment, e), nn(o.$$.fragment, e), s = !0) }, o(e) { on(n.$$.fragment, e), on(o.$$.fragment, e), s = !1 }, d(e) { e && _t(t), pn(n), pn(o) } } } function cs(e, t, n) { let { route: i } = t, { selection: o } = t, { blocks: r } = t; return e.$$set = e => { "route" in e && n(0, i = e.route), "selection" in e && n(1, o = e.selection), "blocks" in e && n(2, r = e.blocks) }, [i, o, r] } class ls extends mn { constructor(e) { super(), gn(this, e, cs, ss, mt, { route: 0, selection: 1, blocks: 2 }) } } function as(e, t, n) { const i = e.slice(); return i[7] = t[n], i } function us(e) { let t, n, i, o, r; return { c() { t = xt("br"), n = jt(), i = xt("a"), i.textContent = `${e[3].custom.home}`, St(i, "href", "# ") }, m(s, c) { kt(s, t, c), kt(s, n, c), kt(s, i, c), o || (r = Pt(i, "click", Ot(e[4])), o = !0) }, p: ut, d(e) { e && _t(t), e && _t(n), e && _t(i), o = !1, r() } } } function fs(e) { let t, n, i, o, r, s, c; t = new En({ props: { icon: "error-" + e[7] } }); let l = e[2] && us(e); return { c() { fn(t.$$.fragment), n = jt(), i = xt("p"), o = Ct(e[1]), r = jt(), l && l.c(), s = jt() }, m(e, a) { dn(t, e, a), kt(e, n, a), kt(e, i, a), bt(i, o), bt(i, r), l && l.m(i, null), kt(e, s, a), c = !0 }, p(e, n) { const r = {}; 1 & n && (r.icon = "error-" + e[7]), t.$set(r), (!c || 2 & n) && Et(o, e[1]), e[2] ? l ? l.p(e, n) : (l = us(e), l.c(), l.m(i, null)) : l && (l.d(1), l = null) }, i(e) { c || (nn(t.$$.fragment, e), c = !0) }, o(e) { on(t.$$.fragment, e), c = !1 }, d(e) { pn(t, e), e && _t(n), e && _t(i), l && l.d(), e && _t(s) } } } function ds(e, t) { let n, i, o; return i = new zn({ props: { type: "error", extra: "error--" + t[7], $$slots: { default: [fs] }, $$scope: { ctx: t } } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 1 & n && (o.extra = "error--" + t[7]), 1031 & n && (o.$$scope = { dirty: n, ctx: t }), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function ps(e) { let t, n, i = [], o = new Map, r = [e[0]]; const s = e => e[7]; for (let t = 0; t < 1; t += 1) { let n = as(e, r, t), c = s(n); o.set(c, i[t] = ds(c, n)) } return { c() { for (let e = 0; e < 1; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < 1; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, [n]) { 31 & n && (r = [e[0]], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, ds, t, as), tn()) }, i(e) { if (!n) { for (let e = 0; e < 1; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < 1; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < 1; t += 1)i[t].d(e); e && _t(t) } } } function hs(e, t, n) { let { error: i } = t, { route: o } = t; const r = Bt("registry"), s = xn.errors; let c, l; return e.$$set = e => { "error" in e && n(0, i = e.error), "route" in e && n(5, o = e.route) }, e.$$.update = () => { if (35 & e.$$.dirty) switch (n(2, l = !(!o || !("collections" !== o.type || o.parent || o.params && o.params.provider) || void 0 === s.custom.home)), n(1, c = void 0 === s.custom[i] ? s.defaultError : s.custom[i]), i) { case "not_found": n(1, c = c.replace("{prefix}", o && "collection" === o.type ? '"' + o.params.prefix + '"' : "")); break; case "bad_route": n(2, l = void 0 !== s.custom.home) } }, [i, c, l, s, function () { const e = r.router; o && "collections" === o.type ? e.home("") : e.home() }, o] } class gs extends mn { constructor(e) { super(), gn(this, e, hs, ps, mt, { error: 0, route: 5 }) } } function ms(e) { let t, n; return t = new Pi({ props: { providers: e[6], activeProvider: e[9] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 64 & n && (i.providers = e[6]), 512 & n && (i.activeProvider = e[9]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ys(e) { let t, n; return t = new Jn({ props: { viewChanged: e[1], route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.viewChanged = e[1]), 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function $s(e) { let t, n; return t = new oi({ props: { route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function vs(e) { let t, n, i, o; const r = [Cs, xs, ws, _s, ks, bs], s = []; function c(e, t) { return "" === e[2] && e[3] ? "collections" === e[3].type ? 1 : "collection" === e[3].type ? 2 : "search" === e[3].type ? 3 : "custom" === e[3].type ? 4 : 5 : 0 } return t = c(e), n = s[t] = r[t](e), { c() { n.c(), i = It() }, m(e, n) { s[t].m(e, n), kt(e, i, n), o = !0 }, p(e, o) { let l = t; t = c(e), t === l ? s[t].p(e, o) : (en(), on(s[l], 1, 1, (() => { s[l] = null })), tn(), n = s[t], n ? n.p(e, o) : (n = s[t] = r[t](e), n.c()), nn(n, 1), n.m(i.parentNode, i)) }, i(e) { o || (nn(n), o = !0) }, o(e) { on(n), o = !1 }, d(e) { s[t].d(e), e && _t(i) } } } function bs(e) { let t, n; return t = new gs({ props: { error: "bad_route", route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ks(e) { let t, n; return t = new ls({ props: { route: e[3], blocks: e[4], selection: e[0] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), 16 & n && (i.blocks = e[4]), 1 & n && (i.selection = e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function _s(e) { let t, n; return t = new rs({ props: { route: e[3], blocks: e[4], selection: e[0] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), 16 & n && (i.blocks = e[4]), 1 & n && (i.selection = e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ws(e) { let t, n; return t = new ts({ props: { route: e[3], blocks: e[4], selection: e[0] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), 16 & n && (i.blocks = e[4]), 1 & n && (i.selection = e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function xs(e) { let t, n; return t = new Io({ props: { route: e[3], blocks: e[4] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), 16 & n && (i.blocks = e[4]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Cs(e) { let t, n; return t = new gs({ props: { error: "" !== e[2] ? e[2] : "bad_route", route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 4 & n && (i.error = "" !== e[2] ? e[2] : "bad_route"), 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function js(e) { let t, n, i, o, r, s = e[8] && ms(e), c = e[5] && ys(e), l = e[3]?.parent && $s(e), a = (!e[3] || "empty" !== e[3].type) && vs(e); return { c() { t = xt("div"), s && s.c(), n = jt(), c && c.c(), i = jt(), l && l.c(), o = jt(), a && a.c(), St(t, "class", e[7]) }, m(e, u) { kt(e, t, u), s && s.m(t, null), bt(t, n), c && c.m(t, null), bt(t, i), l && l.m(t, null), bt(t, o), a && a.m(t, null), r = !0 }, p(e, [u]) { e[8] ? s ? (s.p(e, u), 256 & u && nn(s, 1)) : (s = ms(e), s.c(), nn(s, 1), s.m(t, n)) : s && (en(), on(s, 1, 1, (() => { s = null })), tn()), e[5] ? c ? (c.p(e, u), 32 & u && nn(c, 1)) : (c = ys(e), c.c(), nn(c, 1), c.m(t, i)) : c && (en(), on(c, 1, 1, (() => { c = null })), tn()), e[3]?.parent ? l ? (l.p(e, u), 8 & u && nn(l, 1)) : (l = $s(e), l.c(), nn(l, 1), l.m(t, o)) : l && (en(), on(l, 1, 1, (() => { l = null })), tn()), e[3] && "empty" === e[3].type ? a && (en(), on(a, 1, 1, (() => { a = null })), tn()) : a ? (a.p(e, u), 8 & u && nn(a, 1)) : (a = vs(e), a.c(), nn(a, 1), a.m(t, null)), (!r || 128 & u) && St(t, "class", e[7]) }, i(e) { r || (nn(s), nn(c), nn(l), nn(a), r = !0) }, o(e) { on(s), on(c), on(l), on(a), r = !1 }, d(e) { e && _t(t), s && s.d(), c && c.d(), l && l.d(), a && a.d() } } } const Is = "iif-content"; function Ps(e, t, n) { let i, o, { selection: r } = t, { viewChanged: s } = t, { error: c } = t, { route: l } = t, { blocks: a } = t, u = false; return e.$$set = e => { "selection" in e && n(0, r = e.selection), "viewChanged" in e && n(1, s = e.viewChanged), "error" in e && n(2, c = e.error), "route" in e && n(3, l = e.route), "blocks" in e && n(4, a = e.blocks) }, e.$$.update = () => { if (140 & e.$$.dirty && (n(7, i = Is), "" !== c ? n(7, i += " iif-content--error iif-content--error--" + c) : (n(7, i += " iif-content--view iif-content--view--" + l.type), l.params && ("search" === l.type || "collections" === l.type || "collection" === l.type) && l.params.provider && n(7, i += " iif-content--view--" + l.type + "--provider--" + l.params.provider), "collection" === l.type ? n(7, i += " iif-content--view--collection--prefix--" + l.params.prefix) : "custom" === l.type && n(7, i += " iif-content--view--custom--" + l.params.customType))), 40 & e.$$.dirty) { n(5, o = !1); let e = l; for (; !o && e;)"collections" === e.type ? n(5, o = !0) : e = e.parent } 72 & e.$$.dirty && n(8, u = !1) }, [r, s, c, l, a, o, [""], i, u, ""] } class Os extends mn { constructor(e) { super(), gn(this, e, Ps, js, mt, { selection: 0, viewChanged: 1, error: 2, route: 3, blocks: 4 }) } } function Ss(e, t, n) { const i = e.slice(); return i[11] = t[n], i[13] = n, i } function Es(e) { let t, n; return t = new En({ props: { icon: e[11].icon } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.icon = e[11].icon), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ms(e, t) { let n, i, o, r, s, c, l, a, u = t[3](t[11]).replace("{icon}", t[2]).replace("{count}", t[0].length + "") + "", f = t[11].icon && Es(t); function d() { return t[6](t[11]) } return { key: e, first: null, c() { n = xt("button"), f && f.c(), i = jt(), o = Ct(u), r = jt(), St(n, "class", s = t[11].className), this.first = n }, m(e, t) { kt(e, n, t), f && f.m(n, null), bt(n, i), bt(n, o), bt(n, r), c = !0, l || (a = Pt(n, "click", Ot(d)), l = !0) }, p(e, r) { (t = e)[11].icon ? f ? (f.p(t, r), 2 & r && nn(f, 1)) : (f = Es(t), f.c(), nn(f, 1), f.m(n, i)) : f && (en(), on(f, 1, 1, (() => { f = null })), tn()), (!c || 7 & r) && u !== (u = t[3](t[11]).replace("{icon}", t[2]).replace("{count}", t[0].length + "") + "") && Et(o, u), (!c || 2 & r && s !== (s = t[11].className)) && St(n, "class", s) }, i(e) { c || (nn(f), c = !0) }, o(e) { on(f), c = !1 }, d(e) { e && _t(n), f && f.d(), l = !1, a() } } } function Ts(e) { let t, n, i = [], o = new Map, r = e[1]; const s = e => e[11].key; for (let t = 0; t < r.length; t += 1) { let n = Ss(e, r, t), c = s(n); o.set(c, i[t] = Ms(c, n)) } return { c() { t = xt("div"); for (let e = 0; e < i.length; e += 1)i[e].c(); St(t, "class", "iif-footer-buttons") }, m(e, o) { kt(e, t, o); for (let e = 0; e < i.length; e += 1)i[e].m(t, null); n = !0 }, p(e, [n]) { 31 & n && (r = e[1], en(), i = cn(i, n, s, 1, e, r, o, t, sn, Ms, null, Ss), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { e && _t(t); for (let e = 0; e < i.length; e += 1)i[e].d() } } } const As = "iif-form-button"; function Rs(e, t, n) { let { icons: i } = t, { route: o } = t; const r = Bt("registry"), s = xn.footerButtons; function c(e, t) { return { key: e, button: t, registry: r, icons: i, route: o } } const l = Object.keys(wn).map((e => { const t = wn[e]; return Object.assign(Object.assign({}, t), { key: e, className: As + (t.type ? " iif-form-button--" + t.type : "") + (t.icon ? " iif-form-button--with-icon" : "") }) })); let a, u; function f(e) { r.callback({ type: "button", button: e }) } return e.$$set = e => { "icons" in e && n(0, i = e.icons), "route" in e && n(5, o = e.route) }, e.$$.update = () => { if (1 & e.$$.dirty) { const e = i.length; n(1, a = l.filter((t => { const n = t.display; switch (n) { case void 0: case "always": return !0; case "empty": return 0 === e; case "icons": return e > 0; case "one-icon": return 1 === e; case "many-icons": return e > 1; default: if ("function" == typeof n) return n(c(t.key, t)) } }))), n(2, u = e > 0 ? tt.iconToString(i[0]) : "icon") } }, [i, a, u, function (e) { if ("function" == typeof e.text) return e.text(c(e.key, e)); if ("string" == typeof e.text) return e.text; const t = e.key; return "string" == typeof s[t] ? s[t] : t.split("-").map((e => e.slice(0, 1).toUpperCase() + e.slice(1))).join(" ") }, f, o, e => f(e.key)] } class Fs extends mn { constructor(e) { super(), gn(this, e, Rs, Ts, mt, { icons: 0, route: 5 }) } } function Ls(e) { let t, n, i, o = !e[1] && Ns(); let r = function (e, t) { return e[3] ? Vs : Bs }(e)(e); return { c() { t = xt("p"), o && o.c(), n = jt(), r.c(), St(t, "class", "iif-footer-block-title") }, m(e, s) { kt(e, t, s), o && o.m(t, null), bt(t, n), r.m(t, null), i = !0 }, p(e, i) { e[1] ? o && (en(), on(o, 1, 1, (() => { o = null })), tn()) : o ? 2 & i && nn(o, 1) : (o = Ns(), o.c(), nn(o, 1), o.m(t, n)), r.p(e, i) }, i(e) { i || (nn(o), i = !0) }, o(e) { on(o), i = !1 }, d(e) { e && _t(t), o && o.d(), r.d() } } } function Ns(e) { let t, n; return t = new En({ props: { icon: "expand" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Bs(e) { let t, n = e[0] + ":"; return { c() { t = Ct(n) }, m(e, n) { kt(e, t, n) }, p(e, i) { 1 & i && n !== (n = e[0] + ":") && Et(t, n) }, d(e) { e && _t(t) } } } function Vs(e) { let t, n, i, o, r = e[0] + (e[1] ? ":" : ""); return { c() { t = xt("a"), n = Ct(r), St(t, "href", "# ") }, m(r, s) { kt(r, t, s), bt(t, n), i || (o = Pt(t, "click", Ot(e[4])), i = !0) }, p(e, t) { 3 & t && r !== (r = e[0] + (e[1] ? ":" : "")) && Et(n, r) }, d(e) { e && _t(t), i = !1, o() } } } function Ds(e) { let t; const n = e[7].default, i = yt(n, e, e[6], null); return { c() { i && i.c() }, m(e, n) { i && i.m(e, n), t = !0 }, p(e, o) { i && i.p && (!t || 64 & o) && vt(i, n, e, e[6], o, null, null) }, i(e) { t || (nn(i, e), t = !0) }, o(e) { on(i, e), t = !1 }, d(e) { i && i.d(e) } } } function zs(e) { let t, n, i, o = "" !== e[0] && Ls(e), r = e[1] && Ds(e); return { c() { t = xt("div"), o && o.c(), n = jt(), r && r.c(), St(t, "class", e[2]) }, m(e, s) { kt(e, t, s), o && o.m(t, null), bt(t, n), r && r.m(t, null), i = !0 }, p(e, [s]) { "" !== e[0] ? o ? (o.p(e, s), 1 & s && nn(o, 1)) : (o = Ls(e), o.c(), nn(o, 1), o.m(t, n)) : o && (en(), on(o, 1, 1, (() => { o = null })), tn()), e[1] ? r ? (r.p(e, s), 2 & s && nn(r, 1)) : (r = Ds(e), r.c(), nn(r, 1), r.m(t, null)) : r && (en(), on(r, 1, 1, (() => { r = null })), tn()), (!i || 4 & s) && St(t, "class", e[2]) }, i(e) { i || (nn(o), nn(r), i = !0) }, o(e) { on(o), on(r), i = !1 }, d(e) { e && _t(t), o && o.d(), r && r.d() } } } const qs = "iif-footer-block"; function Us(e, t, n) { let { $$slots: i = {}, $$scope: o } = t, { name: r } = t, { title: s } = t, c = r + "Visible"; const l = Bt("registry"), a = l.config.components; let u, f = !0; return e.$$set = e => { "name" in e && n(5, r = e.name), "title" in e && n(0, s = e.title), "$$scope" in e && n(6, o = e.$$scope) }, e.$$.update = () => { 34 & e.$$.dirty && n(2, u = qs + " " + qs + "--" + r + " " + qs + "--" + (f ? "expanded" : "collapsed")) }, [s, f, u, false, function () { n(1, f = a[c] = !f), l.callback({ type: "config" }) }, r, o, i] } class Hs extends mn { constructor(e) { super(), gn(this, e, Us, zs, mt, { name: 5, title: 0 }) } } var Ks = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.extendedColorKeywords = t.baseColorKeywords = void 0, t.baseColorKeywords = { silver: [192, 192, 192], gray: [128, 128, 128], white: [255, 255, 255], maroon: [128, 0, 0], red: [255, 0, 0], purple: [128, 0, 128], fuchsia: [255, 0, 255], green: [0, 128, 0], lime: [0, 255, 0], olive: [128, 128, 0], yellow: [255, 255, 0], navy: [0, 0, 128], blue: [0, 0, 255], teal: [0, 128, 128], aqua: [0, 255, 255] }, t.extendedColorKeywords = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50], rebeccapurple: [102, 51, 153] } })), Gs = ve((function (e, t) { function n(e) { return { r: e[0], g: e[1], b: e[2], a: 1 } } Object.defineProperty(t, "__esModule", { value: !0 }), t.colorToString = t.stringToColor = void 0, t.stringToColor = function (e) { if (e = e.toLowerCase(), void 0 !== Ks.baseColorKeywords[e]) return n(Ks.baseColorKeywords[e]); if (void 0 !== Ks.extendedColorKeywords[e]) return n(Ks.extendedColorKeywords[e]); if (-1 === e.indexOf("(")) return function (e) { if ("#" === e.slice(0, 1) && (e = e.slice(1)), !/^[\da-f]+$/i.test(e)) return null; let t, n, i, o = "", r = 0; switch (e.length) { case 4: o = e.slice(-1), o += o; case 3: t = e.slice(r, ++r), t += t, n = e.slice(r, ++r), n += n, i = e.slice(r, ++r), i += i; break; case 8: o = e.slice(-2); case 6: t = e.slice(r++, ++r), n = e.slice(r++, ++r), i = e.slice(r++, ++r); break; default: return null }return { r: parseInt(t, 16), g: parseInt(n, 16), b: parseInt(i, 16), a: "" === o ? 1 : parseInt(o, 16) / 255 } }(e); if (")" !== (e = e.replace(/\s+/g, "")).slice(-1)) return null; const t = (e = e.slice(0, e.length - 1)).split("("); if (2 !== t.length || /[^\d.,%-]/.test(t[1])) return null; const i = t[0], o = t[1].split(","); if (3 !== o.length && 4 !== o.length) return null; let r, s, c, l, a, u = 1; if (4 === o.length) { const e = o.pop(); if (u = parseFloat(e) * ("%" === e.slice(-1) ? .01 : 1), isNaN(u)) return null; u = u < 0 ? 0 : u > 1 ? 1 : u } switch (i) { case "rgb": case "rgba": return l = "%" === o[0].slice(-1), "%" === o[1].slice(-1) !== l || "%" === o[2].slice(-1) !== l ? null : (a = l ? 2.55 : 1, r = parseFloat(o[0]) * a, s = parseFloat(o[1]) * a, c = parseFloat(o[2]) * a, { r: isNaN(r) || r < 0 ? 0 : r > 255 ? 255 : r, g: isNaN(s) || s < 0 ? 0 : s > 255 ? 255 : s, b: isNaN(c) || c < 0 ? 0 : c > 255 ? 255 : c, a: u }); case "hsl": case "hsla": return -1 !== o[0].indexOf("%") || "%" !== o[1].slice(-1) || "%" !== o[2].slice(-1) ? null : (r = parseFloat(o[0]), s = parseFloat(o[1]), c = parseFloat(o[2]), { h: isNaN(r) ? 0 : r < 0 ? r % 360 + 360 : r >= 360 ? r % 360 : r, s: isNaN(s) || s < 0 ? 0 : s > 100 ? 100 : s, l: isNaN(c) || c < 0 ? 0 : c > 100 ? 100 : c, a: u }) }return null }, t.colorToString = function (e) { let t; try { t = void 0 !== e.r ? e : function (e, t = !1) { function n(e, t, n) { return (n = n < 0 ? n % 360 + 360 : n >= 360 ? n % 360 : n) >= 240 ? e : n < 60 ? e + (t - e) * n / 60 : n < 180 ? t : e + (t - e) * (240 - n) / 60 } const i = e.h < 0 ? e.h % 360 + 360 : e.h >= 360 ? e.h % 360 : e.h, o = e.s < 0 ? 0 : e.s > 100 ? 1 : e.s / 100, r = e.l < 0 ? 0 : e.l > 100 ? 1 : e.l / 100; let s; s = r <= .5 ? r * (1 + o) : r + o * (1 - r); const c = 2 * r - s; let l, a, u; return 0 === o && 0 === i ? (l = r, a = r, u = r) : (l = n(c, s, i + 120), a = n(c, s, i), u = n(c, s, i - 120)), { r: t ? Math.round(255 * l) : 255 * l, g: t ? Math.round(255 * a) : 255 * a, b: t ? Math.round(255 * u) : 255 * u, a: e.a } }(e) } catch (e) { return "" } const n = t.r === Math.round(t.r) && t.g === Math.round(t.g) && t.b === Math.round(t.b); if (n && 1 === e.a) { const e = function (e) { const t = [Ks.baseColorKeywords, Ks.extendedColorKeywords]; for (let n = 0; n < t.length; n++) { const i = t[n], o = Object.keys(i); let r; for (; void 0 !== (r = o.shift());) { const t = i[r]; if (t[0] === e.r && t[1] === e.g && t[2] === e.b) return r } } return null }(t); if ("string" == typeof e) return e; let n = "", i = !0; try { ["r", "g", "b"].forEach((e => { const o = t[e]; if (o < 0 || o > 255) throw new Error("Invalid color"); const r = (o < 16 ? "0" : "") + o.toString(16); n += r, i = i && r[0] === r[1] })) } catch (e) { return "" } return "#" + (i ? n[0] + n[2] + n[4] : n) } if (!n && void 0 !== e.h) { const t = e, n = []; try { let e = t.h % 360; for (; e < 0;)e += 360; n.push(e + ""), ["s", "l"].forEach((e => { const i = t[e]; if (i < 0 || i > 100) throw new Error("Invalid color"); n.push(i + "%") })) } catch (e) { return "" } return 1 !== t.a && n.push(t.a + ""), (1 === t.a ? "hsl(" : "hsla(") + n.join(", ") + ")" } const i = []; try { ["r", "g", "b"].forEach((e => { const n = t[e]; if (n < 0 || n > 255) throw new Error("Invalid color"); i.push(n + "") })) } catch (e) { return "" } return 1 !== t.a && i.push(t.a + ""), (1 === t.a ? "rgb(" : "rgba(") + i.join(", ") + ")" } })); function Js(e) { let t, n, i, o, r, s, c; const l = e[3].default, a = yt(l, e, e[2], null); return { c() { t = xt("div"), n = xt("p"), i = Ct(e[1]), o = jt(), r = xt("div"), a && a.c(), St(t, "class", s = Ws + " " + Ws + "--" + e[0]) }, m(e, s) { kt(e, t, s), bt(t, n), bt(n, i), bt(t, o), bt(t, r), a && a.m(r, null), c = !0 }, p(e, [n]) { (!c || 2 & n) && Et(i, e[1]), a && a.p && (!c || 4 & n) && vt(a, l, e, e[2], n, null, null), (!c || 1 & n && s !== (s = Ws + " " + Ws + "--" + e[0])) && St(t, "class", s) }, i(e) { c || (nn(a, e), c = !0) }, o(e) { on(a, e), c = !1 }, d(e) { e && _t(t), a && a.d(e) } } } const Ws = "iif-footer-options-block"; function Qs(e, t, n) { let i, { $$slots: o = {}, $$scope: r } = t, { type: s } = t; return e.$$set = e => { "type" in e && n(0, s = e.type), "$$scope" in e && n(2, r = e.$$scope) }, e.$$.update = () => { if (1 & e.$$.dirty) { const e = xn.footerBlocks; n(1, i = void 0 === e[s] ? s.split(" ").map((e => e.slice(0, 1).toUpperCase() + e.slice(1))).join(" ") : e[s]) } }, [s, i, r, o] } class Ys extends mn { constructor(e) { super(), gn(this, e, Qs, Js, mt, { type: 0 }) } } function Xs(e) { let t, n; return t = new Ys({ props: { type: "color", $$slots: { default: [Zs] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2053 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Zs(e) { let t, n; return t = new Nn({ props: { value: e[2], placeholder: bn, title: e[3], onInput: e[4], onBlur: e[5], icon: void 0 === e[0] || "" === e[0] ? "color" : "color-filled", extra: void 0 === e[0] ? "" : e[0], type: "color" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 4 & n && (i.value = e[2]), 1 & n && (i.icon = void 0 === e[0] || "" === e[0] ? "color" : "color-filled"), 1 & n && (i.extra = void 0 === e[0] ? "" : e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ec(e) { let t, n, i = e[1] && Xs(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { e[1] ? i ? (i.p(e, n), 2 & n && nn(i, 1)) : (i = Xs(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function tc(e, t, n) { var i; let o, { icons: r } = t, { value: s } = t, { customise: c } = t; const l = xn.footerBlocks.color; let a = s, u = s; return e.$$set = e => { "icons" in e && n(6, r = e.icons), "value" in e && n(0, s = e.value), "customise" in e && n(7, c = e.customise) }, e.$$.update = () => { if (320 & e.$$.dirty) { n(1, o = !1); for (let e = 0; e < r.length; e++) { const t = null === n(8, i = we.Iconify.getIcon) || void 0 === i ? void 0 : i.call(we.Iconify, tt.iconToString(r[e])); if (t && -1 !== t.body.indexOf("currentColor")) { n(1, o = !0); break } } } 513 & e.$$.dirty && a !== s && (n(9, a = s), n(2, u = s)) }, [s, o, u, l, function (e) { if (n(2, u = e), "" === e) return void c("color", ""); const t = function (e, t) { const n = Gs.stringToColor(e); if (!n) return t; const i = Gs.colorToString(n); return "" === i ? t : i }(e, null); null !== t && (n(9, a = n(0, s = t)), c("color", t)) }, function () { n(2, u = s) }, r, c, i, a] } class nc extends mn { constructor(e) { super(), gn(this, e, tc, ec, mt, { icons: 6, value: 0, customise: 7 }) } } function ic(e) { let t, n; return t = new Nn({ props: { value: e[3], placeholder: e[1], title: e[2], onInput: e[4], onBlur: e[5], icon: "icon-" + e[0], type: "number" } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 8 & n && (i.value = e[3]), 2 & n && (i.placeholder = e[1]), 4 & n && (i.title = e[2]), 1 & n && (i.icon = "icon-" + e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function oc(e, t, n) { let i, { prop: o } = t, { value: r } = t, { placeholder: s } = t, { customise: c } = t, l = r, a = r; return e.$$set = e => { "prop" in e && n(0, o = e.prop), "value" in e && n(6, r = e.value), "placeholder" in e && n(1, s = e.placeholder), "customise" in e && n(7, c = e.customise) }, e.$$.update = () => { 1 & e.$$.dirty && n(2, i = xn.footerBlocks[o]), 320 & e.$$.dirty && l !== r && (n(8, l = r), n(3, a = r)) }, [o, s, i, a, function (e) { n(3, a = e); let t = e; if ("" !== e) { const n = parseFloat(e); if (t = "" + n, isNaN(n) || t !== e || n <= 0) return } c(o, t) }, function () { n(3, a = r) }, r, c, l] } class rc extends mn { constructor(e) { super(), gn(this, e, oc, ic, mt, { prop: 0, value: 6, placeholder: 1, customise: 7 }) } } function sc(e, t, n) { const i = e.slice(); return i[8] = t[n], i[10] = n, i } function cc(e, t) { let n, i, o; return i = new rc({ props: { prop: t[8], value: null === t[0][t[8]] ? "" : t[0][t[8]] + "", placeholder: t[2][t[8]], customise: t[1] } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 1 & n && (o.value = null === t[0][t[8]] ? "" : t[0][t[8]] + ""), 4 & n && (o.placeholder = t[2][t[8]]), 2 & n && (o.customise = t[1]), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function lc(e) { let t, n, i = [], o = new Map, r = e[4]; const s = e => e[8]; for (let t = 0; t < r.length; t += 1) { let n = sc(e, r, t), c = s(n); o.set(c, i[t] = cc(c, n)) } return { c() { for (let e = 0; e < i.length; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < i.length; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, n) { 23 & n && (r = e[4], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, cc, t, sc), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < i.length; t += 1)i[t].d(e); e && _t(t) } } } function ac(e) { let t, n; return t = new Ys({ props: { type: e[3], $$slots: { default: [lc] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 2055 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function uc(e, t, n) { let { icons: i } = t, { customisations: o } = t, { customise: r } = t; const s = { width: "", height: "" }; let c, l; return e.$$set = e => { "icons" in e && n(5, i = e.icons), "customisations" in e && n(0, o = e.customisations), "customise" in e && n(1, r = e.customise) }, e.$$.update = () => { if (32 & e.$$.dirty) { let e = 0, t = 0, o = !0, r = !0, s = 1, l = !0; i.forEach((n => { var i; if (!o && !r) return; const c = tt.iconToString(n), a = null === (i = we.Iconify.getIcon) || void 0 === i ? void 0 : i.call(we.Iconify, c); if (a) { if (!e) return e = a.width, t = a.height, void (s = e / t); o && e !== a.width && (o = !1), r && t !== a.height && (r = !1), l && a.width / a.height !== s && (l = !1) } })), n(6, c = { width: o ? e : 0, height: r ? t : 0, ratio: l ? s : 0 }) } if (65 & e.$$.dirty) { n(2, l = { width: "", height: "" }); const e = !(!o.rotate || o.rotate % 2 != 1); if (0 !== c.ratio) { const t = ["width", "height"]; t.forEach(((i, r) => { const a = t[1 - r], u = e ? a : i; let f = "", d = !1; const p = o[e ? i : a]; p ? (f = p, d = !0) : "" !== s[i] ? f = s[i] : "" !== s[a] ? (f = s[a], d = !0) : c[i] && (f = c[i]), "" !== f && n(2, l[u] = (d ? ae(f, "width" === i ? c.ratio : 1 / c.ratio) : f) + "", l) })) } } }, [o, r, l, "size", ["width", "height"], i, c] } class fc extends mn { constructor(e) { super(), gn(this, e, uc, ac, mt, { icons: 5, customisations: 0, customise: 1 }) } } function dc(e) { let t, n; return t = new En({ props: { icon: e[0] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icon = e[0]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function pc(e) { let t, n, i, o, r, s, c, l = (e[3] ? e[3] : e[2]) + "", a = e[0] && dc(e); return { c() { t = xt("button"), a && a.c(), n = jt(), i = xt("span"), o = Ct(l), St(t, "class", e[4]), St(t, "title", e[2]) }, m(l, u) { kt(l, t, u), a && a.m(t, null), bt(t, n), bt(t, i), bt(i, o), r = !0, s || (c = Pt(t, "click", (function () { gt(e[1]) && e[1].apply(this, arguments) })), s = !0) }, p(i, [s]) { (e = i)[0] ? a ? (a.p(e, s), 1 & s && nn(a, 1)) : (a = dc(e), a.c(), nn(a, 1), a.m(t, n)) : a && (en(), on(a, 1, 1, (() => { a = null })), tn()), (!r || 12 & s) && l !== (l = (e[3] ? e[3] : e[2]) + "") && Et(o, l), (!r || 16 & s) && St(t, "class", e[4]), (!r || 4 & s) && St(t, "title", e[2]) }, i(e) { r || (nn(a), r = !0) }, o(e) { on(a), r = !1 }, d(e) { e && _t(t), a && a.d(), s = !1, c() } } } const hc = "iif-option-button"; function gc(e, t, n) { let i, { icon: o = "" } = t, { onClick: r } = t, { title: s } = t, { text: c = null } = t, { textOptional: l = !1 } = t, { status: a = "" } = t; return e.$$set = e => { "icon" in e && n(0, o = e.icon), "onClick" in e && n(1, r = e.onClick), "title" in e && n(2, s = e.title), "text" in e && n(3, c = e.text), "textOptional" in e && n(5, l = e.textOptional), "status" in e && n(6, a = e.status) }, e.$$.update = () => { 105 & e.$$.dirty && n(4, i = hc + " " + hc + (o ? "--with-icon" : "--without-icon") + " " + hc + (c && !l || !o ? "--with-text" : "--without-text") + ("" === a ? "" : " " + hc + "--" + a)) }, [o, r, s, c, i, l, a] } class mc extends mn { constructor(e) { super(), gn(this, e, gc, pc, mt, { icon: 0, onClick: 1, title: 2, text: 3, textOptional: 5, status: 6 }) } } function yc(e, t, n) { const i = e.slice(); return i[6] = t[n].count, i[7] = t[n].key, i[9] = n, i } function $c(e, t) { let n, i, o; function r() { return t[5](t[6]) } return i = new mc({ props: { icon: "rotate" + t[6], title: t[2].rotateTitle.replace("{num}", 90 * t[6] + ""), text: t[2].rotate.replace("{num}", 90 * t[6] + ""), status: t[0] === t[6] ? "checked" : "unchecked", onClick: r } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 2 & n && (o.icon = "rotate" + t[6]), 2 & n && (o.title = t[2].rotateTitle.replace("{num}", 90 * t[6] + "")), 2 & n && (o.text = t[2].rotate.replace("{num}", 90 * t[6] + "")), 3 & n && (o.status = t[0] === t[6] ? "checked" : "unchecked"), 2 & n && (o.onClick = r), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function vc(e) { let t, n, i = [], o = new Map, r = e[1]; const s = e => e[7]; for (let t = 0; t < r.length; t += 1) { let n = yc(e, r, t), c = s(n); o.set(c, i[t] = $c(c, n)) } return { c() { for (let e = 0; e < i.length; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < i.length; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, n) { 15 & n && (r = e[1], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, $c, t, yc), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < i.length; t += 1)i[t].d(e); e && _t(t) } } } function bc(e) { let t, n; return t = new Ys({ props: { type: "rotate", $$slots: { default: [vc] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 1027 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function kc(e, t, n) { let { value: i } = t, { customise: o } = t; const r = xn.footerOptionButtons; let s; function c(e) { (e || i) && o("rotate", e === i ? 0 : e) } return e.$$set = e => { "value" in e && n(0, i = e.value), "customise" in e && n(4, o = e.customise) }, e.$$.update = () => { if (3 & e.$$.dirty) { const e = []; for (let n = 0; n < 4; n++)if (s && s[n] && i !== n) { const t = s[n]; t.selected = !1, e.push(t) } else e.push((t = n, o = i === n, r = s && s[n] ? s[n].temp + 1 : 0, { count: t, key: t + "-" + r, selected: o, temp: r })); n(1, s = e) } var t, o, r }, [i, s, r, c, o, e => c(e)] } class _c extends mn { constructor(e) { super(), gn(this, e, kc, bc, mt, { value: 0, customise: 4 }) } } function wc(e, t, n) { const i = e.slice(); return i[6] = t[n], i[8] = n, i } function xc(e, t) { let n, i, o; function r() { return t[4](t[6]) } return i = new mc({ props: { icon: t[6].icon, title: t[6].title, status: t[0][t[6].prop] ? "checked" : "unchecked", onClick: r } }), { key: e, first: null, c() { n = It(), fn(i.$$.fragment), this.first = n }, m(e, t) { kt(e, n, t), dn(i, e, t), o = !0 }, p(e, n) { t = e; const o = {}; 2 & n && (o.icon = t[6].icon), 2 & n && (o.title = t[6].title), 3 & n && (o.status = t[0][t[6].prop] ? "checked" : "unchecked"), 2 & n && (o.onClick = r), i.$set(o) }, i(e) { o || (nn(i.$$.fragment, e), o = !0) }, o(e) { on(i.$$.fragment, e), o = !1 }, d(e) { e && _t(n), pn(i, e) } } } function Cc(e) { let t, n, i = [], o = new Map, r = e[1]; const s = e => e[6].key; for (let t = 0; t < r.length; t += 1) { let n = wc(e, r, t), c = s(n); o.set(c, i[t] = xc(c, n)) } return { c() { for (let e = 0; e < i.length; e += 1)i[e].c(); t = It() }, m(e, o) { for (let t = 0; t < i.length; t += 1)i[t].m(e, o); kt(e, t, o), n = !0 }, p(e, n) { 7 & n && (r = e[1], en(), i = cn(i, n, s, 1, e, r, o, t.parentNode, sn, xc, t, wc), tn()) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { for (let t = 0; t < i.length; t += 1)i[t].d(e); e && _t(t) } } } function jc(e) { let t, n; return t = new Ys({ props: { type: "flip", $$slots: { default: [Cc] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 515 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ic(e, t, n) { let i, { customisations: o } = t, { customise: r } = t; function s(e, t) { const n = e + "Flip"; return { prop: n, icon: e + "-flip", key: e + "Flip" + (t ? "!" : ""), title: xn.footerOptionButtons[n] } } function c(e) { r(e, !o[e]) } return e.$$set = e => { "customisations" in e && n(0, o = e.customisations), "customise" in e && n(3, r = e.customise) }, e.$$.update = () => { 1 & e.$$.dirty && n(1, i = [s("h", o.hFlip), s("v", o.vFlip)]) }, [o, i, c, r, e => c(e.prop)] } class Pc extends mn { constructor(e) { super(), gn(this, e, Ic, jc, mt, { customisations: 0, customise: 3 }) } } function Oc(e) { let t, n, i, o, r, s, c = function (e) { let t, n; return t = new nc({ props: { icons: e[0], value: "string" == typeof e[1].color ? e[1].color : "", customise: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icons = e[0]), 2 & n && (i.value = "string" == typeof e[1].color ? e[1].color : ""), 4 & n && (i.customise = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } }(e), l = function (e) { let t, n; return t = new fc({ props: { icons: e[0], customisations: e[1], customise: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icons = e[0]), 2 & n && (i.customisations = e[1]), 4 & n && (i.customise = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } }(e), a = function (e) { let t, n; return t = new Pc({ props: { customisations: e[1], customise: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.customisations = e[1]), 4 & n && (i.customise = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } }(e), u = function (e) { let t, n; return t = new _c({ props: { value: e[1].rotate, customise: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 2 & n && (i.value = e[1].rotate), 4 & n && (i.customise = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } }(e); return { c() { t = xt("div"), c && c.c(), n = jt(), l && l.c(), i = jt(), a && a.c(), o = jt(), u && u.c(), r = jt() }, m(e, f) { kt(e, t, f), c && c.m(t, null), bt(t, n), l && l.m(t, null), bt(t, i), a && a.m(t, null), bt(t, o), u && u.m(t, null), bt(t, r), s = !0 }, p(e, t) { c.p(e, t), l.p(e, t), a.p(e, t), u.p(e, t) }, i(e) { s || (nn(c), nn(l), nn(a), nn(u), nn(false), s = !0) }, o(e) { on(c), on(l), on(a), on(u), on(false), s = !1 }, d(e) { e && _t(t), c && c.d(), l && l.d(), a && a.d(), u && u.d() } } } function Sc(e) { let t, n; return t = new Hs({ props: { name: "props", title: e[3], $$slots: { default: [Oc] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 8 & n && (i.title = e[3]), 23 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Ec(e, t, n) { let i, { icons: o } = t, { customisations: r } = t, { customise: s } = t; return e.$$set = e => { "icons" in e && n(0, o = e.icons), "customisations" in e && n(1, r = e.customisations), "customise" in e && n(2, s = e.customise) }, e.$$.update = () => { 1 & e.$$.dirty && n(3, i = "") }, [o, r, s, i] } class Mc extends mn { constructor(e) { super(), gn(this, e, Ec, Sc, mt, { icons: 0, customisations: 1, customise: 2 }) } } function Tc(e, t, n, i) { return e && t ? { width: i ? t : e, height: i ? e : t } : (t ? e = ae(t, i ? 1 / n : n) : t = ae(e, i ? n : 1 / n), { width: e, height: t }) } function Ac(e) { let t, n, i; const o = [{ icon: e[0].name }, e[2]]; let r = {}; for (let e = 0; e < o.length; e += 1)r = ft(r, o[e]); return n = new $e({ props: r }), { c() { t = xt("div"), fn(n.$$.fragment), St(t, "class", "iif-footer-sample iif-footer-sample--block iif-footer-sample--loaded"), St(t, "style", e[1]) }, m(e, o) { kt(e, t, o), dn(n, t, null), i = !0 }, p(e, [r]) { const s = 5 & r ? ln(o, [1 & r && { icon: e[0].name }, 4 & r && an(e[2])]) : {}; n.$set(s), (!i || 2 & r) && St(t, "style", e[1]) }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n) } } } function Rc(e, t, n) { let { icon: i } = t, { customisations: o } = t; const r = [2.5, 3, 3.5], s = kn, c = _n, l = Math.floor(s / 2), a = Math.floor(c / 2); function u(e, t) { for (; e.width > s || e.height > c;) { let t = e.width / 2, n = e.height / 2; if (Math.round(t) !== t || Math.round(n) !== n) for (let i = 0; i < r.length; i++) { let o = r[i], s = e.width / o, c = e.height / o; if (Math.round(s) === s && Math.round(c) === c) { t = s, n = c; break } } e.width = t, e.height = n } if (t) for (; e.width < l && e.height < a;)e.width *= 2, e.height *= 2 } let f, d, p; return e.$$set = e => { "icon" in e && n(3, i = e.icon), "customisations" in e && n(4, o = e.customisations) }, e.$$.update = () => { if (24 & e.$$.dirty) { const e = tt.iconToString(i), t = we.Iconify.getIcon(e), r = !(t.width === t.height || !o.rotate || o.rotate % 2 != 1), s = t.width / t.height; n(0, f = { name: e, data: t, rotated: r, ratio: s }) } if (19 & e.$$.dirty && (n(1, d = ""), o.color ? n(1, d += "color: " + o.color + ";") : n(1, d += "color: #000;"), !o.width && !o.height)) { let e; e = Tc(f.data.width, f.data.height, f.ratio, f.rotated), u(e, !0), n(1, d += "font-size: " + e.height + "px;") } if (17 & e.$$.dirty) { let e; n(2, p = {}), ["hFlip", "vFlip", "rotate"].forEach((e => { const t = e; o[t] && n(2, p[t] = o[t], p) })); const t = o.width, i = o.height; (t || i) && (e = Tc(t || "", i || "", f.ratio, f.rotated)), void 0 !== e && (u(e, !1), n(2, p.width = e.width + "", p), n(2, p.height = e.height + "", p)) } }, [f, d, p, i, o] } class Fc extends mn { constructor(e) { super(), gn(this, e, Rc, Ac, mt, { icon: 3, customisations: 4 }) } } function Lc(e) { let t, n, i, o, r, s, c, l, a, u = e[2].before + "", f = e[2].after + ""; const d = [e[0]]; let p = {}; for (let e = 0; e < d.length; e += 1)p = ft(p, d[e]); return s = new $e({ props: p }), { c() { t = xt("div"), n = xt("p"), i = Ct(u), o = jt(), r = xt("span"), fn(s.$$.fragment), c = jt(), l = Ct(f), St(r, "style", e[1]), St(t, "class", "iif-footer-sample iif-footer-sample--inline iif-footer-sample--loaded") }, m(e, u) { kt(e, t, u), bt(t, n), bt(n, i), bt(n, o), bt(n, r), dn(s, r, null), bt(n, c), bt(n, l), a = !0 }, p(e, [t]) { const n = 1 & t ? ln(d, [an(e[0])]) : {}; s.$set(n), (!a || 2 & t) && St(r, "style", e[1]) }, i(e) { a || (nn(s.$$.fragment, e), a = !0) }, o(e) { on(s.$$.fragment, e), a = !1 }, d(e) { e && _t(t), pn(s) } } } function Nc(e, t, n) { let { icon: i } = t, { customisations: o } = t; const r = xn.footer.inlineSample, s = kn, c = _n; let l, a; return e.$$set = e => { "icon" in e && n(3, i = e.icon), "customisations" in e && n(4, o = e.customisations) }, e.$$.update = () => { if (25 & e.$$.dirty && (n(0, l = { icon: tt.iconToString(i) }), n(1, a = ""), Object.keys(o).forEach((e => { const t = e, i = o[t]; void 0 !== i && "" !== i && 0 !== i && !1 !== i && ("color" === t ? n(1, a = "color: " + i + ";") : n(0, l[t] = i, l)) })), l.width || l.height)) { const e = !!(o.rotate % 2); let t = e ? "height" : "width"; l[t] && l[t] > s && n(0, l[t] = s, l), t = e ? "width" : "height", l[t] && l[t] > c && n(0, l[t] = c, l) } }, [l, a, r, i, o] } class Bc extends mn { constructor(e) { super(), gn(this, e, Nc, Lc, mt, { icon: 3, customisations: 4 }) } } function Vc(e, t, n) { if (!e) return n; switch (e.type) { case "collections": case "search": case "collection": break; default: return n }const i = e.params, o = i && "string" == typeof i.provider ? i.provider : ""; return t.provider !== o ? n : "collection" === e.type && t.prefix === e.params.prefix ? t.name : t.prefix + ":" + t.name } function Dc(e, t, n) { const i = e.slice(); return i[13] = t[n], i[15] = n, i } function zc(e) { let t, n, i; return n = new En({ props: { icon: "reset" } }), { c() { t = xt("span"), fn(n.$$.fragment), St(t, "class", "iif-footer-icons-reset") }, m(e, o) { kt(e, t, o), dn(n, t, null), i = !0 }, i(e) { i || (nn(n.$$.fragment, e), i = !0) }, o(e) { on(n.$$.fragment, e), i = !1 }, d(e) { e && _t(t), pn(n) } } } function qc(e) { let t, n, i, o, r, s; function c() { return e[10](e[13]) } return n = new En({ props: { icon: "reset" } }), { c() { t = xt("a"), fn(n.$$.fragment), St(t, "href", "# "), St(t, "class", "iif-footer-icons-reset"), St(t, "title", i = e[13].removeTitle) }, m(e, i) { kt(e, t, i), dn(n, t, null), o = !0, r || (s = Pt(t, "click", Ot(c)), r = !0) }, p(n, r) { e = n, (!o || 2 & r && i !== (i = e[13].removeTitle)) && St(t, "title", i) }, i(e) { o || (nn(n.$$.fragment, e), o = !0) }, o(e) { on(n.$$.fragment, e), o = !1 }, d(e) { e && _t(t), pn(n), r = !1, s() } } } function Uc(e, t) { let n, i, o, r, s, c, l, a, u, f; const d = [{ icon: t[13].name }, t[2]]; let p = {}; for (let e = 0; e < d.length; e += 1)p = ft(p, d[e]); o = new $e({ props: p }); let h = !t[0] && zc(); function g() { return t[9](t[13]) } let m = t[0] && qc(t); return { key: e, first: null, c() { n = xt("li"), i = xt("a"), fn(o.$$.fragment), r = jt(), h && h.c(), c = jt(), m && m.c(), l = jt(), St(i, "href", "# "), St(i, "title", s = t[13].selectTitle), this.first = n }, m(e, t) { kt(e, n, t), bt(n, i), dn(o, i, null), bt(i, r), h && h.m(i, null), bt(n, c), m && m.m(n, null), bt(n, l), a = !0, u || (f = Pt(i, "click", Ot(g)), u = !0) }, p(e, r) { t = e; const c = 6 & r ? ln(d, [2 & r && { icon: t[13].name }, 4 & r && an(t[2])]) : {}; o.$set(c), t[0] ? h && (en(), on(h, 1, 1, (() => { h = null })), tn()) : h ? 1 & r && nn(h, 1) : (h = zc(), h.c(), nn(h, 1), h.m(i, null)), (!a || 2 & r && s !== (s = t[13].selectTitle)) && St(i, "title", s), t[0] ? m ? (m.p(t, r), 1 & r && nn(m, 1)) : (m = qc(t), m.c(), nn(m, 1), m.m(n, l)) : m && (en(), on(m, 1, 1, (() => { m = null })), tn()) }, i(e) { a || (nn(o.$$.fragment, e), nn(h), nn(m), a = !0) }, o(e) { on(o.$$.fragment, e), on(h), on(m), a = !1 }, d(e) { e && _t(n), pn(o), h && h.d(), m && m.d(), u = !1, f() } } } function Hc(e) { let t, n, i = [], o = new Map, r = e[1]; const s = e => e[13].name; for (let t = 0; t < r.length; t += 1) { let n = Dc(e, r, t), c = s(n); o.set(c, i[t] = Uc(c, n)) } return { c() { t = xt("ul"); for (let e = 0; e < i.length; e += 1)i[e].c(); St(t, "class", "iif-footer-icons"), St(t, "style", e[3]) }, m(e, o) { kt(e, t, o); for (let e = 0; e < i.length; e += 1)i[e].m(t, null); n = !0 }, p(e, c) { 23 & c && (r = e[1], en(), i = cn(i, c, s, 1, e, r, o, t, sn, Uc, null, Dc), tn()), (!n || 8 & c) && St(t, "style", e[3]) }, i(e) { if (!n) { for (let e = 0; e < r.length; e += 1)nn(i[e]); n = !0 } }, o(e) { for (let e = 0; e < i.length; e += 1)on(i[e]); n = !1 }, d(e) { e && _t(t); for (let e = 0; e < i.length; e += 1)i[e].d() } } } function Kc(e) { let t, n; return t = new Ys({ props: { type: "icons", $$slots: { default: [Hc] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 65551 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function Gc(e, t, n) { let { icons: i } = t, { customisations: o } = t, { route: r } = t, { selected: s = "" } = t, { onSelect: c = null } = t; const l = Bt("registry"); let a; const u = ["rotate", "hFlip", "vFlip"]; let f, d; function p(e, t) { e && c ? c(t) : l.callback({ type: "selection", icon: t, selected: !1 }) } return e.$$set = e => { "icons" in e && n(5, i = e.icons), "customisations" in e && n(6, o = e.customisations), "route" in e && n(7, r = e.route), "selected" in e && n(8, s = e.selected), "onSelect" in e && n(0, c = e.onSelect) }, e.$$.update = () => { 419 & e.$$.dirty && (n(1, a = []), i.forEach((e => { const t = tt.iconToString(e), n = Vc(r, e, t), i = xn.footer.remove.replace("{name}", n), o = { icon: e, name: t, text: n, removeTitle: i, selectTitle: c ? xn.footer.select.replace("{name}", n) : i, selected: t === s }; a.push(o) }))), 64 & e.$$.dirty && (n(2, f = {}), u.forEach((e => { o[e] && n(2, f[e] = o[e], f) })), "number" == typeof o.height && o.height < 32 && (n(2, f.height = o.height, f), o.width && n(2, f.width = o.width, f)), n(3, d = ""), "" !== o.color && n(3, d = "color: " + o.color + ";")) }, [c, a, f, d, p, i, o, r, s, e => { p(!0, e.icon) }, e => { p(!1, e.icon) }] } class Jc extends mn { constructor(e) { super(), gn(this, e, Gc, Kc, mt, { icons: 5, customisations: 6, route: 7, selected: 8, onSelect: 0 }) } } function Wc(e) { let t, n, i, o, r, s, c, l, a, u; return r = new $e({ props: { icon: e[0] } }), { c() { t = xt("div"), n = xt("dl"), i = xt("dt"), i.textContent = `${xn.footer.iconName}`, o = xt("dd"), fn(r.$$.fragment), s = jt(), c = xt("div"), l = xt("span"), a = Ct(e[1]), St(c, "class", "iif-footer-icon-name-input"), St(t, "class", "iif-footer-icon-name iif-footer-icon-name--simple") }, m(e, f) { kt(e, t, f), bt(t, n), bt(n, i), bt(n, o), dn(r, o, null), bt(o, s), bt(o, c), bt(c, l), bt(l, a), u = !0 }, p(e, [t]) { const n = {}; 1 & t && (n.icon = e[0]), r.$set(n), (!u || 2 & t) && Et(a, e[1]) }, i(e) { u || (nn(r.$$.fragment, e), u = !0) }, o(e) { on(r.$$.fragment, e), u = !1 }, d(e) { e && _t(t), pn(r) } } } function Qc(e, t, n) { let i, o, { icon: r } = t, { route: s } = t; return e.$$set = e => { "icon" in e && n(2, r = e.icon), "route" in e && n(3, s = e.route) }, e.$$.update = () => { 13 & e.$$.dirty && (n(0, i = tt.iconToString(r)), n(1, o = Vc(s, r, i))) }, [i, o, r, s] } class Yc extends mn { constructor(e) { super(), gn(this, e, Qc, Wc, mt, { icon: 2, route: 3 }) } } var Xc = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.capitalize = void 0; const n = /([0-9]+[0-9.]*)/g; t.capitalize = function (e, t = "-") { return e.split(t).map((e => e.split(n).filter((e => e.length > 0)).map((e => e.slice(0, 1).toUpperCase() + e.slice(1))).join(" "))).join(" ") } })), Zc = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.translateCodeSampleTitles = t.codeSampleTitles = void 0, t.codeSampleTitles = { iconify: "SVG Framework", svg: "SVG", "svg-raw": "SVG", "svg-box": "SVG with viewBox rectangle", "svg-uri": "SVG as data: URI", "react-npm": "React", "react-api": "React with Iconify API" }, t.translateCodeSampleTitles = function (e) { for (const n in e) { const i = n; t.codeSampleTitles[i] = e[i] } } })); ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getCodeSamplesTree = void 0; const n = { iconify: "api", react: { "react-npm": "npm", "react-api": "api" }, vue: { vue3: "npm", vue2: "npm" }, svelte: "npm", svg: { "svg-raw": "raw", "svg-box": "raw", "svg-uri": "raw" } }; t.getCodeSamplesTree = function (e) { const t = []; function i(t, n) { switch (t) { case "svg-box": case "svg-raw": case "svg-uri": if (!we.Iconify.getIcon) return !1 }switch (n) { case "raw": return e[n]; case "api": return void 0 !== e.api; case "npm": return void 0 !== e.npmES || void 0 !== e.npmCJS } } function o(e) { return void 0 !== Zc.codeSampleTitles[e] ? Zc.codeSampleTitles[e] : Xc.capitalize(e) } for (const e in n) { const r = e, s = n[e]; if ("string" == typeof s) { const e = r; if (i(e, s)) { const n = { mode: e, type: s, title: o(r) }; t.push(n) } continue } const c = []; for (const e in s) { const t = e, n = s[t]; if (i(t, n)) { const e = { mode: t, type: n, title: o(t) }; c.push(e) } } let l; const a = r, u = o(a); switch (c.length) { case 0: break; case 1: l = c[0], t.push({ tab: a, mode: l.mode, type: l.type, title: u }); break; default: t.push({ tab: a, children: c, title: u }) } } return t } })); ({ providers: Object.create(null), defaultProvider: { raw: !0 } }).providers[""] = { api: "", npmES: { package: "@iconify-icons/{prefix}", file: "/{name}" }, npmCJS: { package: "@iconify/icons-{prefix}", file: "/{name}" }, raw: !0 }; var el = ve((function (e, t) { function n(e) { let t = ""; const n = e.split("-"); return n.forEach(((e, n) => { t += n ? e.slice(0, 1).toUpperCase() + e.slice(1) : e })), t.charCodeAt(0) < 97 || t.charCodeAt(0) > 122 ? t = "icon" + t.slice(0, 1).toUpperCase() + t.slice(1) : n.length < 2 && (t += "Icon"), t } function i(e) { switch (typeof e) { case "number": return e + ""; case "string": return e; default: return JSON.stringify(e) } } Object.defineProperty(t, "__esModule", { value: !0 }), t.codeParser = t.getCustomisationAttributes = t.varName = void 0, t.varName = n; const o = ["width", "height", "rotate", "hFlip", "vFlip", "hAlign", "vAlign", "slice"]; function r(e, t) { const n = o.slice(0); return e && n.push("color"), t && n.push("inline"), n } t.getCustomisationAttributes = r; const s = "https://docs.iconify.design/implementations/"; const c = Object.create(null); t.codeParser = function (e) { return void 0 === c[e] && (c[e] = function (e) { function t(e, t, n) { e[t] = { key: t, value: n } } function o(e, t, n, i) { let o; switch (typeof n) { case "boolean": o = n ? "true" : "false"; break; case "object": o = JSON.stringify(n); break; default: o = n }e[t] = { key: t, value: o, syntax: i } } function c(e, n, i) { "string" == typeof i && "icon" !== n ? t(e, n, i) : o(e, n, i, "{var}={{value}}") } function l(e, n, i) { "string" == typeof i && "icon" !== n ? t(e, n, i) : o(e, n, i, ':{var}="{value}"') } function a(e, t, n, i) { const o = "object" == typeof e[t] ? e[t] : void 0; e[t] = { key: t, value: (o ? o.value + i : "") + n, syntax: o ? o.syntax : void 0 } } function u(e, t, n) { return t.forEach((t => { void 0 === e.parsers[t] && (e.parsers[t] = (e, i) => n(e, t, i)) })), e } function f(e) { return Object.keys(e).map((t => { const n = e[t]; return "object" == typeof n ? ("string" == typeof n.syntax ? n.syntax : '{var}="{value}"').replace("{var}", n.key).replace("{value}", n.value) : n })).join(" ") } function d(e) { const t = { iconParser: (e, t, i) => l(e, "icon", "icons." + n(i.name)), parsers: { hFlip: (e, t) => l(e, "horizontalFlip", t), vFlip: (e, t) => l(e, "verticalFlip", t), hAlign: (e, t) => l(e, "horizontalAlign", t), vAlign: (e, t) => l(e, "verticalAlign", t), inline: (e, t) => l(e, "inline", t) }, merge: f, template: (e, t) => "<template>\n\t<Icon {attr} />\n</template>".replace("{attr}", e), vueTemplate: (e, t) => "export default {\n\tcomponents: {\n\t\tIcon,\n\t},\n\tdata() {\n\t\treturn {\n\t\t\ticons: {\n\t\t\t\t{varName},\n\t\t\t},\n\t\t};\n\t},\n});".replace("{attr}", e), docs: { type: "vue", href: s + (e ? "vue/" : "vue2/") }, npm: e ? { install: "@iconify/vue@beta", import: (e, t) => "import { Icon } from '@iconify/vue';" } : { install: "@iconify/vue@^1", import: "import Icon from '@iconify/vue';" } }; return u(t, r(!0, !1), l), t } let p; switch (e) { case "iconify": return { init: e => ({ class: 'class="' + (e.inline ? "iconify-inline" : "iconify") + '"' }), iconParser: (e, n, i) => t(e, "data-icon", n), parsers: { color: (e, t) => a(e, "style", "color: " + t + ";", " "), onlyHeight: (e, t) => a(e, "style", "font-size: " + t + (function (e) { return "number" == typeof e || "string" == typeof e && !!e.match(/^-?[0-9.]+$/) }(t) ? "px;" : ";"), " "), width: (e, n) => t(e, "data-width", i(n)), height: (e, n) => t(e, "data-height", i(n)), rotate: (e, n) => t(e, "data-rotate", function (e) { return 90 * e + "deg" }(n)), hFlip: e => a(e, "data-flip", "horizontal", ","), vFlip: e => a(e, "data-flip", "vertical", ","), hAlign: (e, t) => a(e, "data-align", t, ","), vAlign: (e, t) => a(e, "data-align", t, ","), slice: e => a(e, "data-align", "slice", ",") }, merge: f, template: "<span {attr}></span>", docs: { type: "iconify", href: s + "svg-framework/" } }; case "svg-raw": case "svg-uri": case "svg-box": return p = { parsers: {} }, u(p, r(!1, !0), (function (e, t, n) { e[t] = n })), p; case "react-npm": return p = { iconParser: (e, t, i) => c(e, "icon", n(i.name)), parsers: {}, merge: f, template: (e, t) => "<Icon " + e + " />", docs: { type: "react", href: s + "react/" }, npm: { install: "@iconify/react@beta", import: (e, t) => "import { Icon } from '@iconify/react';" } }, u(p, r(!0, !0), c), p; case "react-api": return p = { iconParser: (e, n, i) => t(e, "icon", n), parsers: {}, merge: f, template: (e, t) => "<Icon " + e + " />", docs: { type: "react", href: s + "react/" }, npm: { install: "@iconify/react@alpha", import: (e, t) => "import { Icon } from '@iconify/react';" } }, u(p, r(!0, !0), c), p; case "vue2": return d(!1); case "vue3": return d(!0); case "svelte": return p = { iconParser: (e, t, i) => c(e, "icon", n(i.name)), parsers: {}, merge: f, template: "<Icon {attr} />", docs: { type: "svelte", href: s + "svelte/" }, npm: { install: "@iconify/svelte", import: "import Icon from '@iconify/svelte';" } }, u(p, r(!0, !0), c), p } }(e)), c[e] } })), tl = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.calculateSize = void 0; const n = /(-?[0-9.]*[0-9]+[0-9.]*)/g, i = /^-?[0-9.]*[0-9]+[0-9.]*$/g; t.calculateSize = function (e, t, o) { if (1 === t) return e; if (o = void 0 === o ? 100 : o, "number" == typeof e) return Math.ceil(e * t * o) / o; if ("string" != typeof e) return e; const r = e.split(n); if (null === r || !r.length) return e; const s = []; let c = r.shift(), l = i.test(c); for (; ;) { if (l) { const e = parseFloat(c); isNaN(e) ? s.push(c) : s.push(Math.ceil(e * t * o) / o) } else s.push(c); if (c = r.shift(), void 0 === c) return s.join(""); l = !l } } })), nl = ve((function (e, t) { function n(e) { let t = ""; switch (e.hAlign) { case "left": t += "xMin"; break; case "right": t += "xMax"; break; default: t += "xMid" }switch (e.vAlign) { case "top": t += "YMin"; break; case "bottom": t += "YMax"; break; default: t += "YMid" }return t += e.slice ? " slice" : " meet", t } Object.defineProperty(t, "__esModule", { value: !0 }), t.iconToSVG = void 0, t.iconToSVG = function (e, t) { const i = { left: e.left, top: e.top, width: e.width, height: e.height }; let o, r, s = e.body;[e, t].forEach((e => { const t = [], n = e.hFlip, o = e.vFlip; let r, c = e.rotate; switch (n ? o ? c += 2 : (t.push("translate(" + (i.width + i.left) + " " + (0 - i.top) + ")"), t.push("scale(-1 1)"), i.top = i.left = 0) : o && (t.push("translate(" + (0 - i.left) + " " + (i.height + i.top) + ")"), t.push("scale(1 -1)"), i.top = i.left = 0), c < 0 && (c -= 4 * Math.floor(c / 4)), c %= 4, c) { case 1: r = i.height / 2 + i.top, t.unshift("rotate(90 " + r + " " + r + ")"); break; case 2: t.unshift("rotate(180 " + (i.width / 2 + i.left) + " " + (i.height / 2 + i.top) + ")"); break; case 3: r = i.width / 2 + i.left, t.unshift("rotate(-90 " + r + " " + r + ")") }c % 2 == 1 && (0 === i.left && 0 === i.top || (r = i.left, i.left = i.top, i.top = r), i.width !== i.height && (r = i.width, i.width = i.height, i.height = r)), t.length && (s = '<g transform="' + t.join(" ") + '">' + s + "</g>") })), null === t.width && null === t.height ? (r = "1em", o = tl.calculateSize(r, i.width / i.height)) : null !== t.width && null !== t.height ? (o = t.width, r = t.height) : null !== t.height ? (r = t.height, o = tl.calculateSize(r, i.width / i.height)) : (o = t.width, r = tl.calculateSize(o, i.height / i.width)), "auto" === o && (o = i.width), "auto" === r && (r = i.height), o = "string" == typeof o ? o : o + "", r = "string" == typeof r ? r : r + ""; const c = { attributes: { width: o, height: r, preserveAspectRatio: n(t), viewBox: i.left + " " + i.top + " " + i.width + " " + i.height }, body: s }; return t.inline && (c.inline = !0), c } })), il = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.renderHTML = void 0, t.renderHTML = function (e, t, n) { const i = nl.iconToSVG(e, t), o = []; t.inline && o.push("vertical-align: -0.125em"); const r = {}; "string" == typeof n && "" !== n && (r.class = n), o.length && (r.style = o.join("; ") + ";"); const s = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "aria-hidden": "true", role: "img", ...r, ...i.attributes }; let c = i.body; return "" !== t.color && (c = c.replace(/currentColor/g, t.color)), "<svg " + Object.keys(s).map((e => e + '="' + s[e] + '"')).join(" ") + ">" + c + "</svg>" } })); function ol(e) { let t, n; return t = new zn({ props: { type: "footer", $$slots: { default: [pl] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 767 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function rl(e) { let t, n, i, o; const r = [cl, sl], s = []; return t = 1, n = s[t] = r[t](e), { c() { n.c(), i = It() }, m(e, n) { s[t].m(e, n), kt(e, i, n), o = !0 }, p(e, o) { let c = t; t = 1, t === c ? s[t].p(e, o) : (en(), on(s[c], 1, 1, (() => { s[c] = null })), tn(), n = s[t], n ? n.p(e, o) : (n = s[t] = r[t](e), n.c()), nn(n, 1), n.m(i.parentNode, i)) }, i(e) { o || (nn(n), o = !0) }, o(e) { on(n), o = !1 }, d(e) { s[t].d(e), e && _t(i) } } } function sl(e) { let t, n; return t = new Fc({ props: { icon: e[4], customisations: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 16 & n && (i.icon = e[4]), 4 & n && (i.customisations = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function cl(e) { let t, n; return t = new Bc({ props: { icon: e[4], customisations: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 16 & n && (i.icon = e[4]), 4 & n && (i.customisations = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ll(e) { let t, n; return t = new Jc({ props: { route: e[3], icons: e[0], customisations: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 8 & n && (i.route = e[3]), 1 & n && (i.icons = e[0]), 4 & n && (i.customisations = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function al(e) { let t, n; return t = new Yc({ props: { icon: e[4], route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 16 & n && (i.icon = e[4]), 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function ul(e) { let t, n; return t = new Hs({ props: { name: "info", title: e[7], $$slots: { default: [fl] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 128 & n && (i.title = e[7]), 576 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function fl(e) { let t, n; return t = new Do({ props: { name: "info", block: e[6], short: !0, showTitle: !1 } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 64 & n && (i.block = e[6]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function dl(e) { let t, n; return t = new Mc({ props: { icons: e[0], customise: e[1], customisations: e[2] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icons = e[0]), 2 & n && (i.customise = e[1]), 4 & n && (i.customisations = e[2]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function pl(e) { let t, n, i, o, r, s, c, l, a, u, f, d, p = e[4] && rl(e); const h = [al, ll], g = []; function m(e, t) { return e[4] ? 0 : e[5] ? 1 : -1 } ~(o = m(e)) && (r = g[o] = h[o](e)); let y = e[6] && ul(e), $ = e[5] && dl(e), v = function (e) { let t, n; return t = new Fs({ props: { icons: e[0], route: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 1 & n && (i.icons = e[0]), 8 & n && (i.route = e[3]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } }(e); return { c() { t = xt("div"), p && p.c(), n = jt(), i = xt("div"), r && r.c(), s = jt(), y && y.c(), c = jt(), $ && $.c(), l = jt(), a = jt(), v && v.c(), St(i, "class", u = e[4] ? "iif-footer-full-content" : ""), St(t, "class", f = e[4] ? "iif-footer-full" : "") }, m(e, r) { kt(e, t, r), p && p.m(t, null), bt(t, n), bt(t, i), ~o && g[o].m(i, null), bt(i, s), y && y.m(i, null), bt(i, c), $ && $.m(i, null), bt(i, l), bt(i, a), v && v.m(i, null), d = !0 }, p(e, a) { e[4] ? p ? (p.p(e, a), 16 & a && nn(p, 1)) : (p = rl(e), p.c(), nn(p, 1), p.m(t, n)) : p && (en(), on(p, 1, 1, (() => { p = null })), tn()); let b = o; o = m(e), o === b ? ~o && g[o].p(e, a) : (r && (en(), on(g[b], 1, 1, (() => { g[b] = null })), tn()), ~o ? (r = g[o], r ? r.p(e, a) : (r = g[o] = h[o](e), r.c()), nn(r, 1), r.m(i, s)) : r = null), e[6] ? y ? (y.p(e, a), 64 & a && nn(y, 1)) : (y = ul(e), y.c(), nn(y, 1), y.m(i, c)) : y && (en(), on(y, 1, 1, (() => { y = null })), tn()), e[5] ? $ ? ($.p(e, a), 32 & a && nn($, 1)) : ($ = dl(e), $.c(), nn($, 1), $.m(i, l)) : $ && (en(), on($, 1, 1, (() => { $ = null })), tn()), v.p(e, a), (!d || 16 & a && u !== (u = e[4] ? "iif-footer-full-content" : "")) && St(i, "class", u), (!d || 16 & a && f !== (f = e[4] ? "iif-footer-full" : "")) && St(t, "class", f) }, i(e) { d || (nn(p), nn(r), nn(y), nn($), nn(false), nn(v), d = !0) }, o(e) { on(p), on(r), on(y), on($), on(false), on(v), d = !1 }, d(e) { e && _t(t), p && p.d(), ~o && g[o].d(), y && y.d(), $ && $.d(), v && v.d() } } } function hl(e) { let t, n, i = ol(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { i ? (i.p(e, n), 32 & n && nn(i, 1)) : (i = ol(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function gl(e, t, n) { let { icons: i } = t, { customise: o } = t, { customisations: r } = t, { route: s } = t; const c = Bt("registry"); let l, a, u, f; return e.$$set = e => { "icons" in e && n(0, i = e.icons), "customise" in e && n(1, o = e.customise), "customisations" in e && n(2, r = e.customisations), "route" in e && n(3, s = e.route) }, e.$$.update = () => { if (1 & e.$$.dirty && (n(5, a = i.length > 0), n(4, l = 1 === i.length ? i[0] : null)), 25 & e.$$.dirty) { let e = !0, t = "", o = ""; if (i.length) if (l) t = l.provider, o = l.prefix; else for (let n = 0; n < i.length; n++) { const r = i[n]; if (n) { if (r.provider !== t || r.prefix !== o) { e = !1; break } } else o = r.prefix, t = r.provider } else e = !1; if (e && "collection" === s.type && t === s.params.provider && o === s.params.prefix && (e = !1), e) { const e = tt.getCollectionInfo(c.collections, t, o); e ? (n(6, u = { type: "collection-info", prefix: o, info: e }), n(7, f = xn.footer.about.replace("{title}", e.name))) : (n(6, u = null), n(7, f = "")) } else n(6, u = null), n(7, f = "") } }, [i, o, r, s, l, a, u, f] } ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.getIconCode = t.codeOutputComponentKeys = void 0; function n(e, t, n) { return "string" == typeof e ? e.replace("{attr}", t) : e(t, n) } t.codeOutputComponentKeys = ["install", "install1", "import", "import1", "vue", "use"], t.getIconCode = function (e, t, i, o) { var r; const s = el.codeParser(e); if (!s) return null; const c = Ge.iconToString(t), l = s.init ? s.init(i) : {}, a = s.parsers; s.iconParser && s.iconParser(l, c, t), "" !== i.color && a.color && a.color(l, i.color), "" === i.width && "" !== i.height && a.onlyHeight ? a.onlyHeight(l, i.height) : ["width", "height"].forEach((e => { const t = e, n = i[t]; null !== n && "" !== n && a[t] && a[t](l, n) })), ["rotate", "hFlip", "vFlip", "hAlign", "vAlign", "slice"].forEach((e => { const t = e, n = i[t]; void 0 !== n && n !== it.emptyCustomisations[t] && a[t] && a[t](l, n) })), i.inline && a.inline && a.inline(l, !0); const u = s.merge ? s.merge(l) : "", f = s.template ? n(s.template, u, i) : "", d = { docs: s.docs }; switch (e) { case "iconify": { const e = we.Iconify.getVersion ? we.Iconify.getVersion() : "2.0.1"; return d.iconify = { head: '<script src="https://code.iconify.design/' + e.split(".").shift() + "/" + e + '/iconify.min.js"><\/script>', html: f }, d } case "svg-raw": case "svg-box": case "svg-uri": { const t = null === (r = we.Iconify.getIcon) || void 0 === r ? void 0 : r.call(we.Iconify, c); if (!t) return null; let n = il.renderHTML(t, i); if ("svg-box" === e) { if (!t) return null; n = n.replace(">", '><rect x="' + t.left + '" y="' + t.top + '" width="' + t.width + '" height="' + t.height + '" fill="none" stroke="none" />') } if ("svg-uri" === e) { const e = n.split(">"); let t = e.shift();["aria-hidden", "focusable", "role", "class", "style"].forEach((e => { t = t.replace(new RegExp("\\s" + e + '="[^"]*"'), "") })), e.unshift(t), n = e.join(">"), n = "url('data:image/svg+xml," + encodeURIComponent(n) + "')" } return d.raw = [n], d } case "react-npm": case "svelte": case "vue2": case "vue3": { if (!s.npm || !o.npmCJS && !o.npmES) return null; const r = function (e) { const n = el.varName(t.name), i = e ? o.npmES ? o.npmES : o.npmCJS : o.npmCJS ? o.npmCJS : o.npmES; if (!i) return null; const r = "string" == typeof i.package ? i.package.replace("{prefix}", t.prefix) : "function" == typeof i.package ? i.package(o, t) : null; if ("string" != typeof r) return null; const s = "string" == typeof i.file ? i.file.replace("{name}", t.name) : "function" == typeof i.file ? i.file(o, t) : null; return "string" != typeof s ? null : { name: n, package: r, file: s } }("vue3" === e); if (!r) return null; if (d.component = { install: "npm install --save-dev " + s.npm.install + " " + r.package, import: n(s.npm.import, u, i) + "\nimport " + r.name + " from '" + r.package + r.file + "';", use: f.replace(/{varName}/g, r.name).replace("{iconPackage}", r.package + r.file) }, void 0 !== s.vueTemplate) { const e = "function" == typeof s.vueTemplate ? n(s.vueTemplate, u, i) : s.vueTemplate; "string" == typeof e && (d.component.vue = e.replace(/{varName}/g, r.name).replace("{iconPackage}", r.package + r.file)) } return d } case "react-api": return s.npm ? (d.component = { install1: "npm install --save-dev " + s.npm.install, import1: n(s.npm.import, u, i), use: f }, d) : null } } })); class ml extends mn { constructor(e) { super(), gn(this, e, gl, hl, mt, { icons: 0, customise: 1, customisations: 2, route: 3 }) } } function yl(e) { let t, n; return t = new ml({ props: { icons: e[2], customisations: e[0], route: e[1], customise: e[3] } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, [n]) { const i = {}; 4 & n && (i.icons = e[2]), 1 & n && (i.customisations = e[0]), 2 & n && (i.route = e[1]), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function $l(e, t, n) { let { selection: i } = t, { selectionLength: o } = t, { customisations: r } = t, { route: s } = t; const c = Bt("registry"); let l, a, u = !1, f = 0, d = null; function p() { n(7, f++, f) } return Lt((() => { n(6, u = !0) })), Nt((() => { null !== d && d() })), e.$$set = e => { "selection" in e && n(4, i = e.selection), "selectionLength" in e && n(5, o = e.selectionLength), "customisations" in e && n(0, r = e.customisations), "route" in e && n(1, s = e.route) }, e.$$.update = () => { if (1012 & e.$$.dirty) { n(2, l = []); const e = [], t = []; (o ? st(i) : []).forEach((n => { var i; const o = tt.iconToString(n); (null === (i = we.Iconify.getIcon) || void 0 === i ? void 0 : i.call(we.Iconify, o)) ? l.push(n) : d && a && -1 !== a.indexOf(o) ? e.push(o) : (e.push(o), t.push(o)) })), n(9, a = e), t.length && u && (null !== d && d(), n(8, d = ue(t, p))) } }, [r, s, l, function (e, t) { switch (e) { case "width": case "height": "" !== t && 0 !== t || (t = null) }if (void 0 !== r[e] && r[e] !== t) { const n = { [e]: t }; c.callback({ type: "customisation", changed: n, customisations: Object.assign(Object.assign({}, r), n) }) } }, i, o, u, f, d, a] } class vl extends mn { constructor(e) { super(), gn(this, e, $l, yl, mt, { selection: 4, selectionLength: 5, customisations: 0, route: 1 }) } } function bl(e) { let t, n; return t = new vn({ props: { $$slots: { default: [kl] }, $$scope: { ctx: e } } }), { c() { fn(t.$$.fragment) }, m(e, i) { dn(t, e, i), n = !0 }, p(e, n) { const i = {}; 759 & n && (i.$$scope = { dirty: n, ctx: e }), t.$set(i) }, i(e) { n || (nn(t.$$.fragment, e), n = !0) }, o(e) { on(t.$$.fragment, e), n = !1 }, d(e) { pn(t, e) } } } function kl(e) { let t, n, i, o; return t = new Os({ props: { selection: e[0], viewChanged: e[4], error: e[5], route: e[6], blocks: e[7] } }), i = new vl({ props: { selection: e[0], selectionLength: e[1], route: e[6], customisations: e[2] } }), { c() { fn(t.$$.fragment), n = jt(), fn(i.$$.fragment) }, m(e, r) { dn(t, e, r), kt(e, n, r), dn(i, e, r), o = !0 }, p(e, n) { const o = {}; 1 & n && (o.selection = e[0]), 16 & n && (o.viewChanged = e[4]), 32 & n && (o.error = e[5]), 64 & n && (o.route = e[6]), 128 & n && (o.blocks = e[7]), t.$set(o); const r = {}; 1 & n && (r.selection = e[0]), 2 & n && (r.selectionLength = e[1]), 64 & n && (r.route = e[6]), 4 & n && (r.customisations = e[2]), i.$set(r) }, i(e) { o || (nn(t.$$.fragment, e), nn(i.$$.fragment, e), o = !0) }, o(e) { on(t.$$.fragment, e), on(i.$$.fragment, e), o = !1 }, d(e) { pn(t, e), e && _t(n), pn(i, e) } } } function _l(e) { let t, n, i = !0 !== e[3] && bl(e); return { c() { i && i.c(), t = It() }, m(e, o) { i && i.m(e, o), kt(e, t, o), n = !0 }, p(e, [n]) { !0 !== e[3] ? i ? (i.p(e, n), 8 & n && nn(i, 1)) : (i = bl(e), i.c(), nn(i, 1), i.m(t.parentNode, t)) : i && (en(), on(i, 1, 1, (() => { i = null })), tn()) }, i(e) { n || (nn(i), n = !0) }, o(e) { on(i), n = !1 }, d(e) { i && i.d(e), e && _t(t) } } } function wl(e, t, n) { let { registry: i } = t, { selection: o } = t, { selectionLength: r } = t, { customisations: s } = t, { hidden: c } = t, { viewChanged: l } = t, { error: a } = t, { route: u } = t, { blocks: f } = t; var d, p; return d = "registry", p = i, Ft().$$.context.set(d, p), e.$$set = e => { "registry" in e && n(8, i = e.registry), "selection" in e && n(0, o = e.selection), "selectionLength" in e && n(1, r = e.selectionLength), "customisations" in e && n(2, s = e.customisations), "hidden" in e && n(3, c = e.hidden), "viewChanged" in e && n(4, l = e.viewChanged), "error" in e && n(5, a = e.error), "route" in e && n(6, u = e.route), "blocks" in e && n(7, f = e.blocks) }, [o, r, s, c, l, a, u, f, i] } class xl extends mn { constructor(e) { super(), gn(this, e, wl, _l, mt, { registry: 8, selection: 0, selectionLength: 1, customisations: 2, hidden: 3, viewChanged: 4, error: 5, route: 6, blocks: 7 }) } } const Cl = { getIcon: ce, addCollection: le, getAPI: de.getAPI, addAPIProvider: fe }; tt.setIconify(Cl), le({ prefix: lt, icons: { "error-loading": { body: '<g clip-path="url(#clip0)"><path d="M9.9.2l-.2 1C12.7 2 15 4.7 15 8c0 3.9-3.1 7-7 7s-7-3.1-7-7c0-3.3 2.3-6 5.3-6.8l-.2-1C2.6 1.1 0 4.3 0 8c0 4.4 3.6 8 8 8s8-3.6 8-8c0-3.7-2.6-6.9-6.1-7.8z" fill="currentColor"/></g><defs><clipPath id="clip0"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs>' }, empty: { body: "" } }, width: 16, height: 16 }), tt.setComponentsConfig({ list: !1, toggleList: !0, codeTab: "", multiSelect: !1, propsVisible: !0, infoVisible: !1, codeVisible: !1 }); class jl { constructor(e) { this._state = { icons: [], customisations: {} }, this._selection = Object.create(null), this._selectionLength = 0, this._status = "loading", this._container = null, this._params = e; const t = e.state, n = { callback: this._coreCallback.bind(this) }; t && t.config && (n.config = t.config), e.iconSets && (n.iconSets = e.iconSets instanceof Array ? { iconSets: e.iconSets } : e.iconSets), (e => { ie.toggleBrowserCache(e, !1) })("all"); const i = this._core = new tt.IconFinderCore(n), o = this._registry = i.registry; o.setCustom("callback", this._internalCallback.bind(this)), o.setCustom("link", this._externalLinkCallback.bind(this)), ct.length && ct.forEach((e => { const t = tt.convertProviderData("", e); t && tt.addProvider(e.provider, t) })); const r = this._state; r.config = tt.customisedConfig(o.config); const s = o.partialRoute; r.route = s || void 0, t && (t.icons && (t.icons.forEach((e => { let t = "string" == typeof e ? tt.stringToIcon(e) : e; tt.validateIcon(t) && ot(this._selection, t) })), r.icons = st(this._selection), this._selectionLength = r.icons.length), t.customisations && (r.customisations = t.customisations), t.route && setTimeout((() => { o.partialRoute = t.route }))) } getStatus() { return this._status } getState() { return this._state } _hide(e) { switch (this._status) { case "hidden": case "destroyed": return; case "loading": case "": break; default: this._status }this._status = e, this._container && this._container.$set({ hidden: !0 }) } hide() { this._hide("hidden") } destroy() { "destroyed" !== this._status && (this._hide("destroyed"), this._container = null, this._registry.destroy()) } show() { switch (this._status) { case "destroyed": case "loading": case "": return; case "hidden": break; default: this._status }this._status = "", this._container && this._container.$set({ hidden: !1 }) } _initContainer(e) { const t = this._state; let n = !1; switch (this._status) { case "hidden": case "destroyed": n = !0; case "": case "loading": break; default: this._status }const i = { viewChanged: e.viewChanged, error: e.error, blocks: e.blocks, route: e.route ? tt.objectToRoute(e.route) : null, selection: this._selection, selectionLength: this._selectionLength, customisations: it.mergeCustomisations(it.defaultCustomisations, t.customisations ? t.customisations : {}), registry: this._core.registry, hidden: n }, o = { target: this._params.container, props: i }; return new xl(o) } _triggerEvent(e) { "destroyed" !== this._status && this._params.callback && this._params.callback(e) } _coreCallback(e) { if (!this._container) return this._container = this._initContainer(e), "loading" === this._status && (this._status = "", this._triggerEvent({ type: "load" })), void (e.route && this._setRoute(e.route)); const t = this._container, n = e.route, i = n ? tt.objectToRoute(n) : null; e.route = i, e.viewChanged || !tt.compareObjects(e.route, t.$$.props.route) ? (t.$set(e), n && this._setRoute(n)) : "" !== e.error && e.error === t.$$.props.error || t.$set({ error: e.error, blocks: e.blocks }) } _internalCallback(e) { let t, n; switch (e.type) { case "selection": return n = e, t = "string" == typeof n.icon ? tt.stringToIcon(n.icon) : n.icon, void this._selectIcon(t, "boolean" == typeof n.selected ? n.selected : "force", !0); case "customisation": return void this._setCustomisations(e.customisations); case "button": return void this._triggerEvent({ type: "button", button: e.button, state: this._state }); case "config": return this._state.config = tt.customisedConfig(this._registry.config), void this._triggerEvent({ type: "config", config: this._state.config }) } } _externalLinkCallback(e) { if (e && e.target) { const t = e.target.getAttribute("href"); "string" == typeof t && this._triggerEvent({ type: "link", href: t, event: e }) } } _setRoute(e) { const t = this._state; return (void 0 === t.route || !tt.compareObjects(e, t.route)) && (t.route = e, this._triggerEvent({ type: "route", route: e }), !0) } setRoute(e) { if ("destroyed" === this._status) return; const t = this._core.router; function n() { t.partialRoute = e } this._container ? n() : setTimeout(n) } _selectIcon(e, t, n) { const i = this._state, o = () => { if (this._selectionLength = i.icons.length, n && this._container) { const e = { selection: this._selection, selectionLength: this._selectionLength }; this._container.$set(e) } this._triggerEvent({ type: "selection", icons: i.icons }) }; if (!e) return !0 !== t && 1 === i.icons.length && (this._selection = Object.create(null), i.icons = [], o(), !0); const r = !!this._selectionLength && rt(this._selection, e); if (r === t || r && "force" === t) return !1; if ((r || "force" !== t) && this._registry.config.components.multiSelect || (this._selection = Object.create(null)), r ? function (e, t) { if (void 0 === e[t.provider] || void 0 === e[t.provider][t.prefix]) return !1; const n = e[t.provider]; let i = n[t.prefix].length; const o = t.aliases ? t.aliases.concat([t.name]) : [t.name]; n[t.prefix] = n[t.prefix].filter((e => -1 === o.indexOf(e))); const r = i !== n[t.prefix].length; n[t.prefix].length || (delete n[t.prefix], Object.keys(n).length || delete e[t.provider]) }(this._selection, e) : ot(this._selection, e), i.icons = st(this._selection), o(), i.icons.length > 1) { let e = !1; const t = it.mergeCustomisations(it.defaultCustomisations, i.customisations); t.inline && (t.inline = !1, e = !0), e && this._setCustomisations(t) } return !0 } selectIcons(e) { if ("destroyed" === this._status) return; const t = this._state; this._selection = Object.create(null); const n = this._selection; if (e && (this._registry.config.components.multiSelect ? e : e.slice(-1)).forEach((e => { const t = "string" == typeof e ? tt.stringToIcon(e) : e; t && ot(n, t) })), t.icons = st(n), this._selectionLength = t.icons.length, this._container) { const e = { selection: n, selectionLength: this._selectionLength }; this._container.$set(e) } this._triggerEvent({ type: "selection", icons: t.icons }) } _setCustomisations(e) { const t = this._state; return (void 0 === t.customisations || !tt.compareObjects(t.customisations, e)) && (t.customisations = it.filterCustomisations(e), this._container ? this._container.$set({ customisations: e }) : (this._params.state || (this._params.state = {}), this._params.state.customisations = e), this._triggerEvent({ type: "customisations", customisations: e }), !0) } setCustomisations(e) { "destroyed" !== this._status && this._setCustomisations(it.mergeCustomisations(it.defaultCustomisations, e)) } } window.IconFinder = jl; const Il = document.getElementById("iconify-finder"); Il && new jl({ container: Il, callback: e => { console.log("Event:", e) } }) }() }();